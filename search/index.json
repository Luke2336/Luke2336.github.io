[{"content":"一月 參觀了辛志平校長故居。 Amazon 的 Online Assessment。 看完 Psycho Pass 第二季。 去桃園逛 IKEA。 多益的成績公佈了，拿到聽力 415 閱讀 380，總共 795 分。 開始看進擊的巨人。 處理了微學分承認的手續。 和導師和師母吃飯。 回去雙溪奔喪。 和 Google 談好了 Offer。 玩了 zsh 的設定。 自己留在新竹過年。 二月 和學長在愛買一樓的港式飲茶吃飯，聊了滿久的。 和台北來的朋友一起去逛新竹動物園和看電影。 打了第三劑疫苗（BNT），大約燒到 38.1 而已。 和一家叫 Jump Trading 的公司聊了一下。 生日和 Lin Lee 和卡車一起吃飯。 第一次裝 Docker。 跟隊友去吃拿坡里。 去金山泡溫泉。 去新竹台大醫院拔智齒。 8:30 到中醫門診前的採檢站做快篩。 10:40 在口腔外科門診做手術。 麻醉過後，上排的智齒沒多久就被拔起來了。 下排的可能因為長得有點彎，所以拔了很久。 只有縫下面的傷口，上面的沒有縫，下週三下午要去拆線。 11:30 結束。 原本約診的是女醫師，但實際拔牙的是一個男醫生？ 回去後一個小時把紗布拿掉還繼續在流血。 去清大圖書館逛了校史館。 看了神在月的孩子。 和 Lin Lee 去逛竹北新開的大遠百。 晚餐吃了藍屋日本料理，剛好有當月生日優惠，多贈送了一道甜點。Lin Lee 點了一堆毛豆吃。 三月 去台大醫院拆線。 在巴哈上看了 K-ON！輕音部。 跟 PCCA 去吃夜排檔。 申請提畢。 覺得高等 UNIX 的功課 lsof 很難寫。 去台中玩，吃了有點貴的火鍋。 去紀州庵，還有爬仙跡岩，從景美站爬到海巡署。晚餐在公館吃了初牛的牛橫膈丼。 開始用 Notion 寫筆記。 四月 把 markdown 筆記放到 Github 上，發現了 Chrome 一個方便的擴充 GitHub Math Display，讓 Github 的預覽能顯示數學式。 跟學長去竹北逛逛。 去新埔爬文山步道，原本是要跟 Hyperbola 和小凡一起去，但 Hyperbola 騎車前腳受傷，只好跟學弟兩個人去了。 來回是搭新竹客運的 5619，9:38 從新竹火車站出發，11:38 從遠東廠站上車。 地圖節自網路，大概是從 Ａ線上山，D 線下山，沿途的土石有些鬆落，部分路段需要拉著繩索，所以不適合帶小孩走到吧哩國山後面的路段。雖然是平日，還是有遇到三四群人。 風景大概就是竹北高鐵站一區。 午餐吃了巨城附近一家有素食的店八二親食。 羽球期中考拿了滿分。 讀完了《最強睡眠術》，學到了一些新的知識。 在巴哈上面看了大正処女御伽話。 買實名制快篩。 開始在 591 研究租屋。 又去台大醫院拔智齒。 這次拔了右上和右下兩顆智齒。 早上不到八點就去排快篩了。 這次一樣是個年輕的男醫生。 拔完後，下面的智齒牙根斷了一部分留在裡面，但醫生說會跟骨頭融合。如果硬要處理，高機率會傷到神經。 這次相對上次沒什麼腫。 去台北看房。 五月 又去台北看房，這次看到第三間就決定租了。 賣腳踏車。 去馬偕做體檢，覺得服務還算滿不錯的，但我下週還得去補檢體 QQ 公司的體檢項目比想像中少，大致上就是身高體重視力抽血驗尿照X光等等。 簽約後去逛了 IKEA。 5/10 下午手機的網路突然不能用，完全收不到訊號，到傍晚時才可以打電話，弟弟才告訴我是機房的問題，不是我手機壞掉。結果我半個下午都在研究要換 iphone SE3 還是 iphone 13 mini，浪費一堆時間。 買了些氣泡紙和紙箱，準備搬家。 第一次去博愛校區散步。 買了一些襯衫和白 T。 去退國光的回數票，16 張票得到了 1700 左右。 開始常跟 Lin Lee 去打羽球。 隊友們絕交，讓我有些擔心。 和導師還有他電機的導生吃 pizza。 買了一台除濕機，於是被舍監關注。 和小凡和 Lin Lee 在清交拍畢業照。 六月 和隊友們去吃燒肉、壽司郎、港式飲茶。 在 IKEA 線上訂了一些雜物。 學著坐亞聯來回新竹和大坪林。 房間的熱水器似乎壞了，於是讓房東換了個新的。 在線上看了《怪獸與鄧不利多的秘密》。 退宿後寫了一篇關於競程的心得文。 去系辦發現提前畢業沒有畢業紀念證書可以領。 8/26 ~ 8/29 有 Facebook Hacker Cup Qualification Round。 看完了動畫夏洛特，有空可能會補一下同作者的 Clannad。 學校寄信說 11 月底前要將雲端硬碟容量降到 5GB。 為了玩 Flutter 而開始研究 Dart，最後寫了一個能做質因數分解的APP。 去銀行開了證券戶、黃金存摺和外匯帳戶，開始小額投資。 用 pygame 寫了一個 Wordle，目前只做了用鍵盤輸入的版本。 搬家（交大 - 大坪林） 早上七點花了一個小時把東西分成六趟用手推車搬到女二一樓外面。然後在全家買了早餐吃。 九點前，搬家公司很準時的來了，他們大約十分鐘不到就把所有東西搬上車了。他們是開五噸的貨車來，因為我的量不到三點五頓，所以是收 7000，如果超過就會收 9500，這是學生價減 500 後的價格。 十一點前就到大坪林且把所有東西搬到公寓二樓了，非常的有效率，也幫我把東西排得很整齊。 這次找的搬家公司是大新竹搬家公司，覺得價錢比其他家估得便宜，大家有需要可以參考看看。 下圖分別是搬家前和搬完後的照片。 七月 跑完離校，拿到畢業證書。 和隊友們去吃下午茶和去巨城逛街。 去高中數學老師家玩，吃了午餐、玩桌遊和看電視。 北一女校貓黑妞退休了。 日本前首相被暗殺了，令人震驚。 去香山青青草原，走了兩個小時，腿很痠。 7/11 onboard，之前收到的電腦是 2021 macbook pro 14，居然是注音鍵盤。前三天幾乎沒事做，跟主管說第二週再開始進公司。 去交大剪頭髮，然後看到蓮花盛開。 開始定期定額買 ETF。 登入了雙北的圖書館帳戶，想說有空可以借書來打發時間。結果去了新店分館，滿滿的都是人，只好打道回府。雖然座位區看起來明亮舒適，但裡面的書並不多，而且多是舊書，於是有些懷念清交的圖書館。 Work from home 第一週都在看 Training 的影片和資料，但開始上班後還是覺得壓力突然變大了，對於進辦公室後的人際關係有些煩惱，因為完全都沒有認識的人，不像在 101 時有很多熟人。 整理了一些舊照片，在閒暇時間發些文，不然自從學校無限大的 Google Drive 收回去後，改用了 TeraBox，結果很難搜尋照片，只能按照日期慢慢找。 去九讚頭車站爬茶亭古道，下山等公車時遇到一個義消主動讓我們搭便車，他說我們等公車的地方當地人說毛毛的，然後到竹東後，他介紹我們吃莊記牛肉麵。 跟隊友和他朋友去西門町吃炒飯，結果他們帶我走進一家拉麵店，叫做花月嵐，我覺得那家的炒飯確實比拉麵有特色。大概兩年半沒去西門町了，以前大抵上會做的事就是訂做襯衫和西裝褲，還有看電影。 第一天上班好緊張，前一晚在研究自己的辦公桌在哪，發現是在五樓，看了一下平面圖，感覺那邊可以休息的地方比 101 少很多，有些失望。Manager 就坐我對面，覺得有些壓力，但跟同個 Team 的人坐在一塊，應該比較容易熟吧。 第一天的 Office Tour 令人失望，新店辦公室唯一的好處只有早餐和晚餐選項較多、多了下午茶蛋糕而已。 去跟國中和高中老師分別聚會了一次。 去板橋逛百貨公司，本來想買女鞋，但都下不了手。 每天下班都好累，三餐都直接在公司吃，就沒什麼社交生活了。 去看牙醫，結果說很多顆都需要補牙，於是又約了兩次診。 八月 開始到公司頂樓去打羽球，發現人不少。 因為工作的需求，開始學習 Java。 隊友出車禍受傷，於是回學校去看他。 在東區逛街，第一次喝啤酒。 跟高中同學去植物園散步。 領到畢業後第一份薪水，覺得很大一部分都拿去繳房租了，超級心疼。 去北車附近找隊友玩，吃了咖啡弄，因為店員送錯飲料，於是就被招待了一杯飲料。會是一家還想去消費的店，低消是一杯飲料，所以大概就是 180，但尖峰時段有限時，這點有點可惜。 和學長去吃烹星拉麵。 去看了牙醫。 月底感染 Covid-19。 九月 工作開始步上軌道。 發現租屋處好像有蟑螂大便，讓我很緊張，只好買蟑螂藥回來放。 十月 決定寒假要帶弟弟跟媽媽去東京玩，於是訂了虎航的機票，過年期間真的好貴！ 回交大吃了 KFC，週末去看學弟們比 NCPC，中途去了一家有貓咪的咖啡廳。 常常去清大資電館看動漫，晚餐也探索了不少沒吃過的餐廳。 在馬偕附近吃了一家好吃的咖啡廳，怡客咖啡。 貢獻了些題目給 TOPC。 美金漲超過 32 元了，在 29.7 時就開始買了，於是目前已經賺了一萬塊台幣了。 ","date":"2022-10-22T06:37:25+08:00","image":"https://luke2336.github.io/p/2022/1_hu682ff45fbc5a9de78e5b39cebbbfeb55_3521221_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/2022/","title":"記 2022"},{"content":"咖啡店 ★ ★ ★ 怡客咖啡：新竹市東區光復路二段738號號1樓，座位很多，營業時間是 07:00 - 21:00 ★ ★ 空堂咖啡：清大咖啡社，甜點需預訂 墨咖啡 INK COFFEE：新竹市東區林森路180號，咖啡種類多 暗室微光：300新竹市東區勝利路97號，室內沒有四人的座位 飛行樹屋咖啡：新竹市東區光復路二段18巷17號，位置有些小，有提供水煙 清大、交大、馬偕 ★ ★ ★ 成都老鍋牛肉麵：新竹市東區光復路二段126號，牛筋不推 六扇門時尚湯鍋 新竹建功店：新竹市東區建功一路64號，營業到凌晨，交大證件有送火鍋料 3Q脆皮雞排（清大店）：新竹市東區建功一路8號，平價 璽子牛肉麵：新竹市東區博愛街31號 一燒十味昭和園新竹東光町：新竹市東區東光路87號 21風味館 21PLUS 新竹大潤發門市：新竹市東區忠孝路300號1樓，全雞好吃 丸鍋昆布鍋物：新竹市東區東明街231號，肉多 ★ ★ 小木屋鬆餅交大店 清華大學第二招待所 自助餐、印度料理 山口刺身ま丼飯專賣清大店：新竹市東區建功路35號，平價 來來豆漿店：新竹市東區建功路23號，吃宵夜的好地方 永和豆漿大王：新竹市東區建功路45號 海洋冰城/牛排：新竹市東區建功路35號，夏天冰店，冬天牛排店 粥師傅廣東粥：新竹市東區建功一路1號 白鬍子厚切牛排 (清華大學店)：新竹市東區建功一路68號 杜蘭小麥 - 義大利麵披薩：新竹市東區建新路66號2樓 江之戶日式料理：新竹市東區建新路38號 想破頭黃金蛋炒飯：新竹市東區建新路13號 蔥大爺餅舖：新竹市東區建新路29號，通常要排隊 紅吱吱牛排館：新竹市東區光復路二段380號 La stella義式人文餐廳：新竹市東區建功一路172號 老段牛肉麵：新竹市東區建功一路182號 原味燉品屋：新竹市東區建中路7號 八分飽餐廳：新竹市東區建功一路139號，中式餐廳 夜排檔熱炒：新竹市東區公道五路二段346號 金元寶餃子大王：新竹市東區水源街68號，有滷味和冰淇淋 海水屋忠孝店：新竹市東區忠孝路75號，熱炒店，份量比夜排檔小 二月牌沙茶爐 新竹店：新竹市東區東光路107號，以海鮮為主 台灣壹碳烤（新竹店）：新竹市東區忠孝路168號，有射飛鏢 貳壹村精緻麵點：新竹市東區建功一路85號，價格略高 LALA Kitchen 美式餐廳交大店：導聚好地方 榮師傅麵食館：新竹市東區光復路二段10巷15號，份量略大 ★ 立晉傳統豆花：新竹市東區建功一路6號，沒有什麼服務，價格還常常調漲 開源社香雞排：新竹市東區建功路15號 牽漿店：新竹市東區建功路18號 新竹哈奇客Hot Chicken 韓式炸雞：新竹市東區建功一路35號，量少 竹源現炒清大店：新竹市東區建功一路37號，味道有點太重 日荃蒸餃：新竹市東區建新路17號，一家漲價漲過頭的店 段純貞建功店：新竹市東區建功一路135號 上禾烤肉火鍋吃到飽：新竹市東區忠孝路68號 埔頂、新莊、金山街 ★ ★ ★ Appare串酒場-龍山店：新竹市東區龍山西路68號，生意很好 貳樓餐廳 Second Floor Cafe 新竹店：新竹市東區新莊街212號 Pizza Rock：新竹市東區光復路一段251號，份量大 ★ ★ 關埔－美美精緻自助餐廳：新竹市東區埔頂二路116號 竹美私房料理 關新店：新竹市東區關新路160號，中餐廳，有烤鴨 小時厚牛排-新竹光復店：新竹市東區光復路一段375號1樓，店很大 秦老大的小館子：新竹市東區金山街27號，料不多，會吃不飽 釜山崔炸雞-新竹金山店：新竹市東區金山八街108號 新天地美食館：新竹市東區科學園路58號，中餐廳 新竹市區 ★ ★ ★ 和味清粥：新竹市北區長安街36號 ★ ★ 逢甲懷念古早味燉品屋：新竹市北區西大路375號 辛志平校長故居(前棟）TAIVII 餐酒館（後棟）：新竹市東區東門街32號 八二親食 Mama Kim：新竹市東區三民路43號1樓，有素食可選 永和豆漿大王：新竹市東區食品路309號300 水月和洋料理 晶品城：300新竹市東區林森路18號 B2 竹北 ★ ★ ★ Paella 西班牙烤飯餐酒館：新竹縣竹北市勝利十街76號，很適合聚餐 Sun\u0026rsquo;s Dish Cafe \u0026amp; Restaurant：新竹縣竹北市嘉豐五路二段128號，只有開四五六日 ★ ★ 韓食館韓式料理：新竹縣竹北市文田街128號，免費小菜種類很多 ","date":"2022-10-22T05:33:35+08:00","image":"https://luke2336.github.io/p/hsinchu-food/food_hu5c640467fae28920f2c9473278114cac_2690593_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/hsinchu-food/","title":"新竹美食筆記"},{"content":"大家搭平溪線往往都是去十分、平溪和菁桐等觀光老街，能做的活動大抵也就是放天燈。殊不知其他小站都各有一些私房景點，今天將簡單介紹幾個容易去的景點。\n平溪線怎麼搭 (八堵 - 暖暖 - 四腳亭)／(海科館) - 瑞芳 - 侯硐 - 三貂嶺 - 大華 - 十分 - 望古 - 嶺腳 - 平溪 - 菁桐 平溪線班次不多，班距約為一小時。 搭乘西部縱貫線的旅客可以在八堵換車，搭乘宜蘭線則需要在三貂嶺前換車。 望古、嶺腳 從望古車站下車可以發現鐵道旁有一條小徑通往望古瀑布和嶺腳車站。 望古瀑布 距離火車站不遠，半小時內可抵達。 瀑布下有一個潭子，水的顏色非常的夢幻。陽光照射下，彷彿置若仙境，非常適合拍照。 嶺腳寮山登山步道 坡度不陡，不到兩小時就可以抵達嶺腳車站。 沿途會路過一些民宅、廢棄老屋等等，可以遇到三四隻貓咪。 路邊很多紫色小花。 蔡家洋樓 已經荒廢的一間磚造洋樓 福安宮、壺穴 壺穴是一種基隆河中上游常見的自然景觀。 照片攝於 2018/04/08。\n","date":"2022-07-16T21:37:06+08:00","image":"https://luke2336.github.io/p/pingxi/P13_hub7fd9a1cd3dfa8e169dfd3d94f2cf731_615667_120x120_fill_q75_box_smart1.JPG","permalink":"https://luke2336.github.io/p/pingxi/","title":"平溪線 - 望古、嶺腳"},{"content":"就讀一女中期間，學校裡總共有三隻校貓，分別是摩卡、黑妞、小花。之後，摩卡和小花相繼過世，剩下的黑妞近日因為年紀大了，而被某學姊收編。我想以後要再有校貓是很難了，感謝北一貓奴為了校貓的健康盡心盡力，也感謝校貓們總是療癒我們。\n照片 - 小花 照片 - 摩卡 ","date":"2022-07-14T08:31:16+08:00","image":"https://luke2336.github.io/p/tfg_cat/cover_hu4ce34ed272e32367d7355f4be55cb761_6288443_120x120_fill_q75_box_smart1.JPG","permalink":"https://luke2336.github.io/p/tfg_cat/","title":"北一女中的校貓 - 摩卡、小花"},{"content":"瑞芳區一日遊、兩天一夜 瑞芳有哪裡好玩？ 不管喜歡山上，或是海邊，在瑞芳都能玩得盡興。就山區來說，九份、金瓜石會是很好的選擇。若是沿著濱海一帶玩，則可以從水湳洞、陰陽海玩到南雅奇岩。\n交通方式 看著地圖可以發現這些地方都是相通的，如果是開車的話，一天逛完所有景點是可行的。沒車的朋友也不用擔心，這邊將介紹從台北出發的方法。\n火車：從北車到瑞芳。 1061：從忠孝復興經過松山到瑞芳。 1062：同 1061 的路線，但會開上九份和金瓜石。 965：從板橋到金瓜石。 827：從瑞芳到九份。 825：從瑞芳經九份到金瓜石。 788：從瑞芳經過九份、金瓜石到黃金瀑布、水湳洞。 856：從瑞芳車站沿著瑞濱行駛可以到南雅奇岩。 787：從基隆火車站到瑞芳。 九份 可以看到，基山街就是我們現在通稱的九份老街，主要的商家都匯聚於此。但其實九份剛開始發光發亮的年代，位於下面那條輕便路的昇平戲院一帶才是最熱鬧的。\n基山街、九份國小 正餐推薦這家魚丸店，伴手禮會推薦阿蘭草仔粿，最喜歡吃的是那家的芋粿巧，甜點則會推薦阿柑姨芋圓。\n九份國小假日有開放參觀，裡面有盪鞦韆、礦車等等，也是一個看風景的好地方。\n輕便路 除了從老街進到九份以外，還有一個選擇就是從九份派出所往上走。之後，沿著輕便路行走，首先會看到五番坑，接下來會遇到頌德公園，這邊有一條古道可通往猴硐，名為小粗坑古道。過了頌德公園之後，會看到九份有名的一條小隧道。\n基隆山 基隆山的步道算是遮蔭較少，直直攻頂的一條步道，可以看到深澳漁港等沿岸景色，也可以鳥瞰整個山城。\n金瓜石 大家通常會選在黃金博物館站下車。\n黃金博物館、太子賓館 比較值得一看的是四連棟，但需要脫鞋著襪子才能進去參觀。接著可以往金瓜石派出所的方向前進，就可以去到太子賓館，感受一下日式庭園的景觀。\n金瓜石神社 再往上走就是往黃金館和金瓜石神社的方向，有點可惜的是只剩下一些斷垣殘壁，但沿途可以看見不少小動物，像是石龍子等等。\n祈堂老街 往另一個方向走，祈堂老街則是金瓜石民宅、小商店和咖啡廳的聚集地，可以見到很多柏油屋頂的房子。還有一條樓梯漆滿各種顏色，成為彩虹階梯。\n黃金瀑布 黃金瀑布算是下山會路過的一個景點，會有警語寫道水中含有重金屬。\n陰陽海、十三層遺址 十三層遺址其實是以前台金的舊礦場，有時晚上會有點燈活動，值得一看。下面的陰陽海的形成，也和礦區活動有關，黃色和藍色的海水此消彼長，甚是有趣。\n水湳洞 俗稱小九份，晚上燈光亮起後，也是一個美麗的山城。假日的遊客沒有九份那麼多，也有一些商店和有特色的房子。比較有名的是濂洞國小的溜滑梯，但從國小往海邊看，風景也別具一格。\n瑞芳美食街 瑞芳吃的選項可能略比九份來得多，且更有特色，像是龍鳳腿、牛肉麵、米苔目都很有名。除了去美食街外，後站的老街也值得走走。用完餐，再繼續前往猴硐旅行，也是一個好選項。\n","date":"2022-07-13T10:18:38+08:00","image":"https://luke2336.github.io/p/jiufen/cover_hu01aa0ea2162159fd14999c0a3c295d86_6528231_120x120_fill_q75_box_smart1.JPG","permalink":"https://luke2336.github.io/p/jiufen/","title":"瑞芳、金瓜石、九份、水湳洞"},{"content":"Website Link\nBeginning 我會開始使用這個網站是因為我打字速度很慢，總是要看著鍵盤才找得到字，為了讓自己編程的速度加快才開始練習盲打。我使用的時間累積超過 40 hr，從不到 20 WPM 進步到超過 45 WPM。另外，我除了用它練習英打以外，也會用它練習德文鍵盤，但不推薦拿它練習中文。\nWPM = words per minute，每分鐘能打的單字量\nPractice 每個關卡會有要求的速度，達到才能通關進入下一關。剛開始會有一些教學影片和小遊戲，精緻度還滿高的。\n可以看到每一關每次練習的狀況，也會有練習時的錄影（但是這要付費解鎖）。答對的字會以綠底呈現，錯字會以紅底呈現，更正後會呈現黃色。\nStat 這個網站也會有統計一些資料，包括練習時間、速度、準確率、每個鍵的錯誤率和速度等等。\n","date":"2022-07-09T18:43:08+08:00","image":"https://luke2336.github.io/p/typingclub/cover_hu41fd9771eba4303ae9aa92caee867039_232134_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/typingclub/","title":"TypingClub 介紹"},{"content":"馬崗是位於三貂角燈塔下的一個小聚落，介於福隆和頭城之間。\n此篇的照片多於 2017 ~ 2018 年拍攝。以前馬崗有個婆婆固定會餵貓，因此聚集了很多流浪貓，極盛期隨意亂走都能遇到二十幾隻。現在婆婆搬到台北住了，於是以前很多貓就再也沒見過了。再加上馬崗逐漸商業化，不再是從前的小漁村，假日充斥著觀光客。以前不寫馬崗的故事，是希望那邊能永遠保持著純樸的漁村風貌。現在寫下這篇，則是為了緬懷昔日景色。\n貓咪 漁村一隅 漁港風光 ","date":"2022-07-07T07:14:15+08:00","image":"https://luke2336.github.io/p/magang/cover_hub7fd9a1cd3dfa8e169dfd3d94f2cf731_524206_120x120_fill_q75_box_smart1.JPG","permalink":"https://luke2336.github.io/p/magang/","title":"馬崗"},{"content":"線上編譯器 DartPad Hello World! dart Hello.dart\n1// Hello.dart 2void main() { 3 print(\u0026#39;Hello World!\u0026#39;); 4} Comment 1// Inline Comment 2 3/* 4Comment 5*/ Data Type int, double, num String bool List Map Set Number 1void main() { 2 var num1 = 1; 3 print(num1); // 1 4 5 var num2 = 2.05; 6 print(num2); // 2.05 7 8 var num3 = int.parse(\u0026#39;1\u0026#39;); 9 print(num3); // 1 10 11 var num4 = double.parse(\u0026#39;2.05\u0026#39;); 12 print(num4); // 2.05 13 14 var sum = num3 + num4; 15 print(\u0026#39;Sum = ${sum}\u0026#39;); // Sum = 3.05 16} Constant 1void main() { 2 const one = 1; 3 const PI = 3.14; 4 const product = one * PI; 5 print(product); // 3.14 6} String 1void main() { 2 var s1 = \u0026#39;Hello\u0026#39;; 3 var s2 = \u0026#39;World\u0026#39;; 4 var s3 = s1 + \u0026#39; \u0026#39; + s2; 5 print(s3); // Hello World 6 7 String one = 1.toString(); 8 print(one); // 1 9 10 String PI = 3.14159.toStringAsFixed(2); 11 print(PI); // 3.14 12} Boolean 1void main() { 2 String s1 = \u0026#34;Hello\u0026#34;; 3 String s2 = \u0026#34;World\u0026#34;; 4 bool val = (s1 == s2); 5 print(val); // false 6} List 1void main() { 2 var L = [1, 2, 3]; 3 L[0] = 10; 4 print(L); // [10, 2, 3] 5 6 var constL = const [1, 2, 3]; 7 8 var L2 = [1, ...L]; // [1, 10, 2, 3]; 9 print(L2); 10} Set 1void main() { 2 var set1 = {\u0026#39;Monkdy\u0026#39;, \u0026#39;Dog\u0026#39;, \u0026#39;Goat\u0026#39;}; 3 Set\u0026lt;String\u0026gt; empty_set1 = {}; 4 var set2 = \u0026lt;String\u0026gt;{}; 5 set2.add(\u0026#39;Dog\u0026#39;); 6 set2.addAll(set1); 7 print(set2.length); // 3 8} Map 1void main() { 2 var M1 = { 3 \u0026#39;first\u0026#39;: 1, 4 \u0026#39;second\u0026#39;: 2, 5 \u0026#39;third\u0026#39;: 3, 6 }; 7 assert(M1[\u0026#39;fourth\u0026#39;] == null); 8 print(M1[\u0026#39;third\u0026#39;]); // 3 9 10 Map\u0026lt;int, String\u0026gt; M2 = {}; 11 M2[0] = \u0026#39;0\u0026#39;; 12 M2[1999] = \u0026#39;1999\u0026#39;; 13} dynamic, final, const 沒有被宣告類型的變數會被宣告為 dynamic。 final 和 const 都不可以修改，const 用於編譯時期常數。 final(const) dataType name 1void main() { 2 dynamic x = 10; 3 x = 20; 4 final y = x; 5 const z = 10; 6} 位元運算子 \u0026amp; | ~ ^ if, else 1void main() { 2 var x = -1; 3 if (x == 0) { 4 print(\u0026#39;x = 0\u0026#39;); 5 } else if (x \u0026gt; 0) { 6 print(\u0026#39;x \u0026gt; 0\u0026#39;); 7 } else { 8 print(\u0026#39;x \u0026lt; 0\u0026#39;); 9 } 10} switch 1void main() { 2 var ch = \u0026#39;a\u0026#39;; 3 switch(ch) { 4 case \u0026#39;a\u0026#39;: { 5 print(\u0026#39;Apple\u0026#39;); 6 } 7 break; 8 case \u0026#39;b\u0026#39;: { 9 print(\u0026#39;Banana\u0026#39;); 10 } 11 break; 12 default: { 13 print(\u0026#39;Other\u0026#39;); 14 } 15 break; 16 } 17} for 1void main() { 2 var list = [2, 3, 5, 7]; 3 for (var i in list) { 4 print(i); 5 } 6} 7/* 82 93 105 117 12*/ do, while 1void main() { 2 var i = 1; 3 do { 4 print(i); 5 } while (i \u0026lt; 1); 6} 7/* 81 9*/ Function 1void main() { 2 print(test(\u0026#39;hello \u0026#39;, \u0026#39;world\u0026#39;)); // hello world 3} 4String test(String s1, String s2) { 5 return s1 + s2; 6} 1void main() { 2 test(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;); 3} 4void test(s1, [s2, s3]) { 5 print(s1); 6 print(s2); 7 print(s3); 8} 9/* 10a 11b 12null 13*/ 預設引數。 1void main() { 2 test(\u0026#39;a\u0026#39;, s3: \u0026#39;b\u0026#39;); 3} 4void test(s1, {s2, s3: \u0026#39;c\u0026#39;}) { 5 print(s1); 6 print(s2); 7 print(s3); 8} 9/* 10a 11null 12b 13*/ class 格式 1class class_name { 2 \u0026lt;fields\u0026gt; 3 \u0026lt;getters/setters\u0026gt; 4 \u0026lt;constructors\u0026gt; 5 \u0026lt;functions\u0026gt; 6} 繼承和 override 1void main() { 2 Child c = new Child(); 3 c.m(); // child 4} 5 6class Parent { 7 void m() { 8 print(\u0026#39;parent\u0026#39;); 9 } 10} 11 12class Child extends Parent { 13 @override 14 void m() { 15 print(\u0026#39;child\u0026#39;); 16 } 17} this, super static class_name.constructor_name(param_list) .. 1void main() { 2 new Parent() 3 ..m1() 4 ..m2(1); 5} 6 7class Parent { 8 void m1() { 9 print(\u0026#39;parent\u0026#39;); 10 } 11 void m2(int i) { 12 print(i); 13 } 14} ","date":"2022-06-27T03:46:07+08:00","permalink":"https://luke2336.github.io/p/hello_dart/","title":"Dart 筆記"},{"content":"Codeforces Round #790 (Div. 4) 因為下午有些無聊，所以就 virtual 了一場 div. 4，體驗一下 div. 4，但打了 90 分鐘就覺得累到不想打了 QQ 半年多沒打競程，速度掉滿多的，專注力也有差。 pC 一直讀錯題意。 pA. Lucky? 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8int count(int n) { 9 return n / 100 + n / 10 % 10 + n % 10; 10} 11 12int main() { 13 ios::sync_with_stdio(0), cin.tie(0); 14 int n; 15 cin \u0026gt;\u0026gt; n; 16 while (n--) { 17 int t; 18 cin \u0026gt;\u0026gt; t; 19 if (count(t % 1000) == count(t / 1000)) { 20 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; 21 } else { 22 cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; 23 } 24 } 25 return 0; 26} pB. Equal Candies 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8int main() { 9 ios::sync_with_stdio(0), cin.tie(0); 10 int t; 11 cin \u0026gt;\u0026gt; t; 12 while (t--) { 13 int n; 14 cin \u0026gt;\u0026gt; n; 15 vector\u0026lt;int\u0026gt; a(n); 16 for (int i = 0; i \u0026lt; n; i++) { 17 cin \u0026gt;\u0026gt; a[i]; 18 } 19 int m = a[0]; 20 for (int i = 0; i \u0026lt; n; i++) { 21 m = min(m, a[i]); 22 } 23 int sum = 0; 24 for (int i = 0; i \u0026lt; n; i++) { 25 sum += a[i] - m; 26 } 27 cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 } 29 return 0; 30} pC. Most Similar Words 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8int diff(const string \u0026amp;a, const string \u0026amp;b, int m) { 9 int ret = 0; 10 for (int i = 0; i \u0026lt; m; i++) { 11 ret += abs(a[i] - b[i]); 12 } 13 return ret; 14} 15 16int main() { 17 ios::sync_with_stdio(0), cin.tie(0); 18 int t; 19 cin \u0026gt;\u0026gt; t; 20 while (t--) { 21 int n, m; 22 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 23 vector\u0026lt;string\u0026gt; s(n); 24 for (int i = 0; i \u0026lt; n; i++) { 25 cin \u0026gt;\u0026gt; s[i]; 26 } 27 int ans = 26 * 8; 28 for (int i = 0; i \u0026lt; n; i++) { 29 for (int j = i + 1; j \u0026lt; n; j++) { 30 ans = min(ans, diff(s[i], s[j], m)); 31 } 32 } 33 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 34 } 35 return 0; 36} pD. X-Sum 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8int main() { 9 ios::sync_with_stdio(0), cin.tie(0); 10 int t; 11 cin \u0026gt;\u0026gt; t; 12 while (t--) { 13 int n, m; 14 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 15 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a(n, vector\u0026lt;int\u0026gt;(m)); 16 for (int i = 0; i \u0026lt; n; i++) { 17 for (int j = 0; j \u0026lt; m; j++) { 18 cin \u0026gt;\u0026gt; a[i][j]; 19 } 20 } 21 map\u0026lt;int, int\u0026gt; cnt_sum; 22 map\u0026lt;int, int\u0026gt; cnt_diff; 23 for (int i = 0; i \u0026lt; n; i++) { 24 for (int j = 0; j \u0026lt; m; j++) { 25 cnt_sum[i + j] += a[i][j]; 26 cnt_diff[i - j] += a[i][j]; 27 } 28 } 29 int ans = 0; 30 for (int i = 0; i \u0026lt; n; i++) { 31 for (int j = 0; j \u0026lt; m; j++) { 32 ans = max(cnt_sum[i + j] + cnt_diff[i - j] - a[i][j], ans); 33 } 34 } 35 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 36 } 37 return 0; 38} pE. Eating Queries 前綴和＋二分搜。 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8int main() { 9 ios::sync_with_stdio(0), cin.tie(0); 10 int t; 11 cin \u0026gt;\u0026gt; t; 12 while (t--) { 13 int n, q; 14 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 15 vector\u0026lt;int\u0026gt; a(n); 16 for (int i = 0; i \u0026lt; n; i++) { 17 cin \u0026gt;\u0026gt; a[i]; 18 } 19 sort(a.begin(), a.end()); 20 reverse(a.begin(), a.end()); 21 vector\u0026lt;int\u0026gt; sum(n); 22 sum[0] = a[0]; 23 for (int i = 1; i \u0026lt; n; i++) { 24 sum[i] = sum[i - 1] + a[i]; 25 } 26 while (q--) { 27 int x; 28 cin \u0026gt;\u0026gt; x; 29 int ans = lower_bound(sum.begin(), sum.end(), x) - sum.begin() + 1; 30 if (ans \u0026gt; n) ans = -1; 31 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 32 } 33 } 34 return 0; 35} pF. Longest Strike 爬行法＋離散化。 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8int main() { 9 ios::sync_with_stdio(0), cin.tie(0); 10 int t; 11 cin \u0026gt;\u0026gt; t; 12 while (t--) { 13 int n, k; 14 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; 15 vector\u0026lt;int\u0026gt; a(n); 16 map\u0026lt;int, int\u0026gt; sum; 17 for (int i = 0; i \u0026lt; n; i++) { 18 cin \u0026gt;\u0026gt; a[i]; 19 sum[a[i]]++; 20 } 21 vector\u0026lt;int\u0026gt; cnt; 22 vector\u0026lt;int\u0026gt; num; 23 for (auto p : sum) { 24 num.push_back(p.first); 25 cnt.push_back(p.second); 26 } 27 int L = -1, R = -1; 28 for (int l = 0, r = 0; l \u0026lt; cnt.size(); l++) { 29 if (cnt[l] \u0026lt; k) continue; 30 for (r = max(r, l); r \u0026lt; cnt.size() and cnt[r] \u0026gt;= k and num[r] - num[l] == r - l; r++) { 31 } 32 r--; 33 if (num[r] - num[l] \u0026gt;= R - L) { 34 R = num[r], L = num[l]; 35 } 36 } 37 if (L == -1) { 38 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 39 } else { 40 cout \u0026lt;\u0026lt; L \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; R \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 41 } 42 } 43 return 0; 44} pG. White-Black Balanced Subtrees DFS＋DP。 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8int dfs(int i, const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;children, const string \u0026amp;color, int \u0026amp;ans) { 9 int ret = color[i] == \u0026#39;B\u0026#39; ? 1 : -1; 10 for (int u : children[i]) { 11 ret += dfs(u, children, color, ans); 12 } 13 if (ret == 0) ans++; 14 return ret; 15} 16 17int main() { 18 ios::sync_with_stdio(0), cin.tie(0); 19 int T; 20 cin \u0026gt;\u0026gt; T; 21 while (T--) { 22 int n; 23 cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; children(n); 25 for (int i = 1; i \u0026lt; n; i++) { 26 int p; 27 cin \u0026gt;\u0026gt; p; 28 children[p - 1].emplace_back(i); 29 } 30 string color; 31 cin \u0026gt;\u0026gt; color; 32 int ans = 0; 33 dfs(0, children, color, ans); 34 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 35 } 36 return 0; 37} pH. Maximum Crossings 逆序數對。 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8void solve(vector\u0026lt;ll\u0026gt; \u0026amp;a, vector\u0026lt;ll\u0026gt; \u0026amp;b, int l, int r, ll \u0026amp;ans) { 9 if (l \u0026gt;= r) return; 10 int mid = (l + r) / 2; 11 solve(a, b, l, mid, ans); 12 solve(a, b, mid + 1, r, ans); 13 int li = l, ri = mid + 1; 14 for (int i = l; i \u0026lt;= r; i++) { 15 if (ri \u0026gt; r or (li \u0026lt;= mid \u0026amp;\u0026amp; a[li] \u0026lt; a[ri])) { 16 b[i] = a[li++]; 17 ans += ri - mid - 1; 18 } else { 19 b[i] = a[ri++]; 20 } 21 } 22 for (int i = l; i \u0026lt;= r; i++) { 23 a[i] = b[i]; 24 } 25} 26 27int main() { 28 ios::sync_with_stdio(0), cin.tie(0); 29 int T; 30 cin \u0026gt;\u0026gt; T; 31 while (T--) { 32 int n; 33 cin \u0026gt;\u0026gt; n; 34 vector\u0026lt;ll\u0026gt; a(n), b(n); 35 for (int i = 0; i \u0026lt; n; i++) { 36 cin \u0026gt;\u0026gt; a[i]; 37 } 38 ll ans = 0; 39 solve(a, b, 0, n - 1, ans); 40 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 41 } 42 return 0; 43} ","date":"2022-06-19T15:02:44+08:00","image":"https://luke2336.github.io/p/cf_contest_1676/Standing_hu98593b0e95aff81b7013ecf42b856739_107298_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/cf_contest_1676/","title":"Codeforces Round 790 Div. 4"},{"content":"Chapter 1 1.4 Wormholes 題意：有 12 個蟲洞，要配對成兩兩一組，一旦碰到蟲洞就會被傳送到另一端，且一直往 +X 方向移動，問有多少種組合能形成環？ 這題是很好的題目，能練習實作暴搜。首先要會 DFS 枚舉組合，方法是每次找到第一個沒被用到的點，然後枚舉能和他匹配的點。之後再檢查每個組合是否有環，採取 BFS，每次走兩步，先一步蟲洞，再走到下一個點。 1/* 2ID: whitech1 3TASK: wormhole 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8typedef pair\u0026lt;int, int\u0026gt; pii; 9#define x first 10#define y second 11int n, ans = 0; 12vector\u0026lt;pii\u0026gt; p; 13vector\u0026lt;vector\u0026lt;bool\u0026gt; \u0026gt; G; 14vector\u0026lt;int\u0026gt; pr; 15bool check() { 16 vector\u0026lt;int\u0026gt; visit(n); 17 queue\u0026lt;int\u0026gt; q; 18 for (int i = 0; i \u0026lt; n; i++) q.push(i); 19 while (!q.empty()) { 20 int u = q.front(); q.pop(); 21 if (visit[u] \u0026gt; 2 * n) return true; 22 for (int i = 0; i \u0026lt; n; i++) { 23 if (G[pr[u]][i]) 24 q.push(i), visit[i] = visit[u] + 2; 25 } 26 } 27 return false; 28} 29void per(int cnt) { 30 if (cnt == n) { 31 if (check()) ans++; 32 return; 33 } 34 for (int i = 0; i \u0026lt; n; i++) { 35 if (pr[i] != -1) continue; 36 for (int j = i + 1; j \u0026lt; n; j++) { 37 if (pr[j] != -1) continue; 38 pr[i] = j, pr[j] = i; 39 per(cnt + 2); 40 pr[i] = pr[j] = -1; 41 } 42 break; 43 } 44} 45int main() { 46 freopen(\u0026#34;wormhole.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 47 freopen(\u0026#34;wormhole.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 48 cin \u0026gt;\u0026gt; n; 49 p.resize(n), pr.resize(n, -1); 50 G.resize(n, vector\u0026lt;bool\u0026gt;(n)); 51 for (int i = 0; i \u0026lt; n; i++) 52 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 53 sort(p.begin(), p.end()); 54 for (int i = 0; i \u0026lt; n; i++) 55 for (int j = i + 1; j \u0026lt; n; j++) 56 if (p[i].y == p[j].y) { 57 G[i][j] = true; 58 break; 59 } 60 per(0); 61 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 62 return 0; 63} 1.4 Ski Course Design 1/* 2ID: whitech1 3TASK: skidesign 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8inline int d(int x) {return x * x;} 9int main() { 10 freopen(\u0026#34;skidesign.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 11 freopen(\u0026#34;skidesign.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 12 int n; cin \u0026gt;\u0026gt; n; 13 vector\u0026lt;int\u0026gt; v(n); 14 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; 15 sort(v.begin(), v.end()); 16 int ans = n * d(100); 17 for (int m = 0; m \u0026lt;= 100; m++) { 18 int cnt = 0; 19 for (int a : v) 20 if (a \u0026lt; m) cnt += d(m - a); 21 else if (a \u0026gt; m + 17) cnt += d(a - m - 17); 22 ans = min(ans, cnt); 23 } 24 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 25 return 0; 26} 1.5 Arithmetic Progressions 題意：枚舉 p * p + q * q (0 ≤ p, q ≤ m ≤ 250)序列中的長度為 n ≤ 25 的序列。時間為 5 秒。 作法：把序列先用 bool seq[2 * m * m + 1] 紀錄。枚舉前兩個元素來檢查序列。 1/* 2ID: whitech1 3TASK: ariprog 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8typedef pair\u0026lt;int, int\u0026gt; pii; 9set\u0026lt;int\u0026gt; s; 10int main() { 11 freopen(\u0026#34;ariprog.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 12 freopen(\u0026#34;ariprog.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 13 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 14 vector\u0026lt;int\u0026gt; sq(m + 1); 15 for (int i = 1; i \u0026lt;= m; i++) sq[i] = i * i; 16 for (int i = 0; i \u0026lt;= m; i++) 17 for (int j = i; j \u0026lt;= m; j++) 18 s.insert(sq[i] + sq[j]); 19 set\u0026lt;pii\u0026gt; ans; 20 vector\u0026lt;int\u0026gt; v(s.begin(), s.end()); 21 vector\u0026lt;bool\u0026gt; seq(2 * m * m + 1); 22 for (int i : v) seq[i] = true; 23 for (int i : v) { 24 for (int j : v) { 25 if (i \u0026gt;= j) continue; 26 int d = j - i; 27 bool success = true; 28 for (int k = i + (n - 1) * d; k \u0026gt; j; k -= d) 29 if (k \u0026gt;= seq.size() || !seq[k]) { 30 success = false; 31 break; 32 } 33 if (success) ans.insert(pii(d, i)); 34 } 35 } 36 for (auto i : ans) cout \u0026lt;\u0026lt; i.second \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i.first \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 37 if (!ans.size()) cout \u0026lt;\u0026lt; \u0026#34;NONE\\n\u0026#34;; 38 return 0; 39} 1.5 Mother\u0026rsquo;s Milk 題意：給定 1 ≤ A, B, C ≤ 20，三個桶子，問 A 桶為空時，C 有哪些可能的容量。 1/* 2ID: whitech1 3TASK: milk3 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8int a, b, c; 9bool ans[25][25][25]; 10void solve(int x, int y, int z) { 11 if (ans[x][y][z]) return; 12 ans[x][y][z] = true; 13 int d; 14 // A -\u0026gt; B 15 d = min(x, b - y); 16 solve(x - d, y + d, z); 17 // A -\u0026gt; C 18 d = min(x, c - z); 19 solve(x - d, y, z + d); 20 // B -\u0026gt; A 21 d = min(a - x, y); 22 solve(x + d, y - d, z); 23 // B -\u0026gt; C 24 d = min(y, c - z); 25 solve(x, y - d, z + d); 26 // C -\u0026gt; A 27 d = min(a - x, z); 28 solve(x + d, y, z - d); 29 // C -\u0026gt; B 30 d = min(b - y, z); 31 solve(x, y + d, z - d); 32} 33int main() { 34 freopen(\u0026#34;milk3.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 35 freopen(\u0026#34;milk3.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 36 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; 37 solve(0, 0, c); 38 for (int i = 0; i \u0026lt; c; i++) 39 if (c - i \u0026lt;= b \u0026amp;\u0026amp; ans[0][c - i][i]) 40 cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 41 cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 42 return 0; 43} 1.6 Binary Numbers Value Binary Sample Meaning x 00101100 the original x value x \u0026amp; -x 00000100 extract lowest bit set `x -x` 11111100 x ^ -x 11111000 create mask bits to left of lowest bit set x \u0026amp; (x - 1) 00101000 strip off lowest bit set `x (x - 1)` 00101111 x ^ (x - 1) 00000111 create mask for lowest-set-bit \u0026amp; bits to its right ~x \u0026amp; (x - 1) 00000011 create mask for bits to right of lowest bit set `x (x + 1)` 00101101 x / (x \u0026amp; -x) 00001011 shift number right so lowest set bit is at bit 0 1.6 Number Triangles 1/* 2ID: whitech1 3TASK: numtri 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8int main() { 9 freopen(\u0026#34;numtri.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 10 freopen(\u0026#34;numtri.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 11 int r; cin \u0026gt;\u0026gt; r; 12 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; a(r); 13 for (int i = 0; i \u0026lt; r; i++) { 14 a[i].resize(i + 1); 15 for (int j = 0; j \u0026lt;= i; j++) 16 cin \u0026gt;\u0026gt; a[i][j]; 17 } 18 for (int i = 1; i \u0026lt; r; i++) 19 for (int j = 0; j \u0026lt;= i; j++) 20 a[i][j] += max(a[i - 1][max(0, j - 1)], 21 a[i - 1][min(i - 1, j)]); 22 int ans = 0; 23 for (int j = 0; j \u0026lt; r; j++) 24 ans = max(ans, a[r - 1][j]); 25 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 26 return 0; 27} 1.6 Prime Palindromes 題意：找 [a, b] 中同時為迴文和質數的數。 方法：枚舉迴文，再檢查使否為質數，相反會超時。可以發現除了 11 以外的偶位數迴文都會被 11 整除，即非質數。 1/* 2ID: whitech1 3TASK: pprime 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8vector\u0026lt;int\u0026gt; prime; 9bool isprime[10000]; 10void gen_prime() { 11 prime.push_back(2); 12 for (int i = 3; i \u0026lt; 10000; i += 2) { 13 if (isprime[i]) continue; 14 prime.push_back(i); 15 for (int j = i * i; j \u0026lt; 10000; j += 2 * i) 16 isprime[j] = true; 17 } 18} 19bool check_prime(int x) { 20 for (int p : prime) { 21 if (p * p \u0026gt; x) return true; 22 if (x % p == 0) return false; 23 } 24 return true; 25} 26int num(int x) { 27 int ret = x; 28 vector\u0026lt;int\u0026gt; v; 29 while (x) { 30 v.push_back(x % 10); 31 x /= 10; 32 } 33 for (int i = 1; i \u0026lt; v.size(); i++) 34 ret = ret * 10 + v[i]; 35 return ret; 36} 37int main() { 38 freopen(\u0026#34;pprime.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 39 freopen(\u0026#34;pprime.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 40 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 41 gen_prime(); 42 vector\u0026lt;int\u0026gt; ans; 43 int c[] = {2, 3, 5, 7, 11}; 44 for (int i : c) 45 if (a \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt;= b) 46 ans.push_back(i); 47 for (int i = 10; i \u0026lt; 10000; i++) { 48 int x = num(i); 49 if (a \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= b \u0026amp;\u0026amp; check_prime(x)) 50 ans.push_back(x); 51 } 52 for (int i : ans) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 53 return 0; 54} 1.6 Superprime Rib 1/* 2ID: whitech1 3TASK: sprime 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8vector\u0026lt;int\u0026gt; prime; 9bool isprime[10000]; 10void gen_prime() { 11 prime.push_back(2); 12 for (int i = 3; i \u0026lt; 10000; i += 2) { 13 if (isprime[i]) continue; 14 prime.push_back(i); 15 for (int j = i * i; j \u0026lt; 10000; j += 2 * i) 16 isprime[j] = true; 17 } 18} 19bool check_prime(int x) { 20 if (x \u0026lt; 2) return false; 21 for (int p : prime) { 22 if (p * p \u0026gt; x) return true; 23 if (x % p == 0) return false; 24 } 25 return true; 26} 27vector\u0026lt;int\u0026gt; ans; 28void solve(int cnt, int n, int num) { 29 if (cnt == n) { 30 ans.push_back(num); 31 return; 32 } 33 for (int i = 1; i \u0026lt;= 9; i++) { 34 int d = num * 10 + i; 35 if (check_prime(d)) solve(cnt + 1, n, d); 36 } 37} 38int main() { 39 freopen(\u0026#34;sprime.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 40 freopen(\u0026#34;sprime.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 41 int n; cin \u0026gt;\u0026gt; n; 42 gen_prime(); 43 solve(0, n, 0); 44 for (int i : ans) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 45 return 0; 46} Chapter 2 2.1 The Castle \u0026ldquo;Farthest to the west\u0026rdquo; 是指「最西邊」。 題意：給定每個房間的四道牆，問拆一道牆能形成的最大房間大小。 解法：Flood Fill 算出每個房間的大小，再試著拆每道牆。 1/* 2ID: whitech1 3TASK: castle 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8const char D[5] = \u0026#34;WNES\u0026#34;; 9const int dx[4] = {0, -1, 0, 1}; 10const int dy[4] = {-1, 0, 1, 0}; 11int main() { 12 freopen(\u0026#34;castle.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 13 freopen(\u0026#34;castle.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 14 int n, m; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; 15 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; w(n, vector\u0026lt;int\u0026gt;(m)); 16 for (int i = 0; i \u0026lt; n; i++) 17 for (int j = 0; j \u0026lt; m; j++) 18 cin \u0026gt;\u0026gt; w[i][j]; 19 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; G(n, vector\u0026lt;int\u0026gt;(m)); 20 vector\u0026lt;int\u0026gt; sz(1); 21 int mx = 0; 22 for (int i = 0; i \u0026lt; n; i++) { 23 for (int j = 0; j \u0026lt; m; j++) { 24 if (G[i][j]) continue; 25 queue\u0026lt;int\u0026gt; qx, qy; 26 qx.push(i), qy.push(j); 27 G[i][j] = sz.size(); 28 sz.push_back(1); 29 while (!qx.empty()) { 30 int x = qx.front(); qx.pop(); 31 int y = qy.front(); qy.pop(); 32 for (int d = 0; d \u0026lt; 4; d++) { 33 if ((1 \u0026lt;\u0026lt; d) \u0026amp; w[x][y]) continue; 34 int xx = x + dx[d], yy = y + dy[d]; 35 if (G[xx][yy]) continue; 36 G[xx][yy] = G[x][y]; 37 qx.push(xx), qy.push(yy); 38 sz.back()++; 39 } 40 } 41 mx = max(mx, sz.back()); 42 } 43 } 44 cout \u0026lt;\u0026lt; sz.size() - 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 45 mx = 0; 46 int ax, ay; char dir; 47 for (int j = 0; j \u0026lt; m; j++) { 48 for (int i = n - 1; i \u0026gt;= 0; i--) { 49 for (int d = 1; d \u0026lt;= 2; d++) { 50 if ((1 \u0026lt;\u0026lt; d) \u0026amp; w[i][j]) { 51 int ii = i + dx[d], jj = j + dy[d]; 52 if (ii \u0026lt; 0 || jj \u0026gt;= m) continue; 53 if (G[ii][jj] == G[i][j]) continue; 54 if (sz[G[i][j]] + sz[G[ii][jj]] \u0026gt; mx) { 55 mx = sz[G[i][j]] + sz[G[ii][jj]]; 56 ax = i, ay = j, dir = D[d]; 57 } 58 } 59 } 60 } 61 } 62 cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; ax + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ay + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; dir \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 63 return 0; 64} 2.1 Ordered Fractions 題意：枚舉出 0 ~ 1 之間，分母最大為 N ≤ 160 的分數，依照大小印出。 解法：只將分子與分母互質的最簡分數(reduced fraction)放入，再定義大小排序。 1/* 2ID: whitech1 3TASK: frac1 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8typedef pair\u0026lt;int, int\u0026gt; frac; 9#define x first 10#define y second 11bool cmp (const frac \u0026amp;a, const frac \u0026amp;b) { 12 return a.x * b.y \u0026lt; a.y * b.x; 13} 14int main() { 15 freopen(\u0026#34;frac1.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 16 freopen(\u0026#34;frac1.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 17 int n; cin \u0026gt;\u0026gt; n; 18 vector\u0026lt;frac\u0026gt; v; 19 v.push_back(frac(0, 1)); 20 for (int i = 1; i \u0026lt;= n; i++) 21 for (int j = 1; j \u0026lt;= i; j++) 22 if (__gcd(i, j) == 1) 23 v.push_back(frac(j, i)); 24 sort(v.begin(), v.end(), cmp); 25 for (frac f : v) cout \u0026lt;\u0026lt; f.x \u0026lt;\u0026lt; \u0026#39;/\u0026#39; \u0026lt;\u0026lt; f.y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 26 return 0; 27} 2.1 Sorting a Three-Valued Sequence 題意：給定一個長度為 n ≤ 1000 的序列，元素只有 1, 2, 3，操作為將任意兩個位置的元素交換，問最少要幾個操作才能將序列排序？ 解法：Greedy，先將陣列排序，和原陣列比較。若兩兩交換能到對的位置則交換，各消耗 1 次操作。其餘會形成 cycle，cycle 需要 2 次操作。 1/* 2ID: whitech1 3TASK: sort3 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8int main() { 9 freopen(\u0026#34;sort3.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 10 freopen(\u0026#34;sort3.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 11 int n; cin \u0026gt;\u0026gt; n; 12 vector\u0026lt;int\u0026gt; a(n); 13 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 14 vector\u0026lt;int\u0026gt; b(a.begin(), a.end()); 15 sort(b.begin(), b.end()); 16 int c[4][4] = {}; 17 for (int i = 0; i \u0026lt; n; i++) 18 if (a[i] != b[i]) c[a[i]][b[i]]++; 19 int ans = 0; 20 for (int i = 1; i \u0026lt; 3; i++) { 21 for (int j = i + 1; j \u0026lt;= 3; j++) { 22 int d = min(c[i][j], c[j][i]); 23 ans += d, c[i][j] -= d, c[j][i] -= d; 24 } 25 } 26 int tmp = 0; 27 for (int i = 1; i \u0026lt;= 3; i++) 28 for (int j = 1; j \u0026lt;= 3; j++) 29 tmp += c[i][j]; 30 cout \u0026lt;\u0026lt; ans + tmp * 2 / 3 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 31 return 0; 32} 2.1 Healthy Holsteins 題意：牛需要 V 種維他命。有 G 種飼料可選擇，問最少要選擇幾種飼料，才能使維他命的和達到牛所需的量。 解法：枚舉所有組合檢查。 複雜度：$$O(VG2^G)$$ 1/* 2ID: whitech1 3TASK: holstein 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8int main() { 9 freopen(\u0026#34;holstein.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 10 freopen(\u0026#34;holstein.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 11 int v; cin \u0026gt;\u0026gt; v; 12 vector\u0026lt;int\u0026gt; need(v); 13 for (int i = 0; i \u0026lt; v; i++) cin \u0026gt;\u0026gt; need[i]; 14 int n; cin \u0026gt;\u0026gt; n; 15 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; vit(n, vector\u0026lt;int\u0026gt;(v)); 16 for (int i = 0; i \u0026lt; n; i++) 17 for (int j = 0; j \u0026lt; v; j++) 18 cin \u0026gt;\u0026gt; vit[i][j]; 19 int N = 1 \u0026lt;\u0026lt; n; 20 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(N, vector\u0026lt;int\u0026gt;(v)); 21 int ans = n, id = N - 1; 22 for (int i = 0; i \u0026lt; N; i++) { 23 int cnt = 0; 24 for (int j = 0; j \u0026lt; n; j++) { 25 if ((1 \u0026lt;\u0026lt; j) \u0026amp; i) cnt++; 26 else for (int r = 0, k = i | (1 \u0026lt;\u0026lt; j); !dp[k][r] \u0026amp;\u0026amp; r \u0026lt; v; r++) 27 dp[k][r] = dp[i][r] + vit[j][r]; 28 } 29 bool success = true; 30 for (int r = 0; r \u0026lt; v; r++) 31 if (dp[i][r] \u0026lt; need[r]) success = false; 32 if (success) { 33 if (cnt \u0026lt; ans) ans = cnt, id = i; 34 else if (cnt \u0026lt;= ans) id = min(i, id); 35 } 36 } 37 cout \u0026lt;\u0026lt; ans; 38 for (int i = 0; i \u0026lt; n; i++) 39 if (id \u0026amp; (1 \u0026lt;\u0026lt; i)) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; i + 1; 40 cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 41 return 0; 42} 2.1 Hamming Codes 題意：輸出一個大小為 N ≤ 64 的集合，裡面的元素長度為 B ≤ 8 個 bits，兩兩 Hamming distance 不小於 D ≤ 7。 解法：測資弱，直接暴力枚舉。用 __builtin_popcount(x) 算幾個 1-bit。 1/* 2ID: whitech1 3TASK: hamming 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8typedef unsigned int ui; 9vector\u0026lt;ui\u0026gt; ans; 10bool success = false; 11int N, M, D, B; 12void dfs() { 13 if (success) return; 14 if (ans.size() == N) { 15 success = true; 16 sort(ans.begin(), ans.end()); 17 for (int i = 0; i \u0026lt; N; i++) 18 cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i % 10 == 9 || i == N - 1]; 19 return; 20 } 21 for (ui i = 0; i \u0026lt; M \u0026amp;\u0026amp; !success; i++) { 22 bool add = true; 23 for (ui x : ans) { 24 if (__builtin_popcount(i ^ x) \u0026lt; D) { 25 add = false; break; 26 } 27 } 28 if (add) { 29 ans.push_back(i); 30 dfs(); 31 ans.pop_back(); 32 } 33 } 34} 35int main() { 36 freopen(\u0026#34;hamming.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 37 freopen(\u0026#34;hamming.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 38 int B; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; B \u0026gt;\u0026gt; D; 39 M = 1 \u0026lt;\u0026lt; B; 40 dfs(); 41 return 0; 42} 2.2 Preface Numbering 題意：給定 N ≤ 3500，計算 1 ~ N 的羅馬字母表示法共用了每種字母個幾個。 1/* 2ID: whitech1 3TASK: preface 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8int d[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; 9string s[13] = {\u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34;}; 10int cnt[13]; 11void solve(int x) { 12 for (int i = 0; i \u0026lt; 13; i++) { 13 cnt[i] += x / d[i]; 14 x %= d[i]; 15 } 16} 17int main() { 18 freopen(\u0026#34;preface.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 19 freopen(\u0026#34;preface.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 20 int n; cin \u0026gt;\u0026gt; n; 21 for (int i = 1; i \u0026lt;= n; i++) solve(i); 22 int ans[7] = {}; 23 char c[8] = \u0026#34;IVXLCDM\u0026#34;; 24 for (int i = 0; i \u0026lt; 13; i++) 25 for (int j = 0; j \u0026lt; 7; j++) 26 for (char ch : s[i]) 27 if (ch == c[j]) ans[j] += cnt[i]; 28 for (int i = 0; i \u0026lt; 7; i++) 29 if (ans[i]) cout \u0026lt;\u0026lt; c[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 30 return 0; 31} 2.2 Subset Sums 題意：給定 N ≤ 39，計算 1 ~ N 有幾種分法能使兩堆一樣多。 1/* 2ID: whitech1 3TASK: subset 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8inline int sum(int x) {return x * (x + 1) \u0026gt;\u0026gt; 1;} 9int main() { 10 freopen(\u0026#34;subset.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 11 freopen(\u0026#34;subset.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 12 int n; cin \u0026gt;\u0026gt; n; 13 int m = sum(n); 14 if (m \u0026amp; 1) { 15 cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; 16 return 0; 17 } 18 m \u0026gt;\u0026gt;= 1; 19 vector\u0026lt;long long\u0026gt; dp(m + 1); 20 dp[0] = 1; 21 for (int i = 1; i \u0026lt;= n; i++) 22 for (int j = min(sum(i), m); j \u0026gt;= i; j--) 23 dp[j] += dp[j - i]; 24 cout \u0026lt;\u0026lt; (dp[m] \u0026gt;\u0026gt; 1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 25 return 0; 26} 2.2 Runaround Numbers 題意：給定 M ≤ 2^32，找出一個大於 M 的循環數。循環數的定義為，沒用到 0，且每個位元不重複，從第一個位元 d 開始向右走 d 位，走到最右邊則從最左邊繼續，然後在從此位繼續，走完全部回到第一位且不重複。 解法：DFS 暴搜所有解，不斷更新最小值剪枝。 1/* 2ID: whitech1 3TASK: runround 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8typedef long long ll; 9ll m; 10vector\u0026lt;int\u0026gt; v; 11bool used[10]; 12bool check(ll num, int len) { 13 if (num \u0026lt;= m) return false; 14 vector\u0026lt;int\u0026gt; cnt(len); 15 for (int i = 0, r = 0; i \u0026lt; len; i++) { 16 r = (r + v[r]) % len; 17 cnt[r]++; 18 } 19 for (int i = 0; i \u0026lt; len; i++) 20 if (!cnt[i]) return false; 21 return true; 22} 23ll ans = 987654321LL; 24void solve(ll now, int len) { 25 if (check(now, len)) ans = min(ans, now); 26 if (now \u0026gt;= ans) return; 27 for (int i = 1; i \u0026lt;= 9; i++) { 28 if (used[i]) continue; 29 used[i] = true, v.push_back(i); 30 solve(now * 10 + i, len + 1); 31 used[i] = false, v.pop_back(); 32 } 33} 34int main() { 35 freopen(\u0026#34;runround.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 36 freopen(\u0026#34;runround.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 37 cin \u0026gt;\u0026gt; m; 38 solve(0, 0); 39 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 40 return 0; 41} 2.2 Party Lamps 題意：給定 N ≤ 100 和 C ≤ 10000。一開始有 N 盞燈，及四種按鈕，分別為所有燈、奇數燈、偶數燈、3K + 1 狀態改變。以及給定某些燈的狀態。C 為按下按鈕的總次數，求輸出所有最後可能的狀態。 解法：只需要考慮四種按鈕分別按下的奇偶性，以及和 C 的大小及奇偶是否一致。然後枚舉 16 種狀態去花 O(N) 確認。 1/* 2ID: whitech1 3TASK: lamps 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8void input(vector\u0026lt;int\u0026gt; \u0026amp;v) { 9 int x; 10 while (cin \u0026gt;\u0026gt; x \u0026amp;\u0026amp; x != -1) v.push_back(x); 11} 12int main() { 13 freopen(\u0026#34;lamps.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 14 freopen(\u0026#34;lamps.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 15 int n, c; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c; 16 vector\u0026lt;int\u0026gt; on, off; 17 input(on); input(off); 18 int start[4] = {1, 1, 2, 1}, step[4] = {1, 2, 2, 3}; 19 set\u0026lt;string\u0026gt; s; 20 for (int state = 0; state \u0026lt; 16; state++) { 21 int d = __builtin_popcount(state); 22 if (d \u0026gt; c || (d + c) \u0026amp; 1) continue; 23 vector\u0026lt;bool\u0026gt; lamp(1 + n); 24 for (int r = 0; r \u0026lt; 4; r++) 25 if ((1 \u0026lt;\u0026lt; r) \u0026amp; state) 26 for (int i = start[r]; i \u0026lt;= n; i += step[r]) 27 lamp[i] = !lamp[i]; 28 bool success = true; 29 for (int i : on) 30 if (lamp[i]) success = false; 31 for (int i : off) 32 if (!lamp[i]) success = false; 33 if (!success) continue; 34 string str = \u0026#34;\u0026#34;; 35 for (int i = 1; i \u0026lt;= n; i++) str += \u0026#34;10\u0026#34;[lamp[i]]; 36 s.insert(str); 37 } 38 if (s.empty()) cout \u0026lt;\u0026lt; \u0026#34;IMPOSSIBLE\\n\u0026#34;; 39 else for (string str : s) cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 40 return 0; 41} 2.3 Longest Prefix 題意：給定一個字串集合，大小 n ≤ 200，元素長度小魚 L ≤ 10，以及一個字串 S。問能用集合中元素組成的最長 S 前綴有多長？ 解法：DP，O(nL|S|)。 1/* 2ID: whitech1 3TASK: prefix 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8int main() { 9 freopen(\u0026#34;prefix.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 10 freopen(\u0026#34;prefix.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 11 string tmp; 12 vector\u0026lt;string\u0026gt; pr; 13 while (cin \u0026gt;\u0026gt; tmp \u0026amp;\u0026amp; tmp != \u0026#34;.\u0026#34;) pr.push_back(tmp); 14 string s = \u0026#34; \u0026#34;; 15 while (cin \u0026gt;\u0026gt; tmp) s += tmp; 16 vector\u0026lt;bool\u0026gt; dp(s.length() + 1); 17 int ans = 0; 18 dp[0] = true; 19 for (int i = 1; s[i]; i++) { 20 for (string p : pr) { 21 int l = p.length(); 22 if (i \u0026gt;= l \u0026amp;\u0026amp; p == s.substr(i - l + 1, l)) 23 dp[i] = dp[i] || dp[i - l]; 24 if (dp[i]) {ans = i; break;} 25 } 26 } 27 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 return 0; 29} 2.3 Cow Pedigrees 題意：給定 N \u0026lt; 200 和 K \u0026lt; 100，每個點只能有 0 / 2 個子節點，求大小為 N 且深度為 K 的樹有多少種，答案 mod 9901。 解法：DP。 狀態：dp[n][k] 代表大小為 n 且深度不超過 k 的樹有幾種。 轉移：O(N) 枚舉左右子樹的大小。 1/* 2ID: whitech1 3TASK: nocows 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8#define mod 9901 9inline void add(int \u0026amp;a, int b) { a = (a + b) % mod; } 10int main() { 11 freopen(\u0026#34;nocows.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 12 freopen(\u0026#34;nocows.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 13 int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); 14 int dp[200][100] = {}; 15 for (int i = 1; i \u0026lt;= k; i++) dp[1][i] = 1; 16 for (int i = 1; i \u0026lt;= n; ++i) 17 for (int j = 1; j \u0026lt;= k; ++j) 18 for (int l = 1, r = i - 2; r \u0026gt;= 1; ++l, --r) 19 add(dp[i][j], dp[l][j - 1] * dp[r][j - 1]); 20 printf(\u0026#34;%d\\n\u0026#34;, (dp[n][k] - dp[n][k - 1] + mod) % mod); 21 return 0; 22} 2.3 Zero Sum 題意：給定 N ≤ 9，在 1 ~ N 之間插入 + - ，問有哪些算式能得到 0？ Ex. 1-2 3-4 5+6 7 = 1 - 23 - 45 + 67 = 0 解法：枚舉所有可能，用 python 的 eval() 計算。 複雜度：$$O(N3^N)$$ 1\u0026#34;\u0026#34;\u0026#34; 2ID: whitech1 3LANG: PYTHON3 4TASK: zerosum 5\u0026#34;\u0026#34;\u0026#34; 6ans = [] 7def enum(i, s, n): 8 s += str(i) 9 if i == n: 10 if eval(s.replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;)) == 0: 11 ans.append(s + \u0026#39;\\n\u0026#39;) 12 else: 13 for op in \u0026#34; +-\u0026#34;: 14 enum(i + 1, s + op, n) 15fin = open (\u0026#39;zerosum.in\u0026#39;, \u0026#39;r\u0026#39;) 16fout = open (\u0026#39;zerosum.out\u0026#39;, \u0026#39;w\u0026#39;) 17n = int(fin.readline()) 18enum(1, \u0026#39;\u0026#39;, n) 19fout.writelines(ans) 20fin.close() 21fout.close() 2.3 Money Systems 題意：給定 V ≤ 25 種貨幣，問有幾種方法能組出 N ≤ 10000？ 解法：無限 DP。 1/* 2ID: whitech1 3TASK: money 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt; 7using namespace std; 8int main() { 9 freopen(\u0026#34;money.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 10 freopen(\u0026#34;money.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 11 int v, n; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; n; 12 vector\u0026lt;long long\u0026gt; dp(n + 1); 13 dp[0] = 1; 14 while (v--) { 15 int x; cin \u0026gt;\u0026gt; x; 16 for (int i = x; i \u0026lt;= n; i++) 17 dp[i] += dp[i - x]; 18 } 19 cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 20 return 0; 21} 2.3 Controlling Companies 題意：給定至多 m = 100 家公司，及他們的持股資訊。A 控制 B，當達到三種條件的其中一種，問共有幾種控制的 pair。 A = B A 持有 B 的股票超過 50% A 控制的公司們持有 B 的股票和超過 50% 解法：當 x 控制 y 時，則將 y 持有的股票加到 x，當超過 50，則繼續 DFS。因為最多 O(m^2) 次，每次 O(m)，總時間複雜度 O(m^3)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4bool cont[101][101]; 5int block[101][101]; 6void dfs(int i, int j) { 7 if (cont[i][j]) return; 8 cont[i][j] = true; 9 for (int k = 1; k \u0026lt;= 100; k++) { 10 block[i][k] += block[j][k]; 11 if (block[i][k] \u0026gt; 50) dfs(i, k); 12 } 13} 14int main() { 15 freopen(\u0026#34;concom.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 16 freopen(\u0026#34;concom.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 17 int n; cin \u0026gt;\u0026gt; n; 18 queue\u0026lt;int\u0026gt; q; 19 while (n--) { 20 int i, j, p; cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; j \u0026gt;\u0026gt; p; 21 block[i][j] = p; 22 } 23 for (int i = 1; i \u0026lt;= 100; i++) 24 for (int j = 1; j \u0026lt;= 100; j++) 25 if (block[i][j] \u0026gt; 50) dfs(i, j); 26 for (int i = 1; i \u0026lt;= 100; i++) 27 for (int j = 1; j \u0026lt;= 100; j++) 28 if (i != j \u0026amp;\u0026amp; cont[i][j]) 29 cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 30 return 0; 31} 2.4 The Tamworth Two 題意：給定一個 10 x 10 的地圖，Farmer 和 Cow 以同樣的方式行走，他們一開始皆面向北，每分鐘可行走一步，當遇到障礙物時，則花一分鐘順時鐘轉 90 度，請問要多久兩者才會相遇在同一格？若不相遇則輸出 0。 解法：模擬。最多有 10 x 10 x 4 = 400 種狀態，兩者則有 400 x 400 = 160000 種狀態，若他們並未相遇，則不可能會相遇。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3char board[12][12]; 4const int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; 5struct state { 6 int x, y, d; 7 state() {d = 0;} 8 state(int _x, int _y, int _d) { 9 x = _x, y = _y, d = _d; 10 } 11}; 12inline bool same(state A, state B) { 13 return A.x == B.x \u0026amp;\u0026amp; A.y == B.y; 14} 15inline bool ob(int i, int j) { 16 return !board[i][j] || board[i][j] == \u0026#39;*\u0026#39;; 17} 18state next_state(state S) { 19 int xx = S.x + dx[S.d], yy = S.y + dy[S.d]; 20 if (ob(xx, yy)) return state(S.x, S.y, (S.d + 1) % 4); 21 return state(xx, yy, S.d); 22} 23int main() { 24 freopen(\u0026#34;ttwo.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 25 freopen(\u0026#34;ttwo.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 26 state F, C; 27 for (int i = 1; i \u0026lt;= 10; i++) { 28 scanf(\u0026#34; %s\u0026#34;, board[i] + 1); 29 for (int j = 1; j \u0026lt;= 10; j++) 30 if (board[i][j] == \u0026#39;F\u0026#39;) F.x = i, F.y = j; 31 else if (board[i][j] == \u0026#39;C\u0026#39;) C.x = i, C.y = j; 32 } 33 for (int i = 0; i \u0026lt;= 160000; i++) { 34 if (same(F, C)) { 35 cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 36 return 0; 37 } 38 F = next_state(F), C = next_state(C); 39 } 40 cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; 41 return 0; 42} 2.4 Overfencing 題意：給定一個 W x H 的地圖，W ≤ 38，H ≤ 100，最外面有兩個柵欄是開的，每個格子都能走到外圍，問離外圍最遠的格子有多遠？ 解法：從外圍的點開始 BFS，複雜度 O(WH)。小技巧是在最外圍加上一圈障礙物，就不會 BFS 超出陣列範圍。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0}; 4int main() { 5 freopen(\u0026#34;maze1.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 6 freopen(\u0026#34;maze1.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 7 int w, h; cin \u0026gt;\u0026gt; w \u0026gt;\u0026gt; h; cin.ignore(); 8 char c[205][80]; 9 memset(c, \u0026#39;.\u0026#39;, sizeof(c)); // 加上障礙物 10 for (int i = 2; i \u0026lt;= 2 * h + 2; i++) 11 cin.getline(c[i] + 2, 2 * w + 2); 12 int vst[205][80]; 13 memset(vst, -1, sizeof(vst)); // 設為沒走過 14 queue\u0026lt;int\u0026gt; qx, qy; 15 // 放入外圈的點 16 for (int i = 1; i \u0026lt;= 2 * w + 3; i++) { 17 c[1][i] = c[2 * h + 3][i] = \u0026#39; \u0026#39;; 18 vst[1][i] = vst[2 * h + 3][i] = 0; 19 qx.push(1), qy.push(i); 20 qx.push(2 * h + 3), qy.push(i); 21 } 22 for (int i = 1; i \u0026lt;= 2 * h + 3; i++) { 23 c[i][1] = c[i][2 * w + 3] = \u0026#39; \u0026#39;; 24 vst[i][1] = vst[i][2 * w + 3] = 0; 25 qx.push(i), qy.push(1); 26 qx.push(i), qy.push(2 * w + 3); 27 } 28 int mx = 0; 29 // BFS 30 while (!qx.empty()) { 31 int x = qx.front(); qx.pop(); 32 int y = qy.front(); qy.pop(); 33 mx = vst[x][y]; // 最後走到的點就是答案 34 for (int d = 0; d \u0026lt; 4; d++) { 35 int xx = dx[d] + x, yy = dy[d] + y; 36 // 遇到障礙物或走過的點就跳過 37 if (c[xx][yy] != \u0026#39; \u0026#39; || vst[xx][yy] != -1) continue; 38 vst[xx][yy] = vst[x][y] + 1; 39 qx.push(xx), qy.push(yy); 40 } 41 } 42 cout \u0026lt;\u0026lt; mx / 2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 43 return 0; 44} 2.4 Cow Tours 題意：給定一個大小為 N ≤ 150 的圖，這個圖為加上一條邊可聯通的非聯通圖。問加上一條邊後的最小直徑（diameter）為多少。 解法：先做一次 Floyd-Warshall 算出枚舉加入 (i, j)，i、j 兩聯通塊和 i、j 最遠的點距和 i、j 的距離相加，再和未聯通前的最大直徑比較。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const double INF = 40000000; 4inline double dst(int x, int y, int xx, int yy) { 5 double dx = x - xx, dy = y - yy; 6 return sqrt(dx * dx + dy * dy); 7} 8int main() { 9 freopen(\u0026#34;cowtour.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 10 freopen(\u0026#34;cowtour.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 11 ios::sync_with_stdio(0), cin.tie(0); 12 int n; cin \u0026gt;\u0026gt; n; 13 vector\u0026lt;int\u0026gt; x(n), y(n); 14 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i]; 15 vector\u0026lt;string\u0026gt; m(n); 16 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; m[i]; 17 vector\u0026lt;vector\u0026lt;double\u0026gt; \u0026gt; dis(n, vector\u0026lt;double\u0026gt;(n, 0)); 18 for (int i = 0; i \u0026lt; n; i++) 19 for (int j = i + 1; j \u0026lt; n; j++) 20 dis[i][j] = dis[j][i] = dst(x[i], y[i], x[j], y[j]); 21 vector\u0026lt;vector\u0026lt;double\u0026gt; \u0026gt; dp(n, vector\u0026lt;double\u0026gt;(n, INF)); 22 for (int i = 0; i \u0026lt; n; i++) { 23 dp[i][i] = 0; 24 for (int j = i + 1; j \u0026lt; n; j++) 25 if (m[i][j] == \u0026#39;1\u0026#39;) dp[i][j] = dp[j][i] = dis[i][j]; 26 } 27 for (int i = 0; i \u0026lt; n; i++) 28 for (int j = 0; j \u0026lt; n; j++) 29 for (int k = 0; k \u0026lt; n; k++) 30 dp[j][k] = min(dp[j][k], dp[j][i] + dp[i][k]); 31 vector\u0026lt;double\u0026gt; far(n, 0); 32 for (int i = 0; i \u0026lt; n; i++) 33 for (int j = 0; j \u0026lt; n; j++) 34 if (dp[i][j] + 1 \u0026lt; INF) 35 far[i] = max(far[i], dp[i][j]); 36 double ans = INF; 37 for (int i = 0; i \u0026lt; n; i++) 38 for (int j = i + 1; j \u0026lt; n; j++) 39 if (dp[i][j] + 1 \u0026gt; INF) 40 ans = min(ans, far[i] + far[j] + dis[i][j]); 41 for (int i = 0; i \u0026lt; n; i++) ans = max(ans, far[i]); 42 cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(6) \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 43 return 0; 44} 2.4 Bessie Come Home 題意：共有 A ~ Y 和 a ~ z 這些牧場，每個大寫字母的牧場都有一隻牛，給定 P ≤ 10000 條道路，問距離 Z 最近的牧場為何？ 解法：Dijkstra 找最短距離，O(P log P)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4const int INF = 100000000; 5inline int id(char c) { 6 if (isupper(c)) return c - \u0026#39;A\u0026#39;; 7 return c - \u0026#39;a\u0026#39; + 26; 8} 9int main() { 10 freopen(\u0026#34;comehome.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 11 freopen(\u0026#34;comehome.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 12 int m; cin \u0026gt;\u0026gt; m; 13 vector\u0026lt;vector\u0026lt;pii\u0026gt; \u0026gt; G(52); 14 while (m--) { 15 char a, b; int w; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; w; 16 G[id(a)].push_back(pii(w, id(b))); 17 G[id(b)].push_back(pii(w, id(a))); 18 } 19 vector\u0026lt;int\u0026gt; dis(52, INF); 20 dis[id(\u0026#39;Z\u0026#39;)] = 0; 21 priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, greater\u0026lt;pii\u0026gt; \u0026gt; pq; 22 pq.push(pii(0, id(\u0026#39;Z\u0026#39;))); 23 while (!pq.empty()) { 24 int u = pq.top().second; pq.pop(); 25 if (u \u0026lt; 25) { 26 cout \u0026lt;\u0026lt; char(u + \u0026#39;A\u0026#39;) \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; dis[u] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 27 return 0; 28 } 29 for (pii e : G[u]) { 30 int uu = e.second, w = e.first; 31 if (dis[uu] \u0026gt; dis[u] + w) { 32 dis[uu] = dis[u] + w; 33 pq.push(pii(dis[uu], uu)); 34 } 35 } 36 } 37 return 0; 38} 2.4 Fractions to Decimals 題意：給定 N 和 D ≤ 100000，求 N / Q 的循環小數表示。 解法：當餘數重複出現，則表示出現循環，餘數至多 D 種，所以複雜度 O(D)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3inline char dec(int x) {return x + \u0026#39;0\u0026#39;;} 4string str(int x) { 5 string s = \u0026#34;\u0026#34;; 6 while (x) { 7 s += char(x % 10 + \u0026#39;0\u0026#39;); 8 x /= 10; 9 } 10 reverse(s.begin(), s.end()); 11 return s; 12} 13void print(string s) { 14 for (int i = 0; s[i]; i++) { 15 cout \u0026lt;\u0026lt; s[i]; 16 if (i % 76 == 75 || i == s.length() - 1) 17 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 18 } 19} 20int main() { 21 freopen(\u0026#34;fracdec.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 22 freopen(\u0026#34;fracdec.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 23 ios::sync_with_stdio(0), cin.tie(0); 24 int N, D; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; D; 25 int Q = N / D; 26 if (!N) { 27 cout \u0026lt;\u0026lt; Q \u0026lt;\u0026lt; \u0026#34;.0\\n\u0026#34;; 28 return 0; 29 } 30 N %= D; 31 vector\u0026lt;int\u0026gt; q, r; 32 vector\u0026lt;int\u0026gt; vst(D + 1, -1); 33 r.push_back(N), vst[N] = 0; 34 while (N) { 35 q.push_back(N * 10 / D); 36 r.push_back(N * 10 % D); 37 N = r.back(); 38 if (vst[N] != -1) break; 39 vst[N] = q.size(); 40 } 41 string ans = Q ? str(Q) : \u0026#34;0\u0026#34;; 42 ans += \u0026#34;.\u0026#34;; 43 int rep = vst[r.back()]; 44 for (int i = 0; i \u0026lt; rep; i++) ans += dec(q[i]); 45 if (rep != r.size() - 1) { 46 ans += \u0026#34;(\u0026#34;; 47 for (int i = rep; i \u0026lt; q.size(); i++) 48 ans += dec(q[i]); 49 ans += \u0026#34;)\u0026#34;; 50 } 51 print(ans); 52 return 0; 53} Chapter 3 3.1 Agri-Net 題意：給 N ≤ 100 的 Adjacency Matrix，求 MST。 解法：做 Prim，複雜度 O(N^2)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define MAXN 105 4#define INF 100000000 5int main() { 6 freopen(\u0026#34;agrinet.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 7 freopen(\u0026#34;agrinet.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 8 int n; cin \u0026gt;\u0026gt; n; 9 int G[MAXN][MAXN]; 10 for (int i = 0; i \u0026lt; n; i++) 11 for (int j = 0; j \u0026lt; n; j++) 12 cin \u0026gt;\u0026gt; G[i][j]; 13 int dis[MAXN] = {}; 14 for (int i = 1; i \u0026lt; n; i++) dis[i] = INF; 15 bool visit[MAXN] = {}; 16 int ans = 0; 17 for (int i = 0; i \u0026lt; n; i++) { 18 int u = 0, mx = INF; 19 for (int j = 1; j \u0026lt; n; j++) 20 if (!visit[j] \u0026amp;\u0026amp; dis[j] \u0026lt; mx) 21 u = j, mx = dis[j]; 22 visit[u] = true; 23 ans += dis[u]; 24 for (int i = 0; i \u0026lt; 100; i++) 25 dis[i] = min(dis[i], G[u][i]); 26 } 27 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 return 0; 29} 3.1 Score Inflation 題意：裸的無限背包。 解法：DP，O(MN)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define MAXM 10005 4int main() { 5 freopen(\u0026#34;inflate.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 6 freopen(\u0026#34;inflate.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 7 int M, N; cin \u0026gt;\u0026gt; M \u0026gt;\u0026gt; N; 8 int dp[MAXM] = {}; 9 while (N--) { 10 int w, t; cin \u0026gt;\u0026gt; w \u0026gt;\u0026gt; t; 11 for (int i = t; i \u0026lt;= M; i++) 12 dp[i] = max(dp[i], dp[i - t] + w); 13 } 14 cout \u0026lt;\u0026lt; dp[M] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 15 return 0; 16} 3.1 Humble Numbers 題意：給定一個大小為 K ≤ 100 的質數集合，問第 N ≤ 100000 個質因數只有集合裡元素的數為何（不含 1）？ 解法：如果用 priority_queue 會 MLE，用 set 會 TLE。用了 DP，不斷計算每個因數目前被用到最大的數為何，複雜度 O(NK)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 freopen(\u0026#34;humble.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 5 freopen(\u0026#34;humble.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 6 int K, N; cin \u0026gt;\u0026gt; K \u0026gt;\u0026gt; N; 7 vector\u0026lt;int\u0026gt; v(K); 8 for (int i = 0; i \u0026lt; K; i++) cin \u0026gt;\u0026gt; v[i]; 9 vector\u0026lt;int\u0026gt; dp(N + 1); 10 dp[0] = 1; 11 vector\u0026lt;int\u0026gt; p(K); 12 for (int i = 1; i \u0026lt;= N; i++) { 13 dp[i] = dp[p[0]] * v[0]; 14 for (int j = 1; j \u0026lt; K; j++) 15 dp[i] = min(dp[i], dp[p[j]] * v[j]); 16 for (int j = 0; j \u0026lt; K; j++) 17 if (dp[i] == dp[p[j]] * v[j]) p[j]++; 18 } 19 cout \u0026lt;\u0026lt; dp[N] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 20 return 0; 21} 3.1 Contact 題意：給定 1 ≤ a ≤ b ≤ 12 和 1 ≤ N ≤ 50，以及一個長度最長 200000 的 0/1 字串 S，問長度介於 [a, b] 的 0/1 字串和 S 有多少 match 次數，列出前 N 大的頻率的所有字串。 解法：將所有長度為 [a, b] 的子字串前綴加上 1 後 hash 丟進 map 計算次數，O(b|S|)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;int, string\u0026gt; pis; 4typedef pair\u0026lt;int, pis\u0026gt; piis; 5int a, b; 6string p; 7vector\u0026lt;piis\u0026gt; ans; 8int mp[(1 \u0026lt;\u0026lt; 13)]; 9void substring(string s) { 10 for (int r = a; r \u0026lt;= b; r++) { 11 int mask = 1 \u0026lt;\u0026lt; r, now = 0; 12 for (int i = 0; s[i]; i++) { 13 now = ((now \u0026lt;\u0026lt; 1) | (s[i] - \u0026#39;0\u0026#39;)) \u0026amp; (mask - 1); 14 if (i \u0026gt;= r - 1) mp[now | mask]++; 15 } 16 } 17} 18void solve(int len) { 19 int pat = 0; 20 for (int i = 0; p[i]; i++) pat = (pat \u0026lt;\u0026lt; 1) | (p[i] - \u0026#39;0\u0026#39;); 21 pat |= (1 \u0026lt;\u0026lt; len); 22 if (a \u0026lt;= len \u0026amp;\u0026amp; mp[pat]) 23 ans.push_back(piis(-mp[pat], pis(len, p))); 24 if (len \u0026gt;= b) return; 25 p += \u0026#39;0\u0026#39;; solve(len + 1); p.pop_back(); 26 p += \u0026#39;1\u0026#39;; solve(len + 1); p.pop_back(); 27} 28int main() { 29 freopen(\u0026#34;contact.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 30 freopen(\u0026#34;contact.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 31 ios::sync_with_stdio(0), cin.tie(0); 32 int n; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; n; 33 string s, ss; 34 while (cin \u0026gt;\u0026gt; ss) s += ss; 35 substring(s); 36 solve(0); 37 sort(ans.begin(), ans.end()); 38 int sz = ans.size(); 39 for (int i = 0, j = 0; i \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; sz; i++) { 40 int f = ans[j].first; 41 cout \u0026lt;\u0026lt; -f \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 42 vector\u0026lt;string\u0026gt; tmp; 43 for (; ans[j].first == f \u0026amp;\u0026amp; j \u0026lt; sz; j++) 44 tmp.push_back(ans[j].second.second); 45 for (int k = 0; k \u0026lt; tmp.size(); k++) 46 cout \u0026lt;\u0026lt; tmp[k] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[k % 6 == 5 || k == tmp.size() - 1]; 47 } 48 return 0; 49} 3.1 Stamps 題意：給定 N ≤ 50 種價值的郵票，最大價值 M ≤ 10000，問最多只用 K ≤ 200 種郵票，能湊出的數為 1 ~ 多少？ 解法：DP。狀態 DP[i] 設為湊出 i 需要的最少數量，O(N) 轉移，複雜度為 O(MNK)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 freopen(\u0026#34;stamps.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 5 freopen(\u0026#34;stamps.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 6 int k, n; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; n; 7 vector\u0026lt;int\u0026gt; v(n); 8 int mx = 0; 9 for (int i = 0; i \u0026lt; n; i++) { 10 cin \u0026gt;\u0026gt; v[i]; 11 mx = max(mx, v[i]); 12 } 13 mx *= k; 14 vector\u0026lt;int\u0026gt; dp(mx + 2, k + 1); 15 dp[0] = 0; 16 for (int i = 0; i \u0026lt;= mx; i++) 17 for (int j = 0; j \u0026lt; n; j++) 18 if (i \u0026gt;= v[j]) 19 dp[i] = min(dp[i], dp[i - v[j]] + 1); 20 int ans = 0; 21 for (; dp[ans] \u0026lt;= k; ans++); 22 cout \u0026lt;\u0026lt; ans - 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 23 return 0; 24} 3.2 Factorials 題意：給定 N ≤ 4220，問 N! 最右邊的非零數字是多少？ Ex. 7! = 5040 是 4。 解法：只有 2 和 5 會產生 0 結尾，把他們提出來另外處理，其他就不斷相乘模 10，最後將多出的 2 或 5 乘上去模 10，複雜度 O(N log N)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 freopen(\u0026#34;fact4.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 5 freopen(\u0026#34;fact4.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 6 int n; cin \u0026gt;\u0026gt; n; 7 int ans = 1, two = 0, five = 0; 8 for (int i = 1; i \u0026lt;= n; i++) { 9 int x = i; 10 while (x % 2 == 0) x /= 2, two++; 11 while (x % 5 == 0) x /= 5, five++; 12 ans = ans * x % 10; 13 } 14 for (int i = two; i \u0026lt; five; i++) ans = ans * 5 % 10; 15 for (int i = five; i \u0026lt; two; i++) ans = ans * 2 % 10; 16 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 17 return 0; 18} 3.2 Stringsobits 題意：給定 N ≤ 31，集合 S 包含所有 1-bit ≤ L 個的 N-bit 數，問集合 S 中的第 I 個數？ 解法：遞迴檢查前綴為 s 的數在集合中有幾個，這部分可用排列組合計算，這樣就可以決定每一位要放 0 或 1。C(a, b) 的部分是用不斷消去分子和分母的最大公因數。複雜度為 O(N^4)。要小心 I 最大為 2^31，要用 unsigned int。官方解答用 DP 算出 C(a, b)，複雜度可降到 O(N^2)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef unsigned int ui; 4string s; 5int C(int a, int b) { 6 if (a \u0026lt; b) return 0; 7 vector\u0026lt;int\u0026gt; up, down; 8 for (int i = a; i \u0026gt; b; i--) up.push_back(i); 9 for (int i = a - b; i \u0026gt; 1; i--) down.push_back(i); 10 for (int i = 0; i \u0026lt; down.size(); i++) { 11 for (int j = 0; j \u0026lt; up.size(); j++) { 12 int g = __gcd(down[i], up[j]); 13 down[i] /= g, up[j] /= g; 14 } 15 } 16 int ret = 1; 17 for (int x : up) ret *= x; 18 return ret; 19} 20void solve(int len, int cnt, ui id) { 21 if (!len) return; 22 ui f = 0; 23 for (int i = cnt; i \u0026gt;= 0; i--) f += C(len - 1, i); 24 if (f \u0026lt; id) { 25 s += \u0026#39;1\u0026#39;; 26 solve(len - 1, cnt - 1, id - f); 27 } else { 28 s += \u0026#39;0\u0026#39;; 29 solve(len - 1, cnt, id); 30 } 31} 32int main() { 33 freopen(\u0026#34;kimbits.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 34 freopen(\u0026#34;kimbits.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 35 int N, L; ui I; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; L \u0026gt;\u0026gt; I; 36 solve(N, L, I); 37 cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 38 return 0; 39} 3.2 Spinning Wheels 讀題讀了很久，最後直接 Google 中文翻譯。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4int main() { 5 freopen(\u0026#34;spin.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 6 freopen(\u0026#34;spin.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 7 int speed[5]; 8 vector\u0026lt;pii\u0026gt; w[5]; 9 for (int i = 0; i \u0026lt; 5; i++) { 10 int x; cin \u0026gt;\u0026gt; speed[i] \u0026gt;\u0026gt; x; 11 w[i].resize(x); 12 for (int j = 0; j \u0026lt; x; j++) { 13 cin \u0026gt;\u0026gt; w[i][j].first \u0026gt;\u0026gt; w[i][j].second; 14 w[i][j].second += w[i][j].first; 15 } 16 } 17 int ans = -1; 18 for (int t = 0; t \u0026lt; 360 \u0026amp;\u0026amp; ans == -1; t++) { 19 int check[360] = {}; 20 for (int i = 0; i \u0026lt; 5; i++) 21 for (pii p : w[i]) 22 for (int j = p.first; j \u0026lt;= p.second; j++) 23 check[(j + t * speed[i]) % 360]++; 24 for (int i = 0; i \u0026lt; 360; i++) 25 if (check[i] == 5) {ans = t; break;} 26 } 27 if (ans == -1) cout \u0026lt;\u0026lt; \u0026#34;none\\n\u0026#34;; 28 else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 29 return 0; 30} 3.2 Feed Ratios 暴力枚舉題。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 freopen(\u0026#34;ratios.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 5 freopen(\u0026#34;ratios.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 6 int mi = 1000; 7 int a[4][3]; 8 for (int i = 0; i \u0026lt; 4; i++) 9 for (int j = 0; j \u0026lt; 3; j++) 10 cin \u0026gt;\u0026gt; a[i][j]; 11 int c[4], ans[4]; 12 for (c[1] = 0; c[1] \u0026lt; 100; ++c[1]) { 13 for (c[2] = 0; c[2] \u0026lt; 100; ++c[2]) { 14 for (c[3] = 0; c[3] \u0026lt; 100; ++c[3]) { 15 int cnt[3] = {}, t[3]; 16 bool f = true; 17 int mx = 0; 18 for (int i = 0; i \u0026lt; 3; i++) { 19 for (int j = 1; j \u0026lt;= 3; j++) cnt[i] += c[j] * a[j][i]; 20 if (!a[0][i] \u0026amp;\u0026amp; !cnt[i]) t[i] = 0; 21 else if ((!a[0][i] \u0026amp;\u0026amp; cnt[i]) || cnt[i] % a[0][i]) f = false; 22 else if (a[0][i]) t[i] = cnt[i] / a[0][i]; 23 else t[i] = 0; 24 mx = max(mx, t[i]); 25 } 26 for (int i = 0; i \u0026lt; 3; i++) 27 if (mx * a[0][i] != cnt[i]) 28 f = false; 29 if (f \u0026amp;\u0026amp; (c[0] + c[1] + c[2])) 30 if (mi \u0026gt; c[0] + c[1] + c[2]) 31 mi = c[0] + c[1] + c[2], 32 ans[0] = mx, ans[1] = c[1], 33 ans[2] = c[2], ans[3] = c[3]; 34 35 } 36 } 37 } 38 if (mi \u0026lt; 1000) { 39 for (int i = 1; i \u0026lt; 4; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 40 cout \u0026lt;\u0026lt; ans[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 41 } 42 else cout \u0026lt;\u0026lt; \u0026#34;NONE\\n\u0026#34;; 43 return 0; 44} 3.2 Magic Squares 題意：給定一個由 1 ~ 8 組成的 4 x 2 矩陣，及三種循環操作，求產生目標矩陣的最小操作數方法為何？ 解法：BFS，因為狀態最多 8! 種，將狀態用 8 位整數儲存到 map 裡。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int c[3][8] = {{4, 5, 6, 7, 0, 1, 2, 3}, 4 {3, 0, 1, 2, 7, 4, 5, 6}, 5 {0, 5, 1, 3, 4, 6, 2, 7}}; 6char ch[4] = \u0026#34;ABC\u0026#34;; 7int change(int x, int r) { 8 int a[8] = {}; 9 for (int i = 0; i \u0026lt; 8; i++) { 10 a[7 - i] = x % 10; 11 x /= 10; 12 } 13 int ret = 0; 14 for (int i = 0; i \u0026lt; 8; i++) ret = ret * 10 + a[c[r][i]]; 15 return ret; 16} 17int main() { 18 freopen(\u0026#34;msquare.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 19 freopen(\u0026#34;msquare.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 20 int goal = 0; 21 int a[8]; 22 for (int i = 0; i \u0026lt; 8; i++) cin \u0026gt;\u0026gt; a[i]; 23 for (int i = 0; i \u0026lt; 4; i++) goal = goal * 10 + a[i]; 24 for (int i = 7; i \u0026gt;= 4; i--) goal = goal * 10 + a[i]; 25 map\u0026lt;int, string\u0026gt; m; 26 queue\u0026lt;int\u0026gt; state; 27 state.push(12348765); 28 m[12348765] = \u0026#34;\u0026#34;; 29 while (!state.empty()) { 30 int s = state.front(); state.pop(); 31 if (s == goal) break; 32 for (int i = 0; i \u0026lt; 3; i++) { 33 int ss = change(s, i); 34 if (m.find(ss) != m.end()) continue; 35 m[ss] = m[s] + ch[i]; 36 state.push(ss); 37 } 38 } 39 cout \u0026lt;\u0026lt; m[goal].length() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; m[goal] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 40 return 0; 41} 3.2 Sweet Butter 題意：給定 N ≤ 500 頭牛，共有 P ≤ 800 個農場和 C ≤ 1450 條路，問要將集合點設在哪，才能使牛隻們走的總距離最小？ 解法：以每個點當起點做一次最短路，這邊用 Dijkstra，總複雜度 O(PC log C)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4const int INF = 2000000000; 5int main() { 6 freopen(\u0026#34;butter.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 7 freopen(\u0026#34;butter.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 8 int n, p, c; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p \u0026gt;\u0026gt; c; 9 vector\u0026lt;int\u0026gt; v(n); 10 vector\u0026lt;vector\u0026lt;pii\u0026gt; \u0026gt; G(p + 1); 11 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; 12 while (c--) { 13 int a, b, w; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; w; 14 G[a].push_back(pii(w, b)); 15 G[b].push_back(pii(w, a)); 16 } 17 int ans = INF; 18 for (int i = 1; i \u0026lt;= p; i++) { 19 vector\u0026lt;int\u0026gt; dis(p + 1, INF); 20 priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, greater\u0026lt;pii\u0026gt; \u0026gt; pq; 21 dis[i] = 0, pq.push(pii(0, i)); 22 while (!pq.empty()) { 23 int u = pq.top().second; pq.pop(); 24 for (pii e : G[u]) { 25 int uu = e.second, w = e.first; 26 if (dis[uu] \u0026gt; dis[u] + w) { 27 dis[uu] = dis[u] + w; 28 pq.push(pii(dis[uu], uu)); 29 } 30 } 31 } 32 int cnt = 0; 33 for (int x : v) cnt += dis[x]; 34 ans = min(ans, cnt); 35 } 36 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 37 return 0; 38} 3.3 Riding the Fences 題意：給定一個 500 個點以內無向的聯通圖，求找出 Euler Path/Circuit。 解法：如果有奇點就從它開始 DFS，否則從編號最小的點開始。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define MAXN 505 4int G[MAXN][MAXN], deg[MAXN]; 5vector\u0026lt;int\u0026gt; ans; 6void solve(int i) { 7 for (int j = 0; j \u0026lt; MAXN \u0026amp;\u0026amp; deg[i]; j++) 8 while (G[i][j]) { 9 deg[j]--, deg[i]--, G[i][j]--, G[j][i]--; 10 solve(j); 11 } 12 ans.push_back(i); 13} 14int main() { 15 freopen(\u0026#34;fence.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 16 freopen(\u0026#34;fence.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 17 int F; cin \u0026gt;\u0026gt; F; 18 for (int i = 0; i \u0026lt; F; i++) { 19 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 20 deg[a]++, deg[b]++, G[a][b]++, G[b][a]++; 21 } 22 for (int i = 0; i \u0026lt; MAXN; i++) 23 if (deg[i] \u0026amp; 1) { solve(i); break;} 24 for (int i = 0; i \u0026lt; MAXN; i++) 25 if (deg[i]) { solve(i); break;} 26 for (int i = ans.size() - 1; i \u0026gt;= 0; i--) 27 cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 return 0; 29} 3.3 Shopping Offers 題意：給定 b ≤ 5 種東西及各自的單價和需要的數量 ≤ 5，以及 s ≤ 99 種組合，每種組合包含數種物品、數量及組合價，問能買到剛好所需物品的最低價格為何？ 解法：DP，i 為把 b 種物品的量 hash 起來，DP[i] 表示其最低所需價格。 寫得好醜 QAQ 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4int num(int id, int state) { 5 for (int i = 0; i \u0026lt; id; i++) state /= 10; 6 return state %= 10; 7} 8int main() { 9 freopen(\u0026#34;shopping.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 10 freopen(\u0026#34;shopping.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 11 ios::sync_with_stdio(0), cin.tie(0); 12 int s; cin \u0026gt;\u0026gt; s; 13 vector\u0026lt;vector\u0026lt;pii\u0026gt; \u0026gt; v(s); 14 vector\u0026lt;int\u0026gt; p(s); 15 for (int i = 0; i \u0026lt; s; i++) { 16 int n; cin \u0026gt;\u0026gt; n; 17 v[i].resize(n); 18 for (int j = 0; j \u0026lt; n; j++) 19 cin \u0026gt;\u0026gt; v[i][j].first \u0026gt;\u0026gt; v[i][j].second; 20 cin \u0026gt;\u0026gt; p[i]; 21 } 22 int b; cin \u0026gt;\u0026gt; b; 23 vector\u0026lt;pii\u0026gt; r(b); 24 vector\u0026lt;int\u0026gt; dp(55556); 25 for (int i = 0; i \u0026lt; b; i++) { 26 int pp; cin \u0026gt;\u0026gt; r[i].first \u0026gt;\u0026gt; r[i].second \u0026gt;\u0026gt; pp; 27 for (int j = dp.size() - 1; j; j--) { 28 int cnt = num(i, j); 29 if (cnt \u0026lt;= r[i].second) dp[j] += cnt * pp; 30 } 31 } 32 int goal = 0; 33 for (int i = b - 1; i \u0026gt;= 0; i--) 34 goal = goal * 10 + r[i].second; 35 for (int i = 0; i \u0026lt; goal; i++) { 36 vector\u0026lt;int\u0026gt; state(b); 37 for (int j = 0; j \u0026lt; b; j++) state[j] = num(j, i); 38 for (int vi = 0; vi \u0026lt; s; vi++) { 39 bool success = true; 40 vector\u0026lt;int\u0026gt; new_state(state.begin(), state.end()); 41 for (pii p : v[vi]) { 42 int id = -1; 43 for (int ii = 0; ii \u0026lt; b; ii++) 44 if (p.first == r[ii].first) id = ii; 45 if (id == -1) success = false; 46 new_state[id] += p.second; 47 } 48 for (int i = 0; i \u0026lt; b; i++) 49 if (new_state[i] \u0026gt; r[i].second) success = false; 50 if (!success) continue; 51 int st = 0; 52 for (int j = b - 1; j \u0026gt;= 0; j--) 53 st = st * 10 + new_state[j]; 54 dp[st] = min(dp[st], dp[i] + p[vi]); 55 } 56 } 57 cout \u0026lt;\u0026lt; dp[goal] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 58 return 0; 59} 3.3 Camelot 寫的有點醜醜的，但其實不難寫，想的難度比較高。因為想不太到夠快的方法，所以就 Google 了一下。 題意：給定一個 R x C ≤ 30 x 26 的棋盤，棋盤上有一個 King 和多個 Knights，棋子可停留在同一格，當 King 和 Knights 在一起時，King 可帶著一個 Knight 照著 Knight 的走法走，問使得所有棋子都在同一格的最少步數？ 解法：如果沒有 King 的話，這題就是對每個點做一次 BFS，最小距離和就是答案。而多了 King 的做法，就是將每個棋做一次 SPFA，紀錄到每一格以遇到 King 或未遇到的最小步數。 複雜度：假設棋子數量為 K。$$O(KRC)$$ 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4#define x first 5#define y second 6#define INF 100000000 7inline int step(pii k, pii p) { 8 return max(abs(k.x - p.x), abs(k.y - p.y)); 9} 10inline bool range(pii p, int R, int C) { 11 return 0 \u0026lt;= p.x \u0026amp;\u0026amp; 0 \u0026lt;= p.y \u0026amp;\u0026amp; p.x \u0026lt; R \u0026amp;\u0026amp; p.y \u0026lt; C; 12} 13int dis[1000][30][35][2]; 14int main() { 15 freopen(\u0026#34;camelot.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 16 freopen(\u0026#34;camelot.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 17 int R, C; 18 cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C; 19 int tmp_int; 20 char tmp_ch; 21 cin \u0026gt;\u0026gt; tmp_ch \u0026gt;\u0026gt; tmp_int; 22 pii king = {tmp_int - 1, tmp_ch - \u0026#39;A\u0026#39;}; 23 vector\u0026lt;pii\u0026gt; knight; 24 while (cin \u0026gt;\u0026gt; tmp_ch \u0026gt;\u0026gt; tmp_int) 25 knight.push_back({tmp_int - 1, tmp_ch - \u0026#39;A\u0026#39;}); 26 if (!knight.size()) { 27 cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; 28 return 0; 29 } 30 for (int i = 0; i \u0026lt; knight.size(); i++) 31 for (int j = 0; j \u0026lt; R; j++) 32 for (int k = 0; k \u0026lt; C; k++) 33 dis[i][j][k][0] = dis[i][j][k][1] = INF; 34 const int dx[8] = {2, 2, 1, 1, -1, -1, -2, -2}; 35 const int dy[8] = {1, -1, 2, -2, 2, -2, 1, -1}; 36 for (int i = 0; i \u0026lt; knight.size(); i++) { 37 dis[i][knight[i].x][knight[i].y][0] = 0; 38 dis[i][knight[i].x][knight[i].y][1] = step(king, knight[i]); 39 queue\u0026lt;pii\u0026gt; q; 40 q.push(knight[i]); 41 while (!q.empty()) { 42 int xx = q.front().x, yy = q.front().y; 43 q.pop(); 44 for (int di = 0; di \u0026lt; 8; di++) { 45 int a = xx + dx[di], b = yy + dy[di]; 46 if (!range({a, b}, R, C)) continue; 47 bool inque = false; 48 if (dis[i][a][b][0] \u0026gt; dis[i][xx][yy][0] + 1) { 49 dis[i][a][b][0] = dis[i][xx][yy][0] + 1; 50 inque = true; 51 } 52 int d = min(dis[i][xx][yy][0] + step(king, {a, b}), 53 dis[i][xx][yy][1]) + 1; 54 if (dis[i][a][b][1] \u0026gt; d) { 55 dis[i][a][b][1] = d; 56 inque = true; 57 } 58 if (inque) q.push({a, b}); 59 } 60 } 61 } 62 int ans = INF; 63 for (int i = 0; i \u0026lt; R; i++) { 64 for (int j = 0; j \u0026lt; C; j++) { 65 int mi = INF, sum = 0; 66 for (int k = 0; k \u0026lt; knight.size(); k++) { 67 sum += dis[k][i][j][0]; 68 mi = min(mi, dis[k][i][j][1] - dis[k][i][j][0]); 69 } 70 ans = min(ans, sum + mi); 71 } 72 } 73 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 74 return 0; 75} 3.4 American Heritage 題意：給定一棵二元樹的中序和前序，求輸出後序。 解法：用前序標出中間節點後遞迴。應該可以做到 O(n)，但因為懶，所以用了 O(n^2)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3string pre, in; 4void solve(int il, int ir, int pl, int pr) { 5 if (il \u0026gt; ir) return; 6 if (il == ir) { cout \u0026lt;\u0026lt; in[il]; return; } 7 int i; 8 for (i = il; in[i] != pre[pl]; i++) {} 9 solve(il, i - 1, pl + 1, pl - il + i); 10 solve(i + 1, ir, pr - ir + i + 1, pr); 11 cout \u0026lt;\u0026lt; pre[pl]; 12} 13int main() { 14 freopen(\u0026#34;heritage.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 15 freopen(\u0026#34;heritage.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 16 cin \u0026gt;\u0026gt; in \u0026gt;\u0026gt; pre; 17 solve(0, in.length() - 1, 0, in.length() - 1); 18 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 19 return 0; 20} 3.4 Electric Fence 題意：給定一個三角形，頂點為 (0, 0), (n, m), (p, 0)，介於 [0, 32000]x[0, 32000] 之間，問有幾個座標點是在三角形裡？ 解法：對每個 y 都算一次邊上的座標，複雜度 O(m)。 官方解法：Pick\u0026rsquo;s Theorem。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 freopen(\u0026#34;fence9.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 5 freopen(\u0026#34;fence9.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 6 int n, m, p; 7 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; p; 8 int ans = 0; 9 for (int i = 1; i \u0026lt; m; i++) 10 ans += max(0, ((n + p) * i - 1) / m - n * i / m); 11 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 12 return 0; 13} 3.4 Raucous Rockers 題意：給定 n ≤ 20 首個歌的長度，共有 m ≤ 20 個唱片可以存放歌曲，每張唱片最多存 T ≤ 20 的長度，且存放時要按照輸入的順序，問最多能存幾首歌。 解法：枚舉放了哪些歌，然後 Greedy，O(n 2^n)。或是用 DP 做，O(nmT)。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 freopen(\u0026#34;rockers.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 5 freopen(\u0026#34;rockers.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 6 int n, m, t; 7 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; t \u0026gt;\u0026gt; m; 8 vector\u0026lt;int\u0026gt; v(n); 9 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; 10 int N = 1 \u0026lt;\u0026lt; n; 11 int ans = 0; 12 for (int i = 1; i \u0026lt; N; i++) { 13 int c = __builtin_popcount(i); 14 if (c \u0026lt;= ans) continue; 15 int r = 0, cnt = 0; 16 for (int j = 0; j \u0026lt; n; j++) { 17 if ((1 \u0026lt;\u0026lt; j) \u0026amp; i) { 18 if (v[j] \u0026gt; t) r = m; 19 if (cnt + v[j] \u0026gt; t) 20 r++, cnt = v[j]; 21 else cnt += v[j]; 22 } 23 } 24 if (r \u0026lt; m) ans = max(c, ans); 25 } 26 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 27 return 0; 28} Chapter 4 4.1 Beef McNuggets 有點吃數論的題目～ 題意：給定 N ≤ 10 個正整數 ≤ 256，求最大的正整數不能用這些數字組出來，若無限大則輸出 0。 解法：若 gcd 不為 1 則輸出 0，否則答案會在 256 x 256 以內，DP 解即可。 對於互質的正整數 a, b，最大不能得到的數為 ab - a - b。 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 freopen(\u0026#34;nuggets.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 5 freopen(\u0026#34;nuggets.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 6 int n; cin \u0026gt;\u0026gt; n; 7 vector\u0026lt;int\u0026gt; a(n); 8 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 9 int g = a[0]; 10 for (int x : a) g = __gcd(x, g); 11 if (g != 1) { 12 cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; 13 return 0; 14 } 15 const int M = 256 * 256; 16 bool check[M + 300] = {1}; 17 int ans = 0; 18 for (int i = 0; i \u0026lt; M; i++) 19 if (check[i]) 20 for (int x : a) 21 check[i + x] = true; 22 else ans = i; 23 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 24 return 0; 25} ","date":"2022-06-16T14:51:45+08:00","permalink":"https://luke2336.github.io/p/usaco/","title":"USACO"},{"content":"pJ. Inverse Factorial 給定一個長度不超過 1e6 的字串，代表 n!，求 n 是多少？ 答案的範圍不超過 1e6，所以可以直接 mod 一個夠大的質數 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define mod 1000000007 4typedef long long ll; 5int main () { 6 ios_base::sync_with_stdio(0); cin.tie(0); 7 string s; cin \u0026gt;\u0026gt; s; 8 ll sum = 0; 9 for (int i = 0; s[i]; i++) 10 sum = (sum * 10 + s[i] - \u0026#39;0\u0026#39;) % mod; 11 for (ll i = 1, frac = 1; ; i++) { 12 frac = (frac * i) % mod; 13 if (frac == sum) { 14 cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; 15 } 16 } 17 return 0; 18} Tic Tac Toe 給定一個 3x3 的棋盤，問是不是合法的。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4bool check(char t[3][4]) { 5 for (int i = 0; i \u0026lt; 3; i++) { 6 if (t[i][0] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; t[i][0] == t[i][1] 7 \u0026amp;\u0026amp; t[i][1] == t[i][2]) return false; 8 if (t[0][i] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; t[0][i] == t[1][i] 9 \u0026amp;\u0026amp; t[1][i] == t[2][i]) return false; 10 } 11 if (t[0][0] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; t[0][0] == t[1][1] 12 \u0026amp;\u0026amp; t[1][1] == t[2][2]) return false; 13 if (t[0][2] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; t[0][2] == t[1][1] 14 \u0026amp;\u0026amp; t[1][1] == t[2][0]) return false; 15 return true; 16} 17 18bool solve() { 19 char c[3][4]; 20 int cnt[2] = {}; 21 for (int i = 0; i \u0026lt; 3; i++) { 22 cin \u0026gt;\u0026gt; c[i]; 23 for (int j = 0; j \u0026lt; 3; j++) { 24 if (c[i][j] == \u0026#39;X\u0026#39;) cnt[0]++; 25 if (c[i][j] == \u0026#39;O\u0026#39;) cnt[1]++; 26 } 27 } 28 if (!cnt[0] \u0026amp;\u0026amp; !cnt[1]) return true; 29 if (cnt[0] \u0026lt; cnt[1] || cnt[0] - cnt[1] \u0026gt; 1) 30 return false; 31 char last = \u0026#34;XO\u0026#34;[cnt[0] == cnt[1]]; 32 for (int i = 0; i \u0026lt; 3; i++) { 33 for (int j = 0; j \u0026lt; 3; j++) { 34 if (c[i][j] != last) continue; 35 c[i][j] = \u0026#39;.\u0026#39;; 36 if (check(c)) return true; 37 c[i][j] = last; 38 } 39 } 40 return false; 41} 42 43int main () { 44 ios::sync_with_stdio(0), cin.tie(0); 45 int n; cin \u0026gt;\u0026gt; n; 46 while (n--) { 47 if (solve()) cout \u0026lt;\u0026lt; \u0026#34;yes\\n\u0026#34;; 48 else cout \u0026lt;\u0026lt; \u0026#34;no\\n\u0026#34;; 49 } 50 return 0; 51} Skener 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 int r, c, a, b; 5 scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;r, \u0026amp;c, \u0026amp;a, \u0026amp;b); 6 char s[55]; 7 for (int i = 0; i \u0026lt; r; i++) { 8 scanf(\u0026#34; %s\u0026#34;, s); 9 for (int j = 0; j \u0026lt; a; j++) { 10 for (int k = 0; k \u0026lt; c; k++) 11 for (int p = 0; p \u0026lt; b; p++) 12 putchar(s[k]); 13 putchar(\u0026#39;\\n\u0026#39;); 14 } 15 } 16 return 0; 17} Printing Costs 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 string s = \u0026#34; !\\\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0026#34;; 5 int a[] = {0, 9, 6, 24, 29, 22, 6 24, 3, 12, 12 ,17, 13, 7 7, 7, 4, 10, 22, 19, 8 22, 23, 21, 27, 26, 16, 9 23, 26, 8, 11, 10, 14, 10 10, 15, 32, 24, 29, 20, 11 26, 26, 20, 25, 25, 18, 12 18, 21, 16, 28, 25, 26, 13 23, 31, 28, 25, 16, 23, 14 19, 26, 18, 14, 22, 18, 15 10, 18, 7, 8, 3, 23, 16 25, 17, 25, 23, 18, 30, 17 21, 15, 20, 21, 16, 22, 18 18, 20, 25, 25, 13, 21, 19 17, 17, 13, 19, 13, 24, 20 19, 18, 12, 18, 9 }; 21 ios::sync_with_stdio(0); cin.tie(0); 22 string input; 23 while (1) { 24 getline(cin, input); 25 if (cin.fail()) break; 26 int cnt = 0; 27 for (int i = 0; input[i]; i++) 28 for (int j = 0; s[j]; j++) 29 if (input[i] == s[j]) { 30 cnt += a[j]; 31 break; 32 } 33 cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 34 } 35 return 0; 36} Touchscreen Keyboard 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4string board[3] = {\u0026#34;qwertyuiop\u0026#34;, \u0026#34;asdfghjkl\u0026#34;, \u0026#34;zxcvbnm\u0026#34;}; 5 6int x[26], y[26]; 7 8int main () { 9 for (int i = 0; i \u0026lt; 3; i++) { 10 for (int j = 0; board[i][j]; j++) { 11 int k = board[i][j] - \u0026#39;a\u0026#39;; 12 x[k] = i, y[k] = j; 13 } 14 } 15 ios::sync_with_stdio(0); cin.tie(0); 16 int T; cin \u0026gt;\u0026gt; T; 17 while (T--) { 18 string key; cin \u0026gt;\u0026gt; key; 19 int n; cin \u0026gt;\u0026gt; n; 20 vector\u0026lt; pair\u0026lt;int, string\u0026gt; \u0026gt; v; 21 for (int i = 0; i \u0026lt; n; i++) { 22 string s; cin \u0026gt;\u0026gt; s; 23 int cnt = 0; 24 for (int j = 0; s[j] \u0026amp;\u0026amp; key[j]; j++) { 25 int a = s[j] - \u0026#39;a\u0026#39;, b = key[j] - \u0026#39;a\u0026#39;; 26 cnt += abs(x[a] - x[b]) + abs(y[a] - y[b]); 27 } 28 v.push_back(pair\u0026lt;int, string\u0026gt;(cnt, s)); 29 } 30 sort(v.begin(), v.end()); 31 for (auto r : v) 32 cout \u0026lt;\u0026lt; r.second \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r.first \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 33 } 34 return 0; 35} Kattis - Pivot 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int n; cin \u0026gt;\u0026gt; n; 6 vector\u0026lt;int\u0026gt; a(n); 7 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 8 vector\u0026lt;bool\u0026gt; check(n, true); 9 int mx = a[0]; 10 for (int i = 0; i \u0026lt; n; i++) { 11 if (a[i] \u0026lt; mx) check[i] = false; 12 mx = max(mx, a[i]); 13 } 14 int mn = a[n - 1]; 15 for (int i = n - 1; i \u0026gt;= 0; i--) { 16 if (a[i] \u0026gt; mn) check[i] = false; 17 mn = min(mn, a[i]); 18 } 19 int cnt = 0; 20 for (int i = 0; i \u0026lt; n; i++) 21 cnt += check[i]; 22 cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 23 return 0; 24} Prva 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int r, c; 6 cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c; 7 vector\u0026lt;string\u0026gt; v(r); 8 for (int i = 0; i \u0026lt; r; i++) 9 cin \u0026gt;\u0026gt; v[i]; 10 string ans = \u0026#34;{\u0026#34;; 11 for (int i = 0; i \u0026lt; r; i++) { 12 string tmp = \u0026#34;\u0026#34;; 13 for (int j = 0; j \u0026lt; c; j++) { 14 if (v[i][j] == \u0026#39;#\u0026#39;) { 15 if (tmp.length() \u0026gt;= 2) 16 ans = min(ans, tmp); 17 tmp = \u0026#34;\u0026#34;; 18 } else tmp += v[i][j]; 19 } 20 if (tmp.length() \u0026gt;= 2) 21 ans = min(ans, tmp); 22 } 23 for (int j = 0; j \u0026lt; c; j++) { 24 string tmp = \u0026#34;\u0026#34;; 25 for (int i = 0; i \u0026lt; r; i++) { 26 if (v[i][j] == \u0026#39;#\u0026#39;) { 27 if (tmp.length() \u0026gt;= 2) 28 ans = min(ans, tmp); 29 tmp = \u0026#34;\u0026#34;; 30 } else tmp += v[i][j]; 31 } 32 if (tmp.length() \u0026gt;= 2) 33 ans = min(ans, tmp); 34 } 35 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 36 return 0; 37} Jane Eyre 覺得 input 格式很難處理～\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;string, int\u0026gt; psi; 4typedef pair\u0026lt;int, psi\u0026gt; pisi; 5typedef long long ll; 6psi split(string s) { 7 bool flag = false; 8 for (int i = 0; s[i]; i++) { 9 if (flag \u0026amp;\u0026amp; s[i] == \u0026#39; \u0026#39;) s[i] = \u0026#39;$\u0026#39;; 10 else if (s[i] == \u0026#39;\\\u0026#34;\u0026#39;) { 11 if (flag) break; 12 flag = true; 13 } 14 } 15 stringstream ss; 16 ss.clear(); ss.str(s); 17 string name; 18 int page; 19 ss \u0026gt;\u0026gt; name \u0026gt;\u0026gt; page; 20 for (int i = 0; name[i]; i++) 21 if (name[i] == \u0026#39;$\u0026#39;) name[i] = \u0026#39; \u0026#39;; 22 return psi(name, page); 23} 24int main () { 25 ios::sync_with_stdio(0), cin.tie(0); 26 int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; 27 priority_queue\u0026lt;psi, vector\u0026lt;psi\u0026gt;, greater\u0026lt;psi\u0026gt; \u0026gt; pq; 28 psi goal = psi(\u0026#34;\\\u0026#34;Jane Eyre\\\u0026#34;\u0026#34;, k); 29 pq.push(goal); 30 for (int i = 0; i \u0026lt; n; i++) { 31 string s1, s2; 32 cin \u0026gt;\u0026gt; s1; 33 getline(cin, s2); 34 pq.push(split(s1 + s2)); 35 } 36 priority_queue\u0026lt;pisi, vector\u0026lt;pisi\u0026gt;, greater\u0026lt;pisi\u0026gt; \u0026gt; pq2; 37 for (int i = 0; i \u0026lt; m; i++) { 38 int t; cin \u0026gt;\u0026gt; t; 39 string s; getline(cin, s); 40 pq2.push(pisi(t, split(s))); 41 } 42 ll time = 0; 43 while (1) { 44 while (!pq2.empty()) { 45 if (pq.empty() || pq2.top().first \u0026lt;= time) { 46 pq.push(pq2.top().second); 47 pq2.pop(); 48 } else break; 49 } 50 if (pq.empty()) break; 51 time += pq.top().second; 52 if (pq.top() == goal) break; 53 pq.pop(); 54 } 55 cout \u0026lt;\u0026lt; time \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 56 return 0; 57} Sim 原本想用 Linked List 做，但後來發現 deque 比較好寫。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 ios::sync_with_stdio(0); cin.tie(0); 5 int T; cin \u0026gt;\u0026gt; T; cin.ignore(); 6 while (T--) { 7 string s; 8 getline(cin, s); 9 deque\u0026lt;string\u0026gt; dq; 10 dq.push_front(\u0026#34;\u0026#34;); 11 int state = 0; 12 for (int i = 0; s[i]; i++) { 13 if (s[i] == \u0026#39;\u0026lt;\u0026#39;) { 14 if (!state) { 15 if (dq.front() != \u0026#34;\u0026#34;) 16 dq.front().pop_back(); 17 } else { 18 if (dq.back() != \u0026#34;\u0026#34;) 19 dq.back().pop_back(); 20 } 21 } else if (s[i] == \u0026#39;[\u0026#39;) { 22 if (dq.front() != \u0026#34;\u0026#34;) 23 dq.push_front(\u0026#34;\u0026#34;); 24 state = 0; 25 } else if (s[i] == \u0026#39;]\u0026#39;) { 26 state = -1; 27 } else { 28 if (state) dq.back().push_back(s[i]); 29 else dq.front().push_back(s[i]); 30 } 31 } 32 string ans; 33 while (!dq.empty()) { 34 ans += dq.front(); 35 dq.pop_front(); 36 } 37 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 38 } 39 return 0; 40} Teque 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 ios::sync_with_stdio(0); cin.tie(0); 5 int N; cin \u0026gt;\u0026gt; N; 6 deque\u0026lt;int\u0026gt; dq1, dq2; 7 while (N--) { 8 string op; cin \u0026gt;\u0026gt; op; 9 int x; cin \u0026gt;\u0026gt; x; 10 if (op == \u0026#34;push_back\u0026#34;) { 11 dq2.push_back(x); 12 } else if (op == \u0026#34;push_front\u0026#34;) { 13 dq1.push_front(x); 14 } else if (op == \u0026#34;push_middle\u0026#34;) { 15 int sz1 = (dq1.size() + dq2.size() + 1) / 2; 16 while (dq1.size() \u0026lt; sz1) { 17 dq1.push_back(dq2.front()); 18 dq2.pop_front(); 19 } 20 while (dq1.size() \u0026gt; sz1) { 21 dq2.push_front(dq1.back()); 22 dq1.pop_back(); 23 } 24 dq1.push_back(x); 25 } else if (op == \u0026#34;get\u0026#34;) { 26 if (dq1.size() \u0026gt; x) 27 cout \u0026lt;\u0026lt; dq1[x] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 else cout \u0026lt;\u0026lt; dq2[x - dq1.size()] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 29 } 30 } 31 return 0; 32} Continuous Median 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 ios::sync_with_stdio(0); cin.tie(0); 5 int T; cin \u0026gt;\u0026gt; T; 6 while (T--) { 7 int n; cin \u0026gt;\u0026gt; n; 8 priority_queue\u0026lt;int\u0026gt; pq1; 9 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; pq2; 10 pq1.push(-1), pq2.push(2e9); 11 long long ans = 0; 12 for (int i = 0; i \u0026lt; n; i++) { 13 int x; cin \u0026gt;\u0026gt; x; 14 if (pq2.size() \u0026gt;= pq1.size()) pq1.push(x); 15 else pq2.push(x); 16 while (pq1.top() \u0026gt; pq2.top()) { 17 pq1.push(pq2.top()); 18 pq2.push(pq1.top()); 19 pq1.pop(), pq2.pop(); 20 } 21 if (i \u0026amp; 1) ans += (pq1.top() + pq2.top()) / 2; 22 else ans += pq1.top(); 23 } 24 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 25 } 26 return 0; 27} Almost Union-Find 1 ≤ n, m ≤ 1e5，有三種操作：\n1 p q 代表將 p 和 q 所屬的集合合併。 2 p q 代表將 p 移到 q 所屬的集合。 3 p 為查詢 p 所屬集合大小及元素和。 操作 2 較難處理，方法為創出新的節點，並將元素指向新的節點。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 ios::sync_with_stdio(0); cin.tie(0); 5 int n, m; 6 while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m) { 7 vector\u0026lt;long long\u0026gt; sum(n + 1); 8 vector\u0026lt;int\u0026gt; sz(n + 1, 1), par(n + 1), point(n + 1); 9 for (int i = 1; i \u0026lt;= n; i++) 10 par[i] = sum[i] = point[i] = i; 11 while (m--) { 12 int op, p, q; cin \u0026gt;\u0026gt; op; 13 if (op == 2) { 14 cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q; 15 int pp = p; 16 pp = point[pp], q = point[q]; 17 while (pp != par[pp]) pp = par[pp]; 18 while (q != par[q]) q = par[q]; 19 if (pp == q) continue; 20 sz[pp]--, sum[pp] -= p; 21 point[p] = par.size(); 22 par.push_back(q); 23 sz[q]++, sum[q] += p; 24 } else if (op == 1) { 25 cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q; 26 p = point[p], q = point[q]; 27 while (p != par[p]) p = par[p]; 28 while (q != par[q]) q = par[q]; 29 if (p == q) continue; 30 if (sz[p] \u0026gt; sz[q]) { 31 int t = p; p = q; q = t; 32 } 33 par[p] = q; 34 sum[q] += sum[p]; 35 sz[q] += sz[p]; 36 } else if (op == 3) { 37 cin \u0026gt;\u0026gt; p; 38 p = point[p]; 39 while (p != par[p]) p = par[p]; 40 cout \u0026lt;\u0026lt; sz[p] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sum[p] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 41 } 42 } 43 } 44 return 0; 45} Thank God it’s Friday 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3string M[12] = {\u0026#34;JAN\u0026#34;, \u0026#34;FEB\u0026#34;, \u0026#34;MAR\u0026#34;, \u0026#34;APR\u0026#34;, \u0026#34;MAY\u0026#34;, \u0026#34;JUN\u0026#34;, 4 \u0026#34;JUL\u0026#34;, \u0026#34;AUG\u0026#34;, \u0026#34;SEP\u0026#34;, \u0026#34;OCT\u0026#34;, \u0026#34;NOV\u0026#34;, \u0026#34;DEC\u0026#34;}; 5int cnt[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 6string W[7] = {\u0026#34;MON\u0026#34;, \u0026#34;TUE\u0026#34;, \u0026#34;WED\u0026#34;, \u0026#34;THU\u0026#34;, \u0026#34;FRI\u0026#34;, \u0026#34;SAT\u0026#34;, \u0026#34;SUN\u0026#34;}; 7int main () { 8 int d; 9 string m, w; 10 cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; m \u0026gt;\u0026gt; w; 11 for (int i = 0; M[i] != m; i++) 12 d += cnt[i]; 13 int day = d - 1; 14 for (int i = 0; W[i] != w; i++) 15 day++; 16 day %= 7; 17 if (m == M[0] || m == M[1]) { 18 if (day == 4) cout \u0026lt;\u0026lt; \u0026#34;TGIF\\n\u0026#34;; 19 else cout \u0026lt;\u0026lt; \u0026#34;:(\\n\u0026#34;; 20 } else { 21 if (day == 4 || day == 3) cout \u0026lt;\u0026lt; \u0026#34;not sure\\n\u0026#34;; 22 else cout \u0026lt;\u0026lt; \u0026#34;:(\\n\u0026#34;; 23 } 24 return 0; 25} Natrij 1h1, m1, s1 = [int(i) for i in input().split(\u0026#39;:\u0026#39;)] 2h2, m2, s2 = [int(i) for i in input().split(\u0026#39;:\u0026#39;)] 3s = ((h2 - h1 + 24) * 60 + m2 - m1) * 60 + s2 - s1 4if s % (24 * 3600) == 0: 5 print(\u0026#34;24:00:00\u0026#34;) 6else: 7 print(\u0026#39;%02d:%02d:%02d\u0026#39; % (s // 3600 % 24, s // 60 % 60, s % 60) ) Semafori 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4typedef pair\u0026lt;int, pii\u0026gt; piii; 5#define x first 6#define y second 7int main () { 8 ios::sync_with_stdio(0), cin.tie(0); 9 int n, L; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L; 10 vector\u0026lt;piii\u0026gt; p(n); 11 for (int i = 0; i \u0026lt; n; i++) 12 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y.x \u0026gt;\u0026gt; p[i].y.y; 13 sort(p.begin(), p.end()); 14 int cnt = 0; 15 for (int i = 0; i \u0026lt; n; i++) { 16 int t = p[i].x + cnt; 17 int cycle = p[i].y.x + p[i].y.y; 18 if (t % cycle \u0026lt; p[i].y.x) 19 cnt += p[i].y.x - t % cycle; 20 } 21 cout \u0026lt;\u0026lt; L + cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 22 return 0; 23} Triple Texting 1s = input() 2L = len(s) // 3 3for i in range(L): 4 if s[i] == s[i + L]: 5 print(s[i], end = \u0026#39;\u0026#39;) 6 else: 7 print(s[i + L + L], end = \u0026#39;\u0026#39;) Functional Fun 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3bool input(set\u0026lt;string\u0026gt; \u0026amp;st) { 4 string s; cin \u0026gt;\u0026gt; s; 5 if (cin.fail()) return false; 6 getline(cin, s); 7 stringstream ss; 8 ss.clear(); ss.str(s); 9 while (ss \u0026gt;\u0026gt; s) st.insert(s); 10 return true; 11} 12int main () { 13 ios::sync_with_stdio(0); cin.tie(0); 14 while (1) { 15 set \u0026lt;string\u0026gt; domain, codomain; 16 if (!input(domain) || !input(codomain)) break; 17 int sz1 = domain.size(), sz2 = codomain.size(); 18 int m; cin \u0026gt;\u0026gt; m; 19 bool surjective = true, injective = true; 20 bool function = true; 21 map\u0026lt;string, string\u0026gt; mp; 22 while (m--) { 23 string x, y, tmp; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; tmp \u0026gt;\u0026gt; y; 24 if (mp.find(x) != mp.end()) { 25 if (mp[x] != y) function = false; 26 else continue; 27 } 28 mp[x] = y; 29 if (!codomain.count(y)) injective = false; 30 else codomain.erase(y); 31 } 32 if (codomain.size()) surjective = false; 33 if (!function) cout \u0026lt;\u0026lt; \u0026#34;not a function\\n\u0026#34;; 34 else if (injective \u0026amp;\u0026amp; surjective) cout \u0026lt;\u0026lt; \u0026#34;bijective\\n\u0026#34;; 35 else if (injective) cout \u0026lt;\u0026lt; \u0026#34;injective\\n\u0026#34;; 36 else if (surjective) cout \u0026lt;\u0026lt; \u0026#34;surjective\\n\u0026#34;; 37 else cout \u0026lt;\u0026lt; \u0026#34;neither injective nor surjective\\n\u0026#34;; 38 } 39 return 0; 40} Timebomb 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3string digit[5] = {\u0026#34;*** * *** *** * * *** *** *** *** *** \u0026#34;, 4 \u0026#34;* * * * * * * * * * * * * * \u0026#34;, 5 \u0026#34;* * * *** *** *** *** *** * *** *** \u0026#34;, 6 \u0026#34;* * * * * * * * * * * * * \u0026#34;, 7 \u0026#34;*** * *** *** * *** *** * *** *** \u0026#34;}; 8int main () { 9 string s[5]; 10 for (int i = 0; i \u0026lt; 5; i++) { 11 getline(cin, s[i]); 12 s[i] += \u0026#34; \u0026#34;; 13 } 14 int cnt = 0, len = s[0].length() / 4; 15 for (int i = 0; i \u0026lt; len; i++) { 16 int d = -1; 17 for (int j = 0; j \u0026lt;= 9; j++) { 18 bool check = true; 19 for (int x = 0; x \u0026lt; 5 \u0026amp;\u0026amp; check; x++) 20 for (int y = 0; y \u0026lt; 4 \u0026amp;\u0026amp; check; y++) 21 if (s[x][i * 4 + y] != digit[x][j * 4 + y]) 22 check = false; 23 if (check) {d = j; break;} 24 } 25 if (d == -1) { cout \u0026lt;\u0026lt; \u0026#34;BOOM!!\\n\u0026#34;; return 0;} 26 else cnt = cnt * 10 + d; 27 } 28 if (cnt % 6) cout \u0026lt;\u0026lt; \u0026#34;BOOM!!\\n\u0026#34;; 29 else cout \u0026lt;\u0026lt; \u0026#34;BEER!!\\n\u0026#34;; 30 return 0; 31} Average Speed 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int T(string s) { 4 int h = (s[0] - \u0026#39;0\u0026#39;) * 10 + s[1] - \u0026#39;0\u0026#39;; 5 int m = (s[3] - \u0026#39;0\u0026#39;) * 10 + s[4] - \u0026#39;0\u0026#39;; 6 int ss = (s[6] - \u0026#39;0\u0026#39;) * 10 + s[7] - \u0026#39;0\u0026#39;; 7 return (h * 60 + m) * 60 + ss; 8} 9void input(string s, int \u0026amp;op, int \u0026amp;speed, int \u0026amp;time) { 10 stringstream ss; 11 ss.clear(); ss.str(s); 12 ss \u0026gt;\u0026gt; s; 13 if (ss \u0026gt;\u0026gt; speed) op = 0; 14 else op = 1; 15 time = T(s); 16} 17int main () { 18 int cnt = 0, speed = 0, last = 0; 19 while (1) { 20 string s; 21 getline(cin, s); 22 if (cin.fail()) break; 23 int op, time, new_speed; 24 input(s, op, new_speed, time); 25 if (op) { 26 double dis = (cnt + (time - last) * speed) / 3600.0; 27 cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; dis \u0026lt;\u0026lt; \u0026#34; km\\n\u0026#34;; 28 } else { 29 cnt += (time - last) * speed; 30 speed = new_speed; 31 last = time; 32 } 33 } 34 return 0; 35} Circuit Math 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 ios::sync_with_stdio(0); cin.tie(0); 5 int n; cin \u0026gt;\u0026gt; n; 6 vector\u0026lt;char\u0026gt; r(n); 7 for (int i = 0; i \u0026lt; n; i++) 8 cin \u0026gt;\u0026gt; r[i]; 9 char c; 10 vector\u0026lt;bool\u0026gt; v; 11 while (cin \u0026gt;\u0026gt; c) { 12 if (c == \u0026#39;*\u0026#39;) { 13 bool t = v.back(); 14 v.pop_back(); 15 v.back() = v.back() \u0026amp;\u0026amp; t; 16 } else if (c == \u0026#39;+\u0026#39;) { 17 bool t = v.back(); 18 v.pop_back(); 19 v.back() = v.back() || t; 20 } else if (c == \u0026#39;-\u0026#39;) { 21 v.back() = !v.back(); 22 } else { 23 v.push_back(r[c - \u0026#39;A\u0026#39;] == \u0026#39;T\u0026#39;); 24 } 25 } 26 cout \u0026lt;\u0026lt; \u0026#34;FT\u0026#34;[v.back()] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 27 return 0; 28} Three Powers 1while True: 2 n = int(input()) 3 if n == 0: 4 break 5 n -= 1 6 now = 1 7 L = [] 8 while n != 0: 9 if n \u0026amp; 1 == 1: 10 L.append(now) 11 n \u0026gt;\u0026gt;= 1 12 now *= 3 13 ans = \u0026#39;\u0026#39; 14 for i in L: 15 ans += \u0026#39; \u0026#39; + str(i) + \u0026#39;,\u0026#39; 16 print(\u0026#39;{\u0026#39; + ans[:-1] + \u0026#39; }\u0026#39;) Quick Brown Fox 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 ios::sync_with_stdio(0); cin.tie(0); 5 int T; cin \u0026gt;\u0026gt; T; cin.ignore(); 6 while (T--) { 7 string s; getline(cin, s); 8 int cnt[26] = {}; 9 for (char c : s) 10 if (isupper(c)) cnt[c - \u0026#39;A\u0026#39;]++; 11 else if (islower(c)) cnt[c - \u0026#39;a\u0026#39;]++; 12 string ans = \u0026#34;\u0026#34;; 13 for (int i = 0; i \u0026lt; 26; i++) 14 if (!cnt[i]) ans += i + \u0026#39;a\u0026#39;; 15 if (ans.length()) cout \u0026lt;\u0026lt; \u0026#34;missing \u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 16 else cout \u0026lt;\u0026lt; \u0026#34;pangram\\n\u0026#34;; 17 } 18 return 0; 19} Square Peg in a Round Hole 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; 5 vector\u0026lt;int\u0026gt; R(n); 6 for (int i = 0; i \u0026lt; n; i++) { 7 cin \u0026gt;\u0026gt; R[i]; 8 R[i] *= 4 * R[i]; 9 } 10 priority_queue\u0026lt;int\u0026gt; pq; 11 for (int i = 0; i \u0026lt; m; i++) { 12 int c; cin \u0026gt;\u0026gt; c; 13 pq.push(4 * c * c); 14 } 15 for (int i = 0; i \u0026lt; k; i++) { 16 int s; cin \u0026gt;\u0026gt; s; 17 pq.push(2 * s * s); 18 } 19 sort(R.begin(), R.end()); 20 reverse(R.begin(), R.end()); 21 int ans = 0; 22 for (int i = 0; i \u0026lt; n; i++) { 23 while (!pq.empty() \u0026amp;\u0026amp; pq.top() \u0026gt;= R[i]) 24 pq.pop(); 25 if (!pq.empty()) 26 pq.pop(), ans++; 27 } 28 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 29 return 0; 30} Radio Commercials 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 int n, p; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; 5 int ans = 0, cnt = 0; 6 for (int i = 0; i \u0026lt; n; i++) { 7 int x; cin \u0026gt;\u0026gt; x; 8 cnt += x - p; 9 ans = max(ans, cnt); 10 cnt = max(cnt, 0); 11 } 12 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 return 0; 14} Ultra-QuickSort 算逆序數對數量，9 ~ 11 行寫起來略卡。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4vector\u0026lt;ll\u0026gt; v, tmp; 5ll inv(int l, int r) { 6 if (l \u0026gt;= r) return 0; 7 int m = (l + r) \u0026gt;\u0026gt; 1; 8 ll ret = inv(l, m) + inv(m + 1, r); 9 for (int i = l, j = m + 1, k = l; k \u0026lt;= r; k++) 10 if (i \u0026gt; m || (j \u0026lt;= r \u0026amp;\u0026amp; v[i] \u0026gt; v[j])) tmp[k] = v[j++]; 11 else tmp[k] = v[i++], ret += j - m - 1; 12 for (int i = l; i \u0026lt;= r; i++) v[i] = tmp[i]; 13 return ret; 14} 15int main () { 16 int n; cin \u0026gt;\u0026gt; n; 17 v.resize(n), tmp.resize(n); 18 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; 19 cout \u0026lt;\u0026lt; inv(0, n - 1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 20 return 0; 21} The Dragon of Loowater 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 int n, m; 5 while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m) { 6 if (!n \u0026amp;\u0026amp; !m) break; 7 vector\u0026lt;int\u0026gt; a(n), b(m); 8 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 9 for (int i = 0; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; b[i]; 10 sort(a.begin(), a.end()); 11 sort(b.begin(), b.end()); 12 int ans = 0; 13 for (int i = 0, j = 0; i \u0026lt; n; i++) { 14 while (j \u0026lt; m \u0026amp;\u0026amp; a[i] \u0026gt; b[j]) ++j; 15 if (j \u0026lt; m) ans += b[j++]; 16 else { ans = -1; break;} 17 } 18 if (ans == -1) cout \u0026lt;\u0026lt; \u0026#34;Loowater is doomed!\\n\u0026#34;; 19 else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 20 } 21 return 0; 22} Postal Delivery 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4typedef long long ll; 5ll solve(vector\u0026lt;pii\u0026gt; \u0026amp;v, int k) { 6 ll ret = 0; 7 sort(v.begin(), v.end()); 8 while (v.size()) { 9 int cap = k; 10 ret += v.back().first; 11 while (v.size() \u0026amp;\u0026amp; cap) { 12 int load = min(cap, v.back().second); 13 v.back().second -= load, cap -= load; 14 if (!v.back().second) v.pop_back(); 15 } 16 } 17 return ret; 18} 19int main () { 20 int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; 21 vector\u0026lt;pii\u0026gt; v[2]; 22 for (int i = 0; i \u0026lt; n; i++) { 23 int x, t; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; t; 24 if (x \u0026lt; 0) v[1].push_back(pii(-x, t)); 25 else v[0].push_back(pii(x, t)); 26 } 27 cout \u0026lt;\u0026lt; (solve(v[0], k) + solve(v[1], k)) * 2 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 return 0; 29} Ladice Union-Find Tree，覺得題目出得很好。 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3struct UnionFind { 4 vector\u0026lt;int\u0026gt; p, r, sz; 5 UnionFind(int n) { 6 p.resize(n), r.resize(n, 1), sz.resize(n, 1); 7 for (int i = 0; i \u0026lt; n; i++) p[i] = i; 8 } 9 int par(int x) { 10 while (x != p[x]) x = p[x]; 11 return x; 12 } 13 int size(int x) { return sz[par(x)]; } 14 void add(int x) { sz[par(x)]--; } 15 void uni(int a, int b) { 16 a = par(a), b = par(b); 17 if (a == b) return; 18 if (r[a] \u0026gt; r[b]) { int t = a; a = b; b = t; } 19 else if (r[a] == r[b]) r[b]++; 20 p[a] = b, sz[b] += sz[a]; 21 } 22}; 23int main () { 24 ios::sync_with_stdio(0), cin.tie(0); 25 int n, L; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L; 26 UnionFind uf(L); 27 for (int i = 0; i \u0026lt; n; i++) { 28 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 29 uf.uni(--a, --b); 30 if (uf.size(a)) uf.add(a), cout \u0026lt;\u0026lt; \u0026#34;LADICA\\n\u0026#34;; 31 else cout \u0026lt;\u0026lt; \u0026#34;SMECE\\n\u0026#34;; 32 } 33 return 0; 34} Misa 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 int r, s; cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; s; 5 vector\u0026lt;string\u0026gt; a(r); 6 for (int i = 0; i \u0026lt; r; i++) cin \u0026gt;\u0026gt; a[i]; 7 int mx = 0, sum = 0; 8 for (int i = 0; i \u0026lt; r; i++) { 9 for (int j = 0; j \u0026lt; s; j++) { 10 int cnt = 0; 11 for (int dx = -1; dx \u0026lt;= 1; dx++) { 12 for (int dy = -1; dy \u0026lt;= 1; dy++) { 13 int x = i + dx, y = j + dy; 14 if (x \u0026lt; 0 || y \u0026lt; 0 || 15 x \u0026gt;= r || y \u0026gt;= s) continue; 16 if (a[x][y] == \u0026#39;o\u0026#39;) cnt++; 17 } 18 } 19 if (a[i][j] == \u0026#39;o\u0026#39;) sum += cnt - 1; 20 else mx = max(mx, cnt); 21 } 22 } 23 cout \u0026lt;\u0026lt; sum / 2 + mx \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 24 return 0; 25} Relocation 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 6 vector\u0026lt;int\u0026gt; v(n + 1); 7 for (int i = 1; i \u0026lt;= n; i++) 8 cin \u0026gt;\u0026gt; v[i]; 9 while (q--) { 10 int op, a, b; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 11 if (op == 1) v[a] = b; 12 else cout \u0026lt;\u0026lt; abs(v[a] - v[b]) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 } 14 return 0; 15} Firefly 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 int n, h; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h; 7 vector\u0026lt;int\u0026gt; a(n); 8 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 9 vector\u0026lt;int\u0026gt; even(h + 1), odd(h + 1); 10 for (int i = 0; i \u0026lt; n; i += 2) 11 even[a[i]]++, odd[a[i + 1]]++; 12 for (int i = h - 2; i \u0026gt;= 1; i--) 13 even[i] += even[i + 1], odd[i] += odd[i + 1]; 14 int ans = n, cnt = 0; 15 for (int i = 1; i \u0026lt;= h; i++) { 16 int sum = odd[h - i + 1] + even[i]; 17 if (sum \u0026lt; ans) ans = sum, cnt = 1; 18 else if (sum == ans) cnt++; 19 } 20 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 21 return 0; 22} Alphabet 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 string s; cin \u0026gt;\u0026gt; s; 5 int dp[30][55] = {}; 6 for (int i = 0; i \u0026lt; 26; i++) 7 for (int j = 0; s[j]; j++) 8 if (s[j] == i + \u0026#39;a\u0026#39;) 9 dp[i + 1][j + 1] = dp[i][j] + 1; 10 else 11 dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]); 12 cout \u0026lt;\u0026lt; 26 - dp[26][s.length()] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 return 0; 14} Walrus Weights 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main () { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int n; cin \u0026gt;\u0026gt; n; 6 bool dp[2005] = {true}; 7 for (int i = 0; i \u0026lt; n; i++) { 8 int x; cin \u0026gt;\u0026gt; x; 9 for (int j = 2000; j \u0026gt;= x; j--) 10 dp[j] = dp[j] | dp[j - x]; 11 } 12 for (int i = 0; i \u0026lt;= 1000; i++) 13 if (dp[1000 + i]) { 14 cout \u0026lt;\u0026lt; 1000 + i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 15 return 0; 16 } else if (dp[1000 - i]) { 17 cout \u0026lt;\u0026lt; 1000 - i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 18 return 0; 19 } 20 return 0; 21} Add Two Numbers 1private fun readLn() = readLine()!! 2fun main() { 3 val (a, b) = readLn().split(\u0026#39; \u0026#39;).map { it.toInt() } 4 println(a + b) 5} Which is Greater? 1private fun readInts() = readLine()!!.split(\u0026#39; \u0026#39;).map{ it.toInt() } 2fun main() { 3 val (a, b) = readInts() 4 val ans = if (a \u0026gt; b) 1 else 0 5 println(ans) 6} Triangle Area 1private fun readLn() = readLine()!! 2fun main() { 3 val (a, b) = readLn().split(\u0026#39; \u0026#39;).map { it.toInt() } 4 println(a * b * 0.5) 5} ","date":"2022-06-16T09:32:03+08:00","permalink":"https://luke2336.github.io/p/kattis/","title":"Kattis"},{"content":"1202 - Investigation 最短路徑水題 Dijkstra 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int mod = 1000000007; 4typedef long long ll; 5typedef pair\u0026lt;ll, int\u0026gt; pii; 6#define pb push_back 7int main () { 8 ios_base::sync_with_stdio(0); cin.tie(0); 9 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 10 vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n + 1); 11 for (int i = 0; i \u0026lt; m; i++) { 12 int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; 13 G[a].pb(pii(c, b)); 14 } 15 vector\u0026lt;bool\u0026gt; visit(n + 1); 16 vector\u0026lt;ll\u0026gt; dis(n + 1, ll(m) * ll(1e9)); 17 vector\u0026lt;ll\u0026gt; cnt(n + 1, 0), mn(n + 1), mx(n + 1); 18 dis[1] = 0, cnt[1] = 1; 19 priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, greater\u0026lt;pii\u0026gt;\u0026gt; pq; 20 pq.push(pii(0, 1)); 21 while (!pq.empty()) { 22 int u = pq.top().second; pq.pop(); 23 if (visit[u]) continue; 24 visit[u] = true; 25 for (pii e : G[u]) { 26 int uu = e.second; ll w = e.first; 27 if (dis[uu] == dis[u] + w) { 28 cnt[uu] = (cnt[u] + cnt[uu]) % mod; 29 mn[uu] = min(mn[uu], mn[u] + 1); 30 mx[uu] = max(mx[uu], mx[u] + 1); 31 } else if (dis[uu] \u0026gt; dis[u] + w) { 32 dis[uu] = dis[u] + w; 33 cnt[uu] = cnt[u] % mod; 34 mn[uu] = mn[u] + 1; 35 mx[uu] = mx[u] + 1; 36 pq.push(pii(dis[uu], uu)); 37 } 38 } 39 } 40 cout \u0026lt;\u0026lt; dis[n] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; cnt[n] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; mn[n] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; mx[n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 41 return 0; 42} 1146 - Counting Bits 問 1 ~ n 的二進制表示法中，共有多少個 1-bit？\n十進位 $$2^2$$ $$2^1$$ $$2^0$$ 0 0 0 0 1 0 0 1 2 0 1 0 3 0 1 1 4 1 0 0 5 1 0 1 6 1 1 0 7 1 1 1 觀察 0/1 交替的方式，最末位是每隔 1 個，接下來是每隔 2 個，接下來是每隔 4 個\u0026hellip;\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4int main() { 5 ll n, ans = 0; 6 cin \u0026gt;\u0026gt; n; n++; 7 for (ll i = 1; i \u0026lt;= n; i \u0026lt;\u0026lt;= 1) { 8 ll c = n / i; 9 if (c \u0026amp; 1) ans += c / 2 * i + n % i; 10 else ans += c / 2 * i; 11 } 12 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 return 0; 14} 11677 - Network Breakdown 題目是問給一張圖，每次刪除一條邊後，回答所剩的聯通塊數目。\n用 Union Find Tree 維護聯通塊，離線倒著回答詢問，也就是一條一條加回去。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4#define x first 5#define y second 6vector\u0026lt;pii\u0026gt; remove(vector\u0026lt;pii\u0026gt; e, vector\u0026lt;pii\u0026gt; q) { 7 sort(q.begin(), q.end()); 8 vector\u0026lt;pii\u0026gt; ret; 9 for (pii p : e) { 10 auto iter = lower_bound(q.begin(), q.end(), p); 11 if (iter == q.end() || *iter != p) 12 ret.push_back(p); 13 } 14 return ret; 15} 16struct UF { 17 int cnt; 18 vector\u0026lt;int\u0026gt; p, r; 19 UF(int n): cnt(n) { 20 p.resize(n + 1), r.resize(n + 1); 21 for (int i = 1; i \u0026lt;= n; i++) p[i] = i; 22 } 23 int par(int x) { 24 return p[x] = ((p[x] == x) ? x : par(p[x])); 25 } 26 void uni(int a, int b) { 27 a = par(a), b = par(b); 28 if (a == b) return; 29 if (r[a] \u0026lt; r[b]) {int t = a; a = b; b = t;} 30 p[b] = a, r[a] += (r[a] == r[b]), cnt--; 31 } 32}; 33int main() { 34 ios::sync_with_stdio(0); cin.tie(0); 35 int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; 36 UF T(n); 37 vector\u0026lt;pii\u0026gt; e(m), q(k); 38 for (int i = 0; i \u0026lt; m; i++) { 39 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 40 e[i] = pii(min(a, b), max(a, b)); 41 } 42 for (int i = 0; i \u0026lt; k; i++) { 43 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 44 q[i] = pii(min(a, b), max(a ,b)); 45 } 46 e = remove(e, q); 47 for (pii p : e) 48 T.uni(p.x, p.y); 49 vector\u0026lt;int\u0026gt; ans; 50 reverse(q.begin(), q.end()); 51 for (pii p : q) { 52 ans.push_back(T.cnt); 53 T.uni(p.x, p.y); 54 } 55 for(int i = k - 1; i \u0026gt;= 0 ; i--) 56 cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 57 return 0; 58} 2189 - Point Location Test 基礎的幾何題。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;ll, ll\u0026gt; point; 5#define x first 6#define y second 7ll check(point p[]) { 8 ll dx = p[1].x - p[0].x, dy = p[1].y - p[0].y; 9 return (p[2].y - p[1].y) * dx + (p[1].x - p[2].x) * dy; 10} 11int main () { 12 ios::sync_with_stdio(0), cin.tie(0); 13 int t; cin \u0026gt;\u0026gt; t; 14 while (t--) { 15 point p[3]; 16 for (int i = 0; i \u0026lt; 3; i++) 17 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 18 ll c = check(p); 19 if (c \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#34;LEFT\\n\u0026#34;; 20 else if (c \u0026lt; 0) cout \u0026lt;\u0026lt; \u0026#34;RIGHT\\n\u0026#34;; 21 else cout \u0026lt;\u0026lt; \u0026#34;TOUCH\\n\u0026#34;; 22 } 23 return 0; 24} 2191 - Polygon Area 給一個簡單多邊形，輸出面積的兩倍。\n1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;ll, ll\u0026gt; pii; 6#define x first 7#define y second 8#define pb push_back 9ll det(vector\u0026lt;pii\u0026gt; \u0026amp;p, int n) { 10 ll cnt = 0; 11 for (int i = 0; i \u0026lt; n; i++) 12 cnt += p[i].x * p[i + 1].y - p[i + 1].x * p[i].y; 13 return (cnt \u0026gt; 0) ? cnt : -cnt; 14} 15int main() { 16 ios::sync_with_stdio(0), cin.tie(0); 17 int n; cin \u0026gt;\u0026gt; n; 18 vector\u0026lt;pii\u0026gt; p(n); 19 for (int i = 0; i \u0026lt; n; i++) 20 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 21 p.pb(p[0]); 22 cout \u0026lt;\u0026lt; det(p, n) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 23 return 0; 24} 2195 - Convex Hull 這題是要求在凸包上的所有點，所以 cross() \u0026lt; 0 才需要拔掉。 cross 的部分要記得開 long long，不然會溢位。 1// monotone chain 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4struct point { 5 long long x, y; 6 point() {} 7 point(long long _x, long long _y) { x = _x, y = _y;} 8 point operator-(const point p) { 9 return point(x - p.x, y - p.y); 10 } 11 long long cross(const point \u0026amp;p) { 12 return x * p.y - y * p.x; 13 } 14}; 15static bool cmp(const point \u0026amp;a, const point \u0026amp;b) { 16 return (a.x \u0026lt; b.x) || (a.x == b.x \u0026amp;\u0026amp; a.y \u0026lt; b.y); 17} 18void convex_hull(vector\u0026lt;point\u0026gt; p, vector\u0026lt;point\u0026gt; \u0026amp;h) { 19 sort(p.begin(), p.end(), cmp); 20 h.resize(p.size() + 1); 21 int m = 0; 22 for (int i = 0; i \u0026lt; p.size(); i++) { 23 while (m \u0026gt;= 2 \u0026amp;\u0026amp; 24 (h[m - 1] - h[m - 2]).cross(p[i] - h[m - 2]) \u0026lt; 0) 25 m--; 26 h[m++] = p[i]; 27 } 28 for (int i = p.size() - 2, t = m + 1; i \u0026gt;= 0; i--) { 29 while (m \u0026gt;= t \u0026amp;\u0026amp; 30 (h[m - 1] - h[m - 2]).cross(p[i] - h[m - 2]) \u0026lt; 0) 31 m--; 32 h[m++] = p[i]; 33 } 34 if (p.size() \u0026gt; 1) m--; 35 h.resize(m); 36} 37int main () { 38 ios::sync_with_stdio(0), cin.tie(0); 39 int n; cin \u0026gt;\u0026gt; n; 40 vector\u0026lt;point\u0026gt; P(n); 41 for (int i = 0; i \u0026lt; n; i++) 42 cin \u0026gt;\u0026gt; P[i].x \u0026gt;\u0026gt; P[i].y; 43 vector\u0026lt;point\u0026gt; H; 44 convex_hull(P, H); 45 cout \u0026lt;\u0026lt; H.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 46 for (point p : H) 47 cout \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 48 return 0; 49} 2205 - Gray Code 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6int main() { 7 ios::sync_with_stdio(0), cin.tie(0); 8 int n; cin \u0026gt;\u0026gt; n; 9 for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) { 10 for (int j = n - 1; j \u0026gt;= 0; j--) { 11 int a = i \u0026gt;\u0026gt; j; 12 int b = a \u0026gt;\u0026gt; 1; 13 cout \u0026lt;\u0026lt; ((a ^ b) \u0026amp; 1); 14 } 15 cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 16 } 17 return 0; 18} 1624 - Chessboard and Queens 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4bool a[8], b[20], c[20]; 5char m[8][9]; 6int ans = 0; 7void dfs (int i) { 8 if (i == 8) { 9 ans++; 10 return; 11 } 12 for (int j = 0; j \u0026lt; 8; j++) { 13 if (m[i][j] == \u0026#39;*\u0026#39;) continue; 14 if (a[j] || b[i + j] || c[i - j + 8]) continue; 15 a[j] = b[i + j] = c[i - j + 8] = true; 16 dfs(i + 1); 17 a[j] = b[i + j] = c[i - j + 8] = false; 18 } 19} 20int main() { 21 ios::sync_with_stdio(0), cin.tie(0); 22 for (int i = 0; i \u0026lt; 8; i++) scanf(\u0026#34; %s\u0026#34;, m[i]); 23 dfs(0); 24 printf(\u0026#34;%d\\n\u0026#34;, ans); 25 return 0; 26} 2183. Missing Coin Sum 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int n; 6 cin \u0026gt;\u0026gt; n; 7 vector\u0026lt;int\u0026gt; v(n); 8 for (int i = 0; i \u0026lt; n; ++i) 9 cin \u0026gt;\u0026gt; v[i]; 10 sort(v.begin(), v.end()); 11 if (v[0] \u0026gt; 1) { 12 cout \u0026lt;\u0026lt; \u0026#34;1\\n\u0026#34;; 13 return 0; 14 } 15 long long sum = v[0]; 16 for (int i = 1; i \u0026lt; n; i++) { 17 if (sum \u0026lt; v[i] - 1) { 18 cout \u0026lt;\u0026lt; sum + 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 19 return 0; 20 } 21 sum += v[i]; 22 } 23 cout \u0026lt;\u0026lt; sum + 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 24 return 0; 25} 2216. Collecting Numbers 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int n; 6 cin \u0026gt;\u0026gt; n; 7 vector\u0026lt;int\u0026gt; v(n); 8 for (int i = 0; i \u0026lt; n; i++) 9 cin \u0026gt;\u0026gt; v[i]; 10 vector\u0026lt;int\u0026gt; pos(n + 1); 11 for (int i = 0; i \u0026lt; n; i++) 12 pos[v[i]] = i; 13 int ans = 1; 14 for (int i = 2; i \u0026lt;= n; i++) 15 if (pos[i - 1] \u0026gt; pos[i]) 16 ans++; 17 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 18 return 0; 19} 2217. Collecting Numbers II 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; v(n); 8 for (int i = 0; i \u0026lt; n; i++) 9 cin \u0026gt;\u0026gt; v[i]; 10 vector\u0026lt;int\u0026gt; pos(n + 1); 11 for (int i = 0; i \u0026lt; n; i++) 12 pos[v[i]] = i; 13 int ans = 1; 14 for (int i = 2; i \u0026lt;= n; i++) 15 if (pos[i - 1] \u0026gt; pos[i]) 16 ans++; 17 while (q--) { 18 int a, b; 19 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 20 a--, b--; 21 int va = v[a]; 22 int vb = v[b]; 23 swap(v[a], v[b]); 24 set\u0026lt;int\u0026gt; s {max(va, 2), min(va + 1, n), max(vb, 2), min(vb + 1, n)}; 25 for (int i : s) 26 if (pos[i - 1] \u0026gt; pos[i]) 27 ans--; 28 pos[va] = b, pos[vb] = a; 29 for (int i : s) 30 if (pos[i - 1] \u0026gt; pos[i]) 31 ans++; 32 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 33 } 34 return 0; 35} 1753. String Matching 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3void z_build(string \u0026amp;s, vector\u0026lt;int\u0026gt; \u0026amp;z) { 4 int bst = z[0] = 0; 5 for (int i = 1; s[i]; ++i) { 6 if (z[bst] + bst \u0026lt; i) z[i] = 0; 7 else z[i] = min(z[bst] + bst - i, z[i - bst]); 8 while (s[z[i]] == s[i + z[i]]) ++z[i]; 9 if (z[i] + i \u0026gt; z[bst] + bst) bst = i; 10 } 11} 12int z_match(string \u0026amp;s, string \u0026amp;t) { 13 int ans = 0; 14 int lens = s.length(), lent = t.length(); 15 vector\u0026lt;int\u0026gt; z(lens + lent + 1); 16 string st = s + \u0026#34;$\u0026#34; + t; 17 z_build(st, z); 18 for (int i = lens + 1; st[i]; ++i) 19 if (z[i] == lens) ++ans; 20 return ans; 21} 22int main() { 23 ios::sync_with_stdio(0), cin.tie(0); 24 string s, p; 25 cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p; 26 cout \u0026lt;\u0026lt; z_match(p, s) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 27 return 0; 28} 1680 - Longest Flight Route 找點 1 到點 n 的最長路徑。 拓樸排序＋DP。 1// DP on DAG 2// Topological Sort 3#pragma GCC optimization (\u0026#34;O3\u0026#34;) 4#include\u0026lt;bits/stdc++.h\u0026gt; 5using namespace std; 6typedef long long ll; 7typedef pair\u0026lt;int, int\u0026gt; pii; 8#define pb push_back 9 10int main() { 11 ios::sync_with_stdio(0), cin.tie(0); 12 int n, m; 13 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 14 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G(n + 1); 15 vector\u0026lt;int\u0026gt; par(n + 1); 16 vector\u0026lt;int\u0026gt; deg(n + 1); 17 vector\u0026lt;int\u0026gt; dis(n + 1, -1e9); 18 dis[1] = 0; 19 for (int i = 0; i \u0026lt; m; i++) { 20 int a, b; 21 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 22 G[a].pb(b); 23 deg[b]++; 24 } 25 queue\u0026lt;int\u0026gt; q; 26 for (int i = 1; i \u0026lt;= n; i++) { 27 if (!deg[i]) { 28 q.push(i); 29 } 30 } 31 while (!q.empty()) { 32 int u = q.front(); 33 q.pop(); 34 for (int uu : G[u]) { 35 deg[uu]--; 36 if (!deg[uu]) { 37 q.push(uu); 38 } 39 if (dis[uu] \u0026lt; dis[u] + 1) { 40 dis[uu] = dis[u] + 1; 41 par[uu] = u; 42 } 43 } 44 } 45 if (dis[n] \u0026lt; 0) { 46 cout \u0026lt;\u0026lt; \u0026#34;IMPOSSIBLE\\n\u0026#34;; 47 } else { 48 vector\u0026lt;int\u0026gt; ans; 49 int v = n; 50 while (v) { 51 ans.pb(v); 52 v = par[v]; 53 } 54 cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 55 for (int i = ans.size() - 1; i \u0026gt;= 0; i--) { 56 cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[!i]; 57 } 58 } 59 return 0; 60} 1682 - Flight Routes Check 判斷圖是不是一個 SCC，若不是找一對 (a, b) 使得 a 走不到 b。 Tarjan Algorithm。 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; 9vector\u0026lt;int\u0026gt; visit; 10vector\u0026lt;int\u0026gt; low; 11vector\u0026lt;int\u0026gt; id; 12vector\u0026lt;bool\u0026gt; inStk; 13stack\u0026lt;int\u0026gt; st; 14int t; 15 16void dfs(int u) { 17 visit[u] = low[u] = ++t; 18 st.push(u); 19 inStk[u] = true; 20 for (int uu : G[u]) { 21 if (!visit[uu]) { 22 dfs(uu); 23 } 24 if (inStk[uu]) 25 low[u] = min(low[u], low[uu]); 26 } 27 if (visit[u] == low[u]) { 28 while (1) { 29 int uu = st.top(); 30 st.pop(); 31 inStk[uu] = false; 32 id[uu] = u; 33 if (uu == u) { 34 break; 35 } 36 } 37 } 38} 39 40vector\u0026lt;int\u0026gt; SCC(int n) { 41 inStk.resize(n); 42 visit.resize(n); 43 low.resize(n); 44 id.resize(n, -1); 45 t = 0; 46 for (int i = 0; i \u0026lt; n; i++) { 47 if (!visit[i]) { 48 dfs(i); 49 } 50 } 51 vector\u0026lt;int\u0026gt; ret; 52 for (int i = 0; i \u0026lt; n; i++) { 53 if (id[i] == i) { 54 ret.pb(i); 55 } 56 } 57 return ret; 58} 59 60int main() { 61 ios::sync_with_stdio(0), cin.tie(0); 62 int n, m; 63 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 64 G.resize(n); 65 for (int i = 0; i \u0026lt; m; i++) { 66 int a, b; 67 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 68 a--, b--; 69 G[a].pb(b); 70 } 71 auto ans = SCC(n); 72 if (ans.size() == 1) { 73 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; 74 } else { 75 cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; 76 for (int i = 0; i \u0026lt; n; i++) { 77 for (int j : G[i]) { 78 if (id[i] != id[j]) { 79 cout \u0026lt;\u0026lt; j + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 80 return 0; 81 } 82 } 83 } 84 // all components are SCC 85 cout \u0026lt;\u0026lt; ans[0] + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ans[1] + 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 86 } 87 return 0; 88} 1087 - Shortest Subsequence 給一個字串 S，找一個最短字串 P 使得 P 不是 S 的子字串。 Greedy。 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8int main() { 9 ios::sync_with_stdio(0), cin.tie(0); 10 string s; 11 cin \u0026gt;\u0026gt; s; 12 vector\u0026lt;int\u0026gt; a(s.length()); 13 for (int i = 0; s[i]; i++) { 14 if (s[i] == \u0026#39;A\u0026#39;) a[i] = 1; 15 else if (s[i] == \u0026#39;C\u0026#39;) a[i] = 2; 16 else if (s[i] == \u0026#39;G\u0026#39;) a[i] = 4; 17 else a[i] = 8; 18 } 19 int st = 0; // Bit Set 20 vector\u0026lt;int\u0026gt; ans; 21 for (int i = 0; i \u0026lt; a.size(); i++) { 22 st = st | a[i]; 23 if (st == 15) { 24 st = 0; 25 ans.pb(a[i]); 26 } 27 } 28 for (int i = 1; i \u0026lt;= 8; i \u0026lt;\u0026lt;= 1) { 29 if ((st \u0026amp; i) == 0) { 30 ans.pb(i); 31 break; 32 } 33 } 34 string out = \u0026#34;\u0026#34;; 35 for (int i = 0; i \u0026lt; ans.size(); i++) { 36 if (ans[i] == 1) out += \u0026#34;A\u0026#34;; 37 else if (ans[i] == 2) out += \u0026#34;C\u0026#34;; 38 else if (ans[i] == 4) out += \u0026#34;G\u0026#34;; 39 else out += \u0026#34;T\u0026#34;; 40 } 41 cout \u0026lt;\u0026lt; out \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 42 return 0; 43} 1756 - Acyclic Graph Edges 給一個無向圖，求輸出一個 Acyclic Orientation 的構造。 Greedy 另小的點指向大的點，則必無環。 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 int n, m; 7 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 8 for (int i = 0; i \u0026lt; m; i++) { 9 int a, b; 10 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 11 if (a \u0026gt; b) swap(a, b); 12 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 } 14 return 0; 15} 1688 - Company Queries II LCA 模板題。 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#pragma GCC optimization (\u0026#34;O3\u0026#34;) 4#include\u0026lt;bits/stdc++.h\u0026gt; 5using namespace std; 6typedef long long ll; 7typedef pair\u0026lt;int, int\u0026gt; pii; 8#define pb push_back 9 10class SparseTableTarjan { 11 private: 12 int maxlg; 13 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; anc; 14 vector\u0026lt;int\u0026gt; dep; 15 void dfs(int u, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edge, int d) { 16 dep[u] = d; 17 for (int i = 1; i \u0026lt; maxlg; i++) 18 if (anc[u][i - 1] == -1) break; 19 else anc[u][i] = anc[anc[u][i - 1]][i - 1]; 20 for (int a : edge[u]) { 21 if (dep[a] != -1) continue; 22 anc[a][0] = u; 23 dfs(a, edge, d + 1); 24 } 25 } 26 public: 27 SparseTableTarjan(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edge, int root) { 28 int n = edge.size(); 29 maxlg = ceil(log2(n)); 30 anc.assign(n, vector\u0026lt;int\u0026gt;(maxlg, -1)); 31 dep.assign(n, -1); 32 dfs(root, edge, 0); 33 } 34 int lca(int a, int b) { 35 if (dep[a] \u0026gt; dep[b]) swap(a, b); 36 for (int k = 0; dep[b] - dep[a]; k++) 37 if (((dep[b] - dep[a]) \u0026gt;\u0026gt; k) \u0026amp; 1) b = anc[b][k]; 38 if (a == b) return a; 39 for (int k = maxlg - 1; k \u0026gt;= 0; k--) 40 if (anc[a][k] != anc[b][k]) 41 a = anc[a][k], b = anc[b][k]; 42 return anc[a][0]; 43 } 44 int dist(int a, int b) { 45 return dep[a] + dep[b] - 2 * dep[lca(a, b)]; 46 } 47}; 48 49int main() { 50 ios::sync_with_stdio(0), cin.tie(0); 51 int n, q; 52 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 53 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G(n); 54 for (int i = 1; i \u0026lt; n; i++) { 55 int p; 56 cin \u0026gt;\u0026gt; p; 57 p--; 58 G[i].pb(p); 59 G[p].pb(i); 60 } 61 SparseTableTarjan ST(G, 0); 62 while (q--) { 63 int a, b; 64 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 65 cout \u0026lt;\u0026lt; ST.lca(a - 1, b - 1) + 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 66 } 67 return 0; 68} Josephus Problem I 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8int main() { 9 ios::sync_with_stdio(0), cin.tie(0); 10 int n; 11 cin \u0026gt;\u0026gt; n; 12 if (n == 1) { 13 cout \u0026lt;\u0026lt; \u0026#34;1\\n\u0026#34;; 14 return 0; 15 } 16 vector\u0026lt;bool\u0026gt; die(n); 17 cout \u0026lt;\u0026lt; 2; 18 for (int i = 1, p = 0; i \u0026lt; n; i++) { 19 die[p] = true; 20 while(die[p]) { 21 p = (p + 1) % n; 22 } 23 p = (p + 1) % n; 24 while(die[p]) { 25 p = (p + 1) % n; 26 } 27 cout \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; (p + 1) % n + 1; 28 } 29 cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 30 return 0; 31} ","date":"2022-06-16T09:29:58+08:00","permalink":"https://luke2336.github.io/p/cses/","title":"CSES"},{"content":"目錄 這邊的分類不代表開課系所，只是用課的性質去歸納。\n物理 物理（一）、（二） 物理實驗（一）、（二） 數學 微積分甲（一）、（二） 離散數學 線性代數 微分方程 訊號與系統 機率 資工 程式 計算機概論與程式設計 物件導向與資料結構 基礎程式設計（GPE） 硬體、底層 數位電路設計 數位電路實驗 計算機組織 作業系統概論 編譯器設計 計算理論 基礎圖論 演算法概論 [清大] 隨機演算法 高等演算法 正規語言概論 隨機演算法 賽局理論及應用 其他 競技程式設計（一）、(二)、（三） 人工智慧概論 資料庫系統概論 計算方法之實務應用 數值軟體開發 資訊工程研討 電機、電子 電子學（一） 電子實驗（一） 電路學 電子設計自動化演算法與實作 通識 校基本 疾病知識與防治 幾何造型 統計方法與資料分析 認識語言 跨院 統計學 核心 政治學 教育學概論 [台大] 東亞儒家：人文精神 外文 大一英文（一） 德文（一） 德文（二） 進階英文寫作 筆記 Github\n修課順序建議 微積分 → 微分方程、訊號與系統 → 電路學、電子學 → 電子實驗\n微積分 → 機率 → 統計學\n數位電路設計 → 數位電路實驗 → 計算機組織 → 作業系統\n離散數學、資料結構、機率 → 演算法 → GPE\n正規語言 → 編譯器\n物理 物理（一）、（二）榮譽班（英文班） 授課老師：電物系 籔下篤史 評分方式：功課 20%、期中 4 x 20% 授課方式： 每次教一個章節，平均一節半就下課放人。上課就投影片唸過，一點點公式推導而已，老師很日本腔，所以大多數人還是選擇自己念。 考試基本上是填充加計算，填充是有點配合題加背公式，百分之九十九考古，計算題半考古半作業吧，反正考古背熟就拿 A 了。 我對這門課真的沒有任何興趣，加上星期五兩節課後來都被我拿去準備專題的meeting，所以上課不是打瞌睡，就是隨便聽聽。大家分數都不錯，所以完全沒調分。很後悔沒有認真背考古題，最後分數淒慘，卻賭一把期末沒退選。下學期決定翹課看簡紋斌的 OCW 就好，加上把考古背好。 結果下學期全部翹課，只去考試。一樣很考古，但計算的比例似乎比上學期重了一些。我真的對物理沒啥興趣，就很乾脆的拿了個 B。 物理實驗（一）、（二） 完全看助教開心來給預報和結報的分數，考驗妳的 Excel 能力，來決定你哪時候下課。我覺得一學分真的投資報酬率低，但因為他會公開每次報告的分數，讓人不由自主花很多時間只為了多拿五分，所以我最後調到 A+。 下學期以光學和電學實驗為主，所以報告相對上學期的力學變得難寫。完全看助教開心來給預報和結報的分數。我期末忘記帶計算機，就爛掉了。 要注意「有效位數」！ 數學 微積分甲（一）、（二）（英文班） 授課老師：應數系 符麥克 評分方式：功課 10%、期中 25%、期末 25%、大會考 30% 授課方式： 每週四 inclass homework 開書考 10 分鐘 2 題，每週 homework 課本習題 2 題、老師自己出的 4 題。 老師是奧地利人，英文帶了點德國腔，剛開始聽會超不習慣，加上他的字小且帶個人風格，上課速度很快，所以剛開始會跟不上。個人是認真的把板書抄下來，但這麼做基本上你就很難認真聽懂他在講什麼，所以抄筆記和聽課可能得取捨一下吧！最好還是課前預習一下。 他的期中是偏證明大約 7 題，期末 6 題，計算要快、觀念要熟，和偏計算的大會考真的方向不同。老師會按規定調到平均 79 左右，今年是調 3 分。 下學期計算量較多，不像上學期那麼多證明，期中考比大會考多了osculating plane的部分。大會考爆難，我算了五年的考古，還只拿70，總成績調分滿多的。感覺班上來上課的人比上學期又更少了。 離散數學 授課老師：資工系 楊武 評分方式：功課 15%、期中 40%、期末 40%、平時表現 5% 授課內容：簡單的數論（質數講很久）、集合、數學歸納法、遞迴、排組、鴿籠、Relation。 授課方式： 老師教得很隨性，上課只是抄一抄板書。 偶而會有小考十分鐘兩題，會先提醒，千萬別遲到。小考蠻過分的，不是滿分 10 分就是鴨蛋 0 分。 期中期末，三成考古，和上課內容不會差太遠，滿分超過一百，平均落在 60 左右，最高 99，基本上就是高於全班平均就能拿 A，期末調分超過 15 分。 老師偶而會一直重複上節課講過的東西，記得點醒他，不然他一直講同一型的題目進度很慢。然後他的麥克風雜音超吵，勇者請把它關小聲。個人覺得他還算是個好玩的老師，不過證明有時不太嚴謹，是小小的缺點。 線性代數（英文班） 授課老師：電控 林源倍 評分方式：平時 15%、小考 2 x 10%、期中 30%、期末 35% 上課方式：翻轉教學，回家看 OCW，上課時發作業，大約四大題，四人一組，抽籤上去用英文講解，可以找其他人的 bug 加分。是一門需要有組員 Carry 的課。助教和老師人都很好。 成績：考試大約都是七成基礎定義和計算，三成偏證明，確認是否有把線代融會貫通。認真讀書拿九十分以上不難，雖然我都粗心掉基本分（例如問 row space 我看成 col. space… ），最後就沒有拿到 A+。會調分就是了，而且線代通常對於有些人滿抽象的，所以拿高分的人並不會太多。 啟發：這門課給我的收穫算是還滿大的。首先，我們這個班主要是電資班和電機系的學生，所以算是能和系上同學多多互動，也能認識外系的機會。再來也是養成自己規劃讀書進度的習慣，看影片的速度也能慢慢修正。最後，很重要一點是，能增進用英文上台發表看法的能力，同時也會在過程中不斷練習去找同學解法的 bug。是一門規劃得很不錯的反轉教學，讓我回憶起以前去台大上資芽的過程。 微分方程（英文班） 授課老師：電機 李冕 評分方式： 12 次小考取 10 次平均 期中期末小組報告 授課方式： 不會點名。老師是義大利人，口音不算太難懂。講投影片為主，老師上課會一直點人上台做題。每週小考，一週手寫，一週 Matlab，題目都是從課本出為主，但我覺得題目選得很爛。助教雷雷的，是印度人，我們不太知道怎麼跟她溝通。 期中期末各一個專題，是 3 人小組報告，選一個數學或物理現象用微方解釋。報告會要求解釋物理和數學原理，以及用 Matlab 模擬，還有動手實作的影片，還有放幾個小笑話。期末因為我看到了「Harmonograph」這個主題很有趣，然後剛好懶得找組員，就自己做了，老師給了 100 分，不小心就對到他的胃口了。 訊號與系統（英文班） 授課老師：資工 黃敬群 評分方式： 作業 6 次 40% 期中期末各 30% 一次加分考 5% 授課內容： LTI System Convolution Fourier Series Fourier Transform Sampling 授課方式： 很早就變成非同步線上授課了，主要是用書商的投影片上課，然後在旁邊手寫補充。 上了不少例題，上課速度偏慢，所以 Laplace 和 Z Transofrm 都沒有上到。 後來覺得自己應該去 YouTube 看陳永平的 OCW 比較有效率。 作業和考試： 作業是每個單元勾課本習題 5~10 題，我自己花了很多時間寫，常常要算 5~15 個小時。原本有說要出 Matlab 作業，但大概就只有一題而已… 考試和作業題目類型有點像，大約 5 題，但還是會有比較不一樣的題目，基本上時間很充裕，不用擔心寫不完，助教給分還算寬鬆。 總分只有調了一分，但作業分數都給很高，所以覺得會比其他班輕鬆。 附註：這是老師第一年在交大開課，因為是英授，所以不到十個人選課，之後也不會再開這門課了。老師人很好，但是我覺得教學上仍有待改進。 機率（英文班） 授課老師：電機 高榮鴻 評分方式：作業 6 次共 20%、期中期末各 40%、加分程式作業一次 授課內容： 高中範圍內容（快速帶過） Independence、Expectation、Variance、Covariance Total Probability Theorem、Bayes’ Rule、Union Bound Discrete/Continuous Random Variable、Transform（Fourier、Laplace、Linear） Markov Inequality、Chebyshev Inequality Weak Law of Large Numbers、Convergence in Probability、Central Limit Theorem Discrete-Time Markov Chain Some Matlab Simulation 授課方式： 純版書，證明定理，然後帶幾題課本例題。 個人覺得期中考前的某些東西教得有點慢，可能是因為很多時間在寫板書。 老師習慣先寫完整個黑板，然後再開始講，但通常抄完黑板後，就大概了解他要講的東西了… 作業和考試： 作業是勾課本上的，通常不到 5 題，難度中等，網路上也可以找到解答。 考試難度也不高，滿分 110，基本上看一份考古，然後稍微看一下上課和作業的題目，考到 90 很簡單。期中考班平均 72，標準差 25，但還是有約三成的人不及格。期末考班平均 77，標準差 24。良心建議考完多檢查，計算過程要寫多一點點，分數會比較好看。 附註：不知道是因為疫情，老師沒有給加簽的名額。個人對這門課沒有太多的感覺，只覺得要拿學生證簽名點名很煩，然後神奇的是考試時反而沒檢查學生證。總成績感覺是沒有調分，也完全不知道點名到底有沒有分數。 資工 - 程式 計算機概論與程式設計（英文授課） 授課老師：資工系 張永儒 Stanley 評分方式： Lab、HW 各佔 20%，有 demo 就滿分。 期中筆試上機各 12.5%。 期末專題，書面計畫和最終書面報告各佔 8.75%，demo 佔17.5%。 授課方式： 上課都用投影片，偶爾會開 IDE 打幾行程式，但 bug 一堆。前 8 週上 C，但作業我還是偷用 C++寫，進度跳很快，我原本就會寫了所以沒認真聽，其他人大部分就 Lab 時間找大神救，投影片內容很豐富。 考試方式： 期中分為選擇和上機，選擇我們這些原本就會寫程式的人大概可以拿 90～100，滿分大約 110，可以 openbook，所以不少人印前一年的考古題，拿滿分，換句話說，完全考古嘔死你。 上機四題選三題，我是拿 95，賽後人工評測，寫不出來寫註解也有分，但那天好死不死，想提早交時當機，只好換一台重打一次，快被系計中的冷氣凍死，難度大概不當機一小時打完收工。 期末專題： 後面幾週教 python，有教到爬網站、BeautifulSoup、正規表達式等東西。 期末專題就是要用「一個爬網站 + 兩個 API」，湊出一個實用的東西。我是用 openCV，但它不用傳 key 之類的東西，導致我分數沒有預期的高，這點可以注意一下，原本有打算加臉書的 API，但它的權限真的很難搞，反正有創意、難度高、實用性都兼顧到應該分數可以到 95 以上。 物件導向與資料結構（英文班） 授課老師：資工 黃世強 評分方式： 不調分，真的有不少人被當。 Lab 10%： 基本上會前一天就放上 e3，所以大多數人都滿分 程式作業 10% x 3： 給一些老師寫好的 project 挖空，需把一些重點函式填上，主要是用 OpenGL 的方式呈現，但這部分不需要理解。 我自己寫起來大致上每次需要花 10~20 小時，通常會給一個月左右的時間完成。 期中上機 15% x 2： 可帶紙本資料，第一次需要熟悉基本的 OOP 語法，第二次需要會寫一些基礎的資料結構（BST之類的）。 第一次爆簡單，結果第二次就很難，據說第二次平均低於 40。 期末筆試 20%： 我這學期成績爆掉的主因，上機和作業都有拿到 90 以上，但忘記筆試佔很重，只考了 60 幾 QQ 除了基礎的 OOP 和資料結構外，上課有教到的檔案處理和除錯用的語法也要背。 期末上機 10%： 從三次作業去改，可從 e3 上下載作業去改，拿 100 不難。 感想： 老師是香港人，所以英文有點口音。 上課進度我有點不喜歡，前三週都在複習計概教過的東西（迴圈、陣列、指標），然後資料結構的部分，紅黑樹也只講到定義而已，前面一些基礎的資料結構都重複上好幾次，但每次都講得亂亂的，我覺得自己在上課學會的東西極少。 功課的部分算是培養我們寫大型專案的能力吧，但有些註解及說明資料寫得不夠具體，變數的名字好像讓我誤解了不少，讓我實作上花了很多時間。 附註： 上機考的部分公平性極低，出場後補交可拿到 60 分。而且抄襲應該也沒有抓得很認真。 成績往往都是好幾週後公布，有可能超過退選截止日期。 沒有筆電或沒灌 windows 建議不要修，因為功課需要用 vs，不然就得像我一樣窩在計中一整天。然後 vs 老師不知道為什麼不採用 2007 版，造成大家寫功課時花了很多時間把環境搞定。第一次作業時，我因為計中電腦無法用 vs2007 開作業的檔案花了很久嘗試，計中助教也花了幾天才把問題解決。 基礎程式設計 不用上課，只要去考 GPE。 一個學期可以考很多場，但每場有人數限制。總共 6 題，3 小時。 這門課沒有過的話，會擋修專題和一些實作類課程，所以早點考一考比較好。 有提供官方題庫，內容以 UVA 題目為主，但是測資品質普遍沒有 UVA 好。建議考前先熟悉系統，能用的語言就只有 C/C++、JAVA，沒有 Python。 難度每次有些落差。雖然只要通過 2.4 題（大概就是有一定的實作能力，拿完部分分就有的分數，不用會太多演算法或資料結構），但聽老師們建議為了讓成績單上成績好看，不要影響到升學、就業等等，就算 0 學分不列入 GPA，還是要考高一點。 資工 - 硬體、底層 數位電路設計 授課老師：資工系 范倫達 評分方式：小考20%、期中兩次25%、期末30% 授課內容：內容是課本 1～7 章，算是不需要什麼基礎知識，從邏輯二進位教到 latch、flip-flop、counter，會帶一些 verilog，但不需要上機，只要看得懂就好了。 授課方式：上課都是用投影片，上課速度時快時慢。小考和期中期末以課本題為主，有練拿 A+ 很簡單，小考是前一週的範圍。老師人很好，很愛關心學生。 數位電路實驗（英文班） 授課老師：資工 范倫達 評分方式： Lab 10 次取 8 次 40% 期中上機 20%、期末上機 20% 期末小組專題 20% 授課方式： 不會點名。作業每週一晚上 demo，10 天前公佈。基本上上課內容以硬體架構為主，講了一些 FPGA 的東西，還有合成的過程，會有幾堂請業界的人講課，但我真心覺得聽課很無趣，且對作業幫助不大。 打分數全由 TA 負責，TA 主要是前一年的修課學生。 期中上機剛好是我高二用 Arduino 寫過的東西，所以就拿了 100 分。期末則出 UART，剛好那次Lab碰上日本比賽，所以沒寫，之後沒補，只帶了同學的模板，電腦剛好選到一台無敵爛的，就考 0 分。總之，上機跟選電腦的運氣成分有很大關聯。 FPGA 不能帶出實驗室，環境 Vivado 不支援 mac，所以每次都得去實驗室做，後來幾次幾乎都寫超過 10 小時，很崩潰。 專題最後我組員退選退光，於是我就一個人做，大概弄了 25~30 小時。期末成績因為調分有拿到A+。 板子是用 Arty，有遇過有錢的同學自己買一個玩，就不用假日窩在實驗室合成了。畢竟到後面有時候燒一次就要 20 分鐘，這時候建議多霸佔幾台電腦，這樣就可以同時跑很多版本的 code 了（應該沒有人像我一樣這樣節省時間的吧）。 課程內容： Lab1 乘法器 Lab2 ALU Lab3 矩陣乘法 Lab4 Button \u0026amp; LED Lab5 LCD Lab6 UART Lab7 矩陣乘法(用 SRM，空間優化) Lab8 SD card Lab9 暴力解MD5（用 Pipeline，時間優化） Lab10 VGA 顯示 期末專題 VGA 小遊戲 2 選 1（貪吃蛇、皮卡丘打排球） 計算機組織 授課老師：資工 蔡文錦 評分方式： 我討厭 Verilog 所以選了 B Plan A 考試 20% * 3 小考 20% Verilog HW 20% Plan B 考試 25% * 3 小考 25% 課程範圍 Ch 1: Computer Abstractions and Technology Ch 2: Instructions: Language of the Computer Ch 4: The processor Ch 3: Arithmetic for Computers Ch 5: Memory Hierarchy Ch 6: Multiprocessor 覺得教得很清楚，讓我沒那麼討厭計組了。重點主要放在第四章。第五、六章和 OS 重疊率很高。 作業系統概論 授課老師：資工 吳育松 評分方式： 大考 2 x 30% 作業 4 x 10% HW1 Multitasking: Python HW2 Memory: C, Linux HW3 File System: Linux cmd HW4 Meltdown: Linux cmd 授課方式 用投影片上課，但投影片很多有的沒的東西，不容易抓到重點。 覺得很催眠的一堂課，只好自學。 作業覺得沒學到太多東西。 期中期末平均都 60 幾，學期分數調了 7 分左右。 編譯器設計 授課老師：資工 游逸平 評分方式： 大考 2 x 25% 作業 5 x 10% Scanner (lex) Parser (yacc) Abstract Syntax Tree Sematic Analysis RISC-V 授課內容 Lexical Analysis, CFG, Parsing, Lex \u0026amp; Yacc, SDD \u0026amp; SDT, IR, Runtime Environment 授課方式 因為疫情，從學期初就線上授課到期末，有錄影可以看。因為是英授，所以上得比較慢，後面很多東西就沒上到，像是 Code Generation \u0026amp; Optimization。 課程資料和作業都是透過 Github，作業都會提供完整的測資，所以交功課時就可以知道自己的分數。作業還會要求寫報告，主要內容是介紹你怎麼寫這份作業，以及你認為作業可以改進的地方，大概佔 5% 左右。 期中考是現場考，期末考則是 Take-Home Exam，老師會提供考古題。 作業平均需要花 8~10 小時，前面兩次作業很簡單，後面就比較需要熟悉 C++。 總而言之，是門值得一修的好課。 資工 - 計算理論 基礎圖論 授課老師：應數系 傅恆霖 評分方式：期中40%、期末60%，滿分約115左右，不調分。 授課方式：老師人超好，因為開在早八，所以會晚十分鐘開始上課（我下堂還有課，結果就因為晚下課搶不到位子），有時會在開始上課前給早到的講點小故事。內容還算滿豐富的，上課全是板書，老師的字大小適中且整齊，上課速度也不會太快，老師手寫筆記和考古題也會公開到網路上。 授課內容：主要是簡單圖為主，從圖的定義，到一些基本性質，還有介紹一些經典問題，尤拉路徑、中國郵差問題、七橋問題之類的，最小生成樹、最短路徑的演算法也有提一下下，最大流最小割，四色定理等等。 會選這門課，主要是因為系上開的離散數學完全跳過圖論這塊，加上以前聽過很多上述的經典問題，卻都不太清楚證明，想說不需要什麼基礎就修修看。 考試內容：以上課範圍為主，證明和定義要記清楚，還有一些簡單的構造題，平常上課聽之外，還需要考試前念一點書。老師偶爾會出作業，寫出證明的話，直接總成績加一分，不過我都在忙東忙西，就都沒有寫了。 演算法概論（英文班） 授課老師：資工 蔡孟宗 評分方式：max ( (2 max(A + B) + min(A, B) + C + D) / 5, 99) A. 3 次手寫作業 + 2 次小考 B. 3 次程式作業(5題) + 2 次上機 C. 期中筆試 D. 期末筆試 不會點名，某程度上不會被當的課，大神很容易刷分的課，修到 A+ 不難，拿 99 也不無可能，因為每次作業考試都滿分 125。 程式作業和考試題目質感高，手寫作業和筆試難度略高，但基本分很好拿。上課是投影片，老師自己做的，所以品質很好。會先英文授課 7 成的時間，然後再用中文講一次。 該上的內容都有上，還會自己加一些好玩的題材，像是隨機演算法、近似演算法，還有 Treap、Quake heap 這種比傳統的紅黑樹和費波那契堆好實作且好懂的平衡樹。 隨機演算法（英文班） 授課老師：清華 韓永楷 評分方式：5作業（最低 2.5%，其他 37.5%）、3考試60% 授課內容： Basic Probability, Discrete Random Variable Verify Matrix Multiplication Random Min-Cut Random Median Poisson Trial Markov Inequality, Chebyshev Inequality, Chernoff Bounds Balls and Bins Probability Methods Markov Chain 課程資料 授課方式： 板書。老師是香港人，但口音聽久就習慣了。 老師人很好，會問大家問題，答錯沒關係。上課氣氛非常愉快，然後不需要太多基礎，可能會一點離散數學就夠了。 這門課大概讓我喜歡上了機率，然後機率變得滿熟悉的 XD 附註：加簽沒上限？ 高等演算法 授課老師：資科碩 蔡孟宗 評分方式：小考 5 x 20% 授課內容：Graph Orientation, Color Coding, Connectivity, Spanner, Decomposition, Cuckoo Hash, Monge Matrix, Matroid, Submodularity, Epsilon Net, Derandomization, Distributed Algorithm, Streaming Algorithm, Dynamic Algorithm, …… 連續上兩個多小時有點累以外，其實滿喜歡這門課的。每個星期都花不少時間複習，但考試就是難到 Open Internet 還是寫不出來。不知不覺就在一學期學了很多東西，算是看到更廣闊的世界……？用到不少機率，所以現在看到再多機率都不怕了 www 正規語言概論 授課老師：資工 曾文貴 評分方式：5 作業 25%、考試 3 x 25% 授課內容：Finite State Machine, Regular Language, Pushdown Automata, Context-free Language, Turing Machine, Hierarchy of Formal Language and Automata, Limits of Computation 作業和考試多來自課本習題，考試平均大約都五六十分。可能是因為用平板上課，上課會很仔細得寫範例題，上的內容有些少，沒有上到 Reduction 的部分，有些失望。 隨機演算法 授課老師：資工 蔡錫鈞 評分方式：作業 x 6、期中（一張小抄）、期末（take home） 授課內容：幾乎整本第二版的 Probability and Computing、一部分 The Probabilistic Method 上課會有投影片，會補充一些書上沒有的內容，回家複習時最好跟書搭配看。強烈建議一定要去上課，不然自己讀會很難抓到精髓。作業多是勾課本習題，每次大約十天五題，但通常網路上找不到答案，應該多和同學討論。期中考的範圍到機率方法，平均落在五十幾分，但其實老師改的算是滿鬆的，題型其實也和作業滿相似的。 賽局理論及應用（英文） 授課老師：資工 嚴力行 評分方式：程式作業 x 2、小考 x 4、期中 30%、期末 30% 授課內容：沒有用教科書。 Non-cooperative game Coordination game, Potential game and Congestion game Network Problem Graph Problem Coaliction Auction Matching 上課的投影片量很大，建議去聽課，不然抓不到重點。整學期的課都有錄影放到雲端，所以去上課的人大概不到七成。這門課第一次開英文授課，老師的語速算慢，所以英文不好還是能聽得很懂，而且老師還滿會教課的。小考完都會現場檢討，雖然老師常常答案被打臉，但還是覺得能把不熟的部分補起來。期中期末其實不難，跟小考很相近，但有些名詞的定義還是要搞清楚才能回答問題。程式作業主要是 Graph 那個單元，都不用 100 行就能搞定，只需要交報告，用 C++ 或 Python 都行，算是研究所課中相對涼的一門課。 資工 - 其他選修 競技程式設計（一）、(二)、（三） 授課老師：謝旻錚 算是競賽用演算法課吧，因為這年有勾題目，所以大家期中期末都比往年高。這學期放了很多假，因此課程的內容比預期少了不少。 很開心在競程一找到 ICPC 的隊友。 競程二是要在任一場比賽打敗清大第四名或台大第六名的隊伍才能 PASS。競程三就只要賽季時一週練 10 小時就解決了。 人工智慧概論 授課老師：資工 王才沛 評分方式： 原本 程式 50%（個人3次小組1次） 大考＋小考＋手寫作業 50% 實際 手寫作業 2% x 3 小考 2% x 2 段考 23% x 2 個人程式作業報告 13% x 2 小組程式作業報告 10% ＋對戰排名 8％ 點名額外加分 1% x 2 授課方式：平常上課以投影片為主。主要是以概論的方式來上。 介紹 AI 的大致種類。 State Space Search：有教基本的 DFS、BFS、A*、IDA* 等。 Constraint Satisfaction Problem：教 AC3、MRV、LCV、Degree heuristic、Forward checking 等。 Adversarial Search：以 0-sum 遊戲為主介紹，教 Min-max pruning、MCTS 等經典算法。 介紹 Learning 的種類：介紹 Learning 相關的概念（Bias-Variance Dilemma、Cross validation等）。 Supervised Learning：教 Decision Tree、CART 的具體實現，神經網路相關的概念、SVM。 Unsupervised Learning，k-means、SOM、VQ 等算法簡介。 Reinforcement Learning：Q-Learning 為主、TD。 Logic：Propositional Logic、First-Order Logic 這兩種，結合了一些Searching 類的演算法。 其他： 手寫作業和小考段考題型都是一樣，投影片讀熟應該考個 90 是沒問題的，但我期中題目沒看仔細，分數跌了不少。 個人程式作業以報告評分，大致描述實踐分法、實驗結果就行了，以 C++、python、java、matlab 都行，小組作業就限 C++ 和 python。 第一次程式作業是給幾個圖及 3000 個單字，用 AC3、Forward checking 等算法，選幾種去寫，去完成填字遊戲。我自己大約寫了 350 行的 C++，把有教的東西都實踐出來，Forward checking、AC3、Degree hueristic、MRV 都有做效果還不錯。 第二次程式作業是實作 Random Forest，可以直接用網路上別人寫好的 code 去改，但我還是選擇自己寫一個出來，也是用 C++寫了 350 行左右，花了很多時間，但一開始對於attritbute bagging的部分理解錯了，到最後一天才在重寫，資料就沒有跑很多，但報告不知道為什麼還拿滿高分的。 整體來說很吃寫實驗報告能力，但因為有修過物理實驗，所以這部分就還算能抓個方向，加上一些專題 meeting 時訓練出的做圖表能力，所以報告都拿 90+，助教給分的 Range 從 50~98 都有，這部分電資班的成績普遍比資工系的高，顯然物理實驗和專題對寫報告的能力增進不少。看了一下同系學長姐的成績，似乎程式不怎麼樣，但報告卻拿很高就是了，所以修這門課好像寫報告能力重於程式能力。 小組作業是 1~3 人一組，針對 Game 那個單元出一個對戰作業，給定一個黑白跳棋的規則（四方棋盤，可以跳或是直接走一步，跳過對方棋子可以吃掉，看遊戲結束時到對面的棋子數量決定勝負）。總共 51 組，我們拿第 7 名，我們是大概以兩步的結果去評估，加上一些 hueristic 的調整。其他朋友則是真的去做 min-max 和 MCTS 之類的實踐，普遍成績都不錯，我在 PCCA 的隊友，也是同門課中和我唯二的大一生，好像用這個方法拿到第一名。 資料庫系統概論 授課老師：資工系 彭文志 評分方式：由於疫情，調整成只有作業和期末專題，在討論區發言或回答同學問題能加分。 授課方式：修課人數很多，開學就用 Microsoft Teams 遠端，沒上過實體課，原本是一週三堂課，但因為改成線上就只有兩堂。講投影片，投影片的份量有點重，可能因為是線上的，所以覺得老師講起來沒什麼吸引力。加上有時候還沒敲鐘就開始上，前面常常沒聽到，後面就跟不上。 作業：我退掉這門課的原因。HW1 我就決定退選了，因為助教給了一份 LOL 的遊戲紀錄，然後搞不懂規則，加上第一次學 mySQL 的狀態下，實在不想在期中考月花時間寫作業，寫了 8 小時左右就放棄了。聽說總共出了四份作業，然後期末專題是三人一組，寫一個應用程式或網頁之類的（類似口罩地圖之類的），主題自訂。據說總共有 4 次 HW，第二次是 B+ Tree，後面我就不清楚了。 原本期末專題找隊友兩人一組，他還很認真的陪我寫作業。但因為那陣子忙著算係好與系統，還有讀專題的東西，於是最後就早早停修了，至少不會拖累他。總之，這是一門每年都上靠北交大的課，請慎選，個人覺得今年似乎比往年少一點點雷了。 計算方法之實務應用 授課老師：資科工碩 吳凱強 評分方式：作業 4、期中專題 (3 milestone)、期末專題 HW1: 10%, HW2: 10%, HW3: 10%, HW4: 10%, Milestone1: 15%, max(Milestone2, Milestone3): 20%, Fin: 15%, Other: 10%: (1/50) * min(Milestone2, Milestone3) * [(HW1 \u0026gt; 0 ) ? 1 : 0 + (HW2 \u0026gt; 0 ) ? 1 : 0 + (HW3 \u0026gt; 0 ) ? 1 : 0 + (HW4 \u0026gt; 0 ) ? 1 : 0 + (Milestone1 \u0026gt; 0 ) ? 1 : 0] HW1. 用 minisat 解數獨 HW2. 用 BDD 算數獨解的數量 HW3. Viterbi Algorithm HW4. 給 BDD，求 satisfied 的機率 Minterm: SAT solver Final: Metaheuristic 這門課主要偏實作，期中作業號稱要 1500 行 c++。時間大多給兩到三週，期中專題可能會做得很趕。理論的部分基礎不需要太多，因為講得很仔細。我覺得我不喜歡老師上課一直講有的沒的冷笑話，讓上課步調偏慢。評分方式都說得不仔細，成績出來，跟助教反應也沒用。 課程內容：比課綱少不少，通常上不到 3 小時就下課了。 SAT solver \u0026amp; application Binary Decision Diagram Hidden Markov Model \u0026amp; Viterbi Algorithm Google\u0026rsquo;s PageRank Pipeline \u0026amp; Retiming Introduction to NLP Metaheuristic 數值軟體開發（英文） 授課老師：陳永昱 評分方式：作業 6 x 5%、期中考 30 %、Proposal 8%、Presentation 32% 授課內容：課程網站 歷年作業都可在老師的 Github 上看到，所以作業量在修課前就可以評估。老師會分享一些業界的事，很喜歡和學生互動。主要會學到的東西是 Script、Makefile、Pybind11 和 Smart Pointer 等 C++ 的細節。Project 會規定用 Python 及 C++，Proposal 基本上很簡單拿滿分，主題建議選一些運算上可以做優化的，期末報告會比較有東西講（要講 18 分鐘）。期中考則是像在考計概，可能要複習一些 float 的表示法之類的東西。作業則是都用 Github 交，一週需要花五個小時左右，有些環境參數的配置會搞很久。整體來說算是很好及格的一門課，也可以學到很多東西。 資訊工程研討 授課老師：資工 莊榮宏 評分方式：最多缺席兩次，每週書面報告 150 字。 整學期都是用 Microsoft Meet 上課。會請一些業界的人來演講，大部分都在講創業的事。也會請一些中研院的人或是新進教授，通常這部分比較有內容。 電機 電子學（一） 授課老師：電工 陳龍英（逝） 評分方式：3次大考100%、作業一次1%、點名加分 雖然老師是電子學名師，但真的老到講話有氣無力，上課常常東跳西跳，品質據說比以前低。我對這門課真的沒興趣，加上很早就發現跟老師對不到拍，於是很果斷的開始翹課 。 第一次期中剛好在 NCPC 完，比完賽隔天病懨懨沒空讀書，於是只讀了第一章就上場考試，然後就低於 40 分。最後去日本比賽完，發現沒空準備第二次期中，就果斷退選了。 電子學（一）（英文班） 授課老師：電子 吳介琮 評分方式：六次考試 課程網站 需要自己先預習課本作者 Razavi 的影片，和其他班用的 Smith 課本不一樣。 老師教的很好，考古題也都有給，但課本實在太少人用了，連解答都找不到，所以也不好準備。三週考一次試實在來不及準備。 電子實驗（一） 授課助教：電工 陳建安 評分方式： 小考 8% 結報 24% 專題 26% 實驗 26% 期末考 20% 課程網頁 授課內容：基本儀器操作（示波器、電源供應器、訊號產生器、三用電錶）、基本元件（電阻、電容、電感、二極體）、LTspice。 授課方式： 無故缺席兩次會被當，請假要補做。每週上課要先小考，要先看影片預習。小考結束助教會講解實驗內容，要在10點半前做完，大多數人為了早點離開，會直接開始做，不聽助教說明。 專題就是有焊接的部分，分別是直流供電器、音源播放器，但美觀完全不影響分數。期末考實驗內容和電子電路學知識大概一半一半，所以我拿41分（平均48）。 結報雖然我什麼都不會，但寫認真點，也能拿到70分（平均66）。小考平均也70左右，所以就算不會電子電路學，認真預習，不要翹實驗，照著規則，基本上很難被當，雖然有可能是電工系有些人太混。 實驗做不完想繼續完成，或是有事請假，可以跟助教約平日下午補做。 電路學（英文班） 授課老師：生醫 蔡德明 評分方式： 小考 15% 作業 10% 大考 25% x 3 期末專題加分 課本：Fundamentals of Electric Circuits, 7th 作業是從最新版的課本出，但可以跟助教借課本拍照。 Exam 1: 1, 2, 3, 4, 5, 6 Exam 2: 7, 8, 9, 10 Exam 3: 11, 13, 14, 15, 16 授課內容： KCL, KVL, Nodal Analysis, Mesh Analysis Theorem: Norton, Thevenin, Superposition, Source Transformaion op-amp, Capacitor, Inductor First/Second-Order Circuit Phasor Magnetically Coupled Circuits Frequency Response, Bode Plot Laplace Transform 授課方式： 每個章節會出一次作業，作業會公布詳解。 交作業時會小考，小考只有一題，通常不難，考完會馬上講解。 講解的很清楚，覺得可以只要會一點微積分就可以了，但有學過線性代數、微分方程、訊號與系統，應該會比較有概念。 整個學期大致上是從 t-domain, w-domain, s-domain 去認識電路。 上課時會講很多範例，老師強調應該要先把觀念搞懂再寫作業，作業是用來檢驗自己是否有熟習觀念，不應該一邊寫一邊翻課本。 老師英文語速不快，私下聊天時可以跟他用中文，很鼓勵學生跟他聊職涯相關問題。 每次大考都有提供補考，但最高只能 60 分。 週二晚上會有一個小時的助教課，助教會選和作業相似的習題演算，助教們人都很好，偶而可以跟他們聊天。 電子設計自動化演算法與實作 授課老師：電工 陳宏明、趙家佐 評分方式：期中考 30%、4 作業 45%、final project 25% 作業：由不同實驗室各出一個，所以評分方式也有所不同。測資常常沒說明大小，問助教也並沒有清楚的回覆，這點有些不習慣。 2-way Partition Grid Routing Binary Decision Diagram SAT-Based Path-Delay-Fault ATPG 上課內容 Introduction to EDA Partitioning: KL, FM, Simulated Annealing Floorplanning: Slicing Tree, B* tree Placement: cluster groth, min-cut, force-directed, simulated annealing, genetic algorithm Routing: global (Lee, line-search), detailed (channel, clock, power/ground) Logic synthesis \u0026amp; verification: ROBDD, \u0026hellip; Testing 期中考因為疫情被延到期末，考試範圍只有 Physical Design 和 Logic Synthesis \u0026amp; Verification。 個人比較喜歡 Physical 的部分，後面就沒有認真學了。如果討厭 Heuristic 的人，EDA 這個領域可能不適合你。 期末專題是選一篇 Paper 寫報告，或是參加 ICCAD contest（會拿 alpha test 計分），參加比賽分數會高個 5~10 分。 通識 校基本 - 疾病知識與防治 授課老師：黃元惠（新竹台大醫院的外科醫生） 評分方式：上課參與與發問 30%（全勤80，問一次約加 2分）、分組討論報告 20%、個人書面報告 20%、期末考 30% 上課是用投影片，老師非常認真回答同學問題。就算你高中不是三類組，也保證能聽得懂。 一學期大概點三次名，會挑人數有點少又不會太少。 報告最好不要第一組，你比較知道準備方向，五個人一組其實負擔很小，小心不要遇到很雷的人就是了。個人和分組報告都是自己選擇主題，很自由，書面報告大約期末倒數第三週交。 期末筆試，可用網路查，兩題申論，一題會是和上課內容有關「冬天需注意的疾病、防治方法」，一題時事題「同婚公投」。反正不翹課應該就能拿 80 分以上，算是甜了。 校基本 - 幾何造型 授課老師：陳明璋 評分方式：隨堂作業 8 次 65%、期末作業 25%、作業每次超過 90 分 + 0.9%、85分 + 0.5% 作業會分成課堂操作歷程呈現的部分，還有課後自己練習及成品彙整的部分（5頁以上）。老師作業改得有點慢，所以我有些做的不錯的圖放在歷程的部分，而不是放在彙整的部分，老師就沒有仔細留意，作業分數就落在 87 左右，因此沒到 90 很虧。 課堂上由老師帶著做一遍，用老師研發的 AMA 軟體（PPT外掛）進行造型繪製。內容包含對稱、碎形、錯覺等等，上課教的很扎實，設計的過程不只對圖形構造的方法更了解，也能學到如何利用工具提升自己的工作速度，避免一再重複一樣的操作，是一門滿有意義的課。老師準備要退休了，真難過。 期末專題是以繪本的方式呈現，至少 25 頁，我做了大約 30 小時，但最後總成績卻還是 A 而已。平常的作業我花的時間大約 5 小時，但認識某資工大神每次花 10 小時做作業，自認不如人家。 校基本 - 統計方法與資料分析 授課老師：唐麗英 網路課程很涼，給分很甜。 有三堂面授，有小組報告，每堂老師都會遲到。 考試可以帶小抄，期中期末各一。 校基本 - 認識語言 授課老師： 上半學期：盧郁安 下半學期：周昭廷 評分方式： 上半學期 課堂參與 15%：每堂課結束會玩 Kahoot。 作業 15%：Praat、\u0026hellip; 期中影片 30%：選一個主題做「60 秒懂 xxx」 下半學期 下課前 Kahoot 小考 2% x 8 Google 表單小考 2% x 7：每週會給一篇文章回去閱讀、題目也會先公布 期末報告 20%：5 important ideas in the course 每週可針對閱讀或語言學提出一個問題 0.5% 上課回答問題 0.5% 上課內容 上半學期：聲音的結構與測量、發音部位、語言感知、句法學\u0026hellip; 下半學期：認知科學、Universal Grammar、母語的學習歷程、嬰兒的認知能力、Finite State Grammar\u0026hellip; 上半學期的內容著重在音韻學，但也有上到一些句法學，期中專題一半的分數是同學互評。下半學期很有趣，是以認知科學的角度去認識語言學。 上半學期有一次上課會用「沙拉油＋活性碳」去塗在舌頭上，做顯影觀察發音的位置。 算是偏涼和甜的課，但可以學到很多東西。 跨院 - 統計學 授課老師：彭南夫 評分方式：小考 15% x 2、期中期末各 35% 不會點名。上課基本上就是投影片唸一唸，每個章節至少重複講 2 次。 因為是電機系開的，所以沒講數學證明，讓我很失望，就不太上這門課了。 考前會出作業，會讓助教講解，但不收作業。考試是 openbook，有些人會有考古題抄上去，於是就 95 以上。但我有些計算錯誤之類的，分數就被扣一半掉了，於是總成績只拿 C。 核心社會 - 政治學 授課老師：胡志光 評分方式：出席 10%、上台報告 10%、期中考 30%、期末考 30%、期末書面報告 20% 用書：《政治學與台灣政治》，建議一定要準備一本，清大人社圖書館有幾本。 授課方式：用書商的投影片，但會在口頭補充一些東西。上課老師會點同學回答問題當點名，一學期大概被點到三次左右。每週上一個單元，有些單元內容不多，甚至會提早一堂課下課。 考試：有些名詞定義，還有一些閱讀題，考運用了什麼政治學觀念。老師統計後，大家考前準備時間平均是 7 小時。認真聽課應該就會知道哪些地方是重點，雖然我到考試時就把前一天讀的東西忘光了，讀工科讀久了就忘記怎麼記背科了。老師說只要期末考比期中考進步，就不太會當掉你。 上台報告：10 分鐘左右，報告一則國內時事，只要準備新聞網址，說明為什麼是政治的新聞，政治主要就是兩群人的衝突，這個部分有抓到應該都不會太差。報告日期是自己選，建議選中間偏前面，愈早報吿老師要求愈低。 期末報告：選一則解嚴後的國內政治事件，寫 2000 字的書面報告，一半的篇幅敘述事件，另外一半用課本中的政治學概念做分析。在最後一個月，老師會點同學確認報告主題。班上滿多人選年金改革、同婚、公投、土地徵收等近幾年的時事。本來有想選大巨蛋案當作題目，但是老師說後來的發展都很陰謀論，所以就聽老師的建議換主題了。繳交時間訂在期末考後下一週，感覺還算友善。 原本是聽隊友建議選了這門課當作核心向度的通識，聽他說上課都在聽故事，不會太累，考試不難分數也還可。但後來才知道他是指兩學分的政治學 QQ 核心社會 - 教育學概論 授課老師：黃漢昌 評分方式：期中報告 25%、期末報告 25%、分組報告 20%、課堂學習單與討論 30% 每次上課都會發學習單，當天要交回，然後舉手回答問題或提問會加分或得到一本書。基本是提問比較容易拿分。 期中報告和期末報告，分別是選一個有興趣的教育問題，和讀一本教育學相關的書寫心得，2500 字，建議在期中選書，選項比較多。 分組報告，大約五人一組，但 ppt 在前幾週就要先交，不確定老師如何評分。 核心人文 - 東亞儒家：人文精神 授課老師：台大 黃俊傑 評分方式：作業 50％、課程參與 20％（兩次直播和一次討論課）、期末報告30％ 是夏季學院開的非同步的線上課程，總共七週，每週都有一週的時間看線上課程和寫作業，字數每次 600~1000 字，教學平台是用 NTU Cool。助教還滿用心改作業的，上課內容也很扎實，分數算是偏甜。 上課內容：孔孟思想、大學、道德經、禪宗、心經、朱子、東亞的儒家思想（中日韓台）等。 外文 大一英文（一） 授課老師：吳思葦 評分方式：出席10%、課堂學習單和平時加分30%、期中20%、期末20%、課堂寫作5%、GEPT 10%（一次課堂三次線上）、VOD 5%（去圖書館三樓語言中心 5 次） 以聽力為主，口說次之。絕對不要翹課或請假，分數會差很多。上課還算輕鬆，功課大約 15 分鐘就可以寫完。期中是考聽力，期末是一組三人，十分鐘的對話要背稿。整體來說投資報酬率不高，要拿 90 以上有點難，完全沒調分。 德文（一） 授課老師：周玉蕙 評分方式：出席、期中小組口試、期末筆試、自我介紹影片 上課會有分組互動，和隔壁的同學練習對話。也會點同學回答問題，但只是練習，不影響分數。 期中考花了很多個禮拜，這點可以改善。主要的內容是介紹組員。 期末文法筆試，主要就是要會背冠詞。 建議買課本，或是跟同學借來印。平常會勾練習本的作業，但都不算分。 德文（二） 授課老師：周玉蕙 評分方式：出席、小組短劇（邀請吃飯）、用德文介紹食譜、期末錄影片（現在完成式練習） 主要都在練習動詞、分離動詞、現在完成式。 疫情後是非同步影片。 進階英文寫作 授課老師：張靜芬 評分方式：出席 15%、作業 50%、部落格專題 25%、作品集 10% 作業有 7 次，作業給分幾乎都介於 85-90，普通就 87，結構好就會到 90。每個作業的流程都是，一週寫完初稿，下次上課給同學 review，繳交修正版，老師給評語和分數，最後改版和前兩個版本都放到 profolio。 老師強調她不想和其他寫作課一樣，都在教 essay，所以作業很豐富，有 summary, product review, \u0026hellip;\u0026hellip; 期中是要一個四人一組的專題，要寫一系列文章，每個人要寫四篇，還要寫 Report。 上課會有一些分組練習，整體來說上課很活潑，不會想睡。但是比較可惜的是同學通常都很害羞，不會給太具體的建議。 ","date":"2022-06-14T11:00:15+08:00","image":"https://luke2336.github.io/p/course_nctu/G0_hu1fbc951f099036ef7b4ff224269900ab_193107_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/course_nctu/","title":"交大修課心得"},{"content":"簡單寫了一個幾何模板當作練習。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4template\u0026lt;typename T\u0026gt; 5class Point { 6 T x; 7 T y; 8public: 9 Point() {} 10 Point(const T \u0026amp;x, const T \u0026amp;y): x(x), y(y) {} 11 Point operator+(const Point \u0026amp;r) const { 12 return Point(x + r.x, y + r.y); 13 } 14 Point operator-(const Point \u0026amp;r) const { 15 return Point(x - r.x, y - r.y); 16 } 17 bool operator==(const Point \u0026amp;r) const { 18 return x == r.x \u0026amp;\u0026amp; y == r.y; 19 } 20 T dot(const Point \u0026amp;r) const { 21 return x * r.x + y * r.y; 22 } 23 T cross(const Point \u0026amp;r) const { 24 return x * r.y - y * r.x; 25 } 26}; 27 28template\u0026lt;typename T\u0026gt; 29class Line { 30 Point\u0026lt;T\u0026gt; p; 31 Point\u0026lt;T\u0026gt; q; 32public: 33 Line() {} 34 Line(const Point\u0026lt;T\u0026gt; \u0026amp;p, const Point\u0026lt;T\u0026gt; \u0026amp;q): p(p), q(q) {} 35 T getLen() const { 36 Point\u0026lt;T\u0026gt; tmp = p - q; 37 return sqrt(tmp.dot(tmp)); 38 } 39}; 40 41int main() { 42 Point\u0026lt;double\u0026gt; a(0, 0), b(3, 4); 43 Line\u0026lt;double\u0026gt; line(a, b); 44 cout \u0026lt;\u0026lt; line.getLen() \u0026lt;\u0026lt; endl; 45 return 0; 46} ","date":"2022-06-08T14:13:30+08:00","permalink":"https://luke2336.github.io/p/template1/","title":"template class 練習"},{"content":"今年暑假我就畢業了，工作是在 Google 的新店辦公室，因為不方便通勤，所以就得開始找房子。\n租屋名詞解釋 獨立套房：有廁所的房間，有獨立的出入口。 出租套房：比起獨立套房而言，多了公共區域，但相對沒隱私。 雅房：需要和他人共用廁所的房間 用什麼工具找房子 591 租屋網 FB 社團 豬豬快租 APP IG 房仲帳號（我開了一個獨立的帳號用來看房子的貼文） @taipei_rent_house_van @taipei_rent @taipei.rent @taipei_king_house @taipei_rent_house @taipei.rent.house @rent_a__house_du @taipei_renthouse2.0 找房子的時間 我自己是 7 月中旬開始工作，6 月下旬學校會要求搬宿舍。因為最後一個學期只修了一兩門課，於是有充分的時間可以研究，從 4 月上旬就開始在租屋網上研究。最後在 5 月上旬簽約，6 月上旬搬家。 被我塞進筆記裡的大約有超過 60 間房子。 每天早上都會看一下網站和 APP 有什麼新的物件，然後有空也會把筆記裡已出租的物件刪除。 另外，開始找之前，可以先研究個區域的通勤方式跟時間，這樣能比較快過濾出要找的區域。 整理找到的資訊 用 notion.so 建立資料庫，可以 sort 和建立 filter。 重視的東西 可以看到我重視的幾個點是有沒有垃圾代收和陽台，然後其次是電梯和廚房。價錢和交通也是決定性的因素。 多看幾間後就可以了解自己的需求要多少預算才可以滿足，邊看邊修正自己的預算。 看房要注意的地方 我大概看了 7 間房間就決定要租哪間了，當中有被放鴿子的經驗，大家最好出發前跟對方確定房子還沒被訂走，如果是找房仲可以請他一次多帶你看幾間同區域的房子。\n會不會漏水 房間、廁所有沒有對外窗 逃生動線是否寬敞 樓下是否有油煙 周遭區域晚上照明是否充足 熱水的溫度和水量 窗戶是否能救災 如何和房東相處 要有禮貌，最好表明自己有正當工作，但不要談價錢前就透露自己的薪水高低。 通常可以試著議價 500~1000 元，再多應該不可能了。 記得和房東要聯絡方式。 簽約 通常會先給個訂金，我自己是租 10000~15000，給了 3000 當訂金，記得這個時候要房東寫個字據代表他確實收到，也寫清楚雙方違約時訂金的處理方式。 台北的租屋市場流動還算快，正常的物件會要求你 1~2 個禮拜內簽約，可能給你 3 天的搬遷期。 如果房東說可以簽半年約，代表這房子可能有雷。可以先上租屋平台看同樣地點上次 po 文的時間，推算上一個房客住了多久。 合約的內容可以參考內政部的應記載及不得記載事項跟房東討論。 稅務及遷戶籍相關的內容可以詳細計算一下自己的所得稅扣繳方式後決定是否跟房東讓步，因為假設被政府知道是出租用屋，其地價稅會翻五倍。 水電的收費方式也要跟房東確認，還有傢俱電器的修繕責任最好也在合約中寫清楚。 ","date":"2022-06-06T16:50:54+08:00","image":"https://luke2336.github.io/p/rent-house/1_hu2fb58ca7177230660753d8dfe79127a7_149044_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/rent-house/","title":"台北租屋經驗"},{"content":" 這篇是用來記錄 UNIX hw1 的實作坑。 實作時可能會因為不是 root 權限，而需要輸出 permission denied。 這份功課有點吃字串處理技巧。 Goal COMMAND PID USER FD TYPE NODE NAME\nPID 先從 /proc 裡面撈出所有的 pid，然後再針對每個 pid 去撈剩下的資訊。 Command 從 /proc/[pid]/comm 讀寫。 User、UID 每個 pid 資料夾中的 user 都相同，於是只要用 stat() 去找 /proc/[pid] 的 st_uid 就行了，然後從 /etc/passwd 撈出對應的 username。 FD 分成以下幾種：\ncwd 從 proc/[pid]/cwd 裡找，因為是 symbolic link，所以用 readlink() 讀出連接的檔名。 rtd 從 proc/[pid]/root 裡找，然後一樣用 readlink()。 txt 從 /proc/[pid]/exe 裡找，然後一樣用 readlink()。 mem 讀 /proc/[pid]/maps。 [0-9]+[rwu] 從 /proc/[pid]/fdinfo/[fd] 裡讀取 flag，然後用 \u0026amp; O_O_ACCMODE 去區分是讀或寫。\nName 除了上述三種用 readlink() 以外，mem 是讀 ./maps，fd 則是 /proc/[pid]/fd/[fd] 丟進 readlink()。 Node 把檔名丟進 stat() 得到 st_ino。 Type 把檔名丟進 stat() 得到 st_mod。 然後要注意 socket 和 pipe 的 Type。 ","date":"2022-03-18T18:49:31+08:00","permalink":"https://luke2336.github.io/p/lsof/","title":"實作 lsof"},{"content":" 今天總共走了 3 萬步。 野柳 金山 去泡硫磺泉 喝了一杯紫地瓜歐雷。 金山獅頭山公園 ","date":"2022-03-13T19:39:05+08:00","image":"https://luke2336.github.io/p/yehliu/1_hu682ff45fbc5a9de78e5b39cebbbfeb55_2287366_120x120_fill_q75_box_smart1.jpeg","permalink":"https://luke2336.github.io/p/yehliu/","title":"野柳、金山"},{"content":"什麼是 lex lex 是幫我們做 lexical analysis 的工具，它負責將 source code 切成一些 token。\nCompile 方法 1lex rule.l 2gcc lex.yy.c -ll 3./a.out \u0026lt; input lex 的格式 利用 %% 將 code 切成三個區段，第一個和第二個是必須的。\n1definition section 2%% 3rule section 4%% 5user subroutine 最簡單的 lex 程式 1%% Definition Section 寫在此區的 Ｃ 程式碼需要加上 %{ 和 %}，例如放 header 和全域變數等等。 可以給於一些定義。 1digit [0-9] 2letter [a-zA-Z] 3space [ \\t]+ 4identifier {letter}({digit}|{letter})* 5integer 0|([1-9]{digit}*) 可以定義一些 State，用 %s 或 %x，預設的 State 稱為 INITIAL。 1%s state1 state2 state3 Rule Section 前面那一項是要寫正規表示法。 比對的規則是先找最長的 rule，遇到一樣長的時候，找最前面的 rule。 1/* 以下這份 code 可以將程式的空白和換行移除。 */ 2{space} { ; } 3\\n { ; } 4. { ECHO; } User Subroutine 用來寫一些 function。 可以自定義 main()，若沒有則是用預設的 main()。 1main() { 2 yylex(); 3} 正規表示法 regular expression definition . 一個字元（\\n 以外的所有字元） * 重複零次以上 + 重複一次以上 ? 零次或一次 ^ 放在 [] 中，表示不包含 ^ 放在開頭，表示一行的開頭 $ 放在結尾，表示一行的結尾 {a, b} 重複 a ~ b 次 ` ` / 表示前面的表示法需要接在後面的表示法之前，yytext 只匹配到前面 %s 和 %x 的區別 使用 %s 時，沒有定義狀態的 rule，可以代表所有狀態。 使用 %x 時，則是 exclusive，沒有定義狀態的只會配到 INITIAL。 Test Case 1/* 2comment 3*/ Example 若運行以下程式碼，會輸出 id，正確的 rule 需改成 \u0026lt;INITIAL\u0026gt;{identifier}，否則按規則將匹配到最長的 rule。 1%s COMMENT 2 3%% 4 5\u0026#34;/*\u0026#34; { BEGIN COMMENT; } 6\u0026lt;COMMENT\u0026gt;. { ; } 7\u0026lt;COMMENT\u0026gt;\u0026#34;*/\u0026#34; { ; } 8{identifier} { printf(\u0026#34;id\u0026#34;); } 以下是正確的寫法，只要用 %x 就可以避免上述情況。 1%x COMMENT 2 3%% 4 5\u0026#34;/*\u0026#34; { BEGIN COMMENT; } 6\u0026lt;COMMENT\u0026gt;. { ; } 7\u0026lt;COMMENT\u0026gt;\u0026#34;*/\u0026#34; { ; } 8{identifier} { printf(\u0026#34;id\u0026#34;); } 特殊指令 ECHO, REJECT, BEGIN。 Lex Libiary yytext yyleng yyin yyout yylex() yymore() yyless(n) yywrap() ","date":"2022-03-11T10:18:20+08:00","permalink":"https://luke2336.github.io/p/lex/","title":"lex 筆記"},{"content":" 時間 地點 12:15 校車 13:20 陽明校門口 13:30 登山口 13:40 大學亭 13:50 軍艦岩 原路折返 16:30 校車 17:40 交大校區 ","date":"2022-03-11T10:17:51+08:00","image":"https://luke2336.github.io/p/nycu-taipei/2_hu682ff45fbc5a9de78e5b39cebbbfeb55_3342050_120x120_fill_q75_box_smart1.jpeg","permalink":"https://luke2336.github.io/p/nycu-taipei/","title":"軍艦岩"},{"content":"談文車站、鄭漢步道 16:01 談文車站 16:28 登山步道口 16:40 紀念碑、觀景台 17:51 區間車 晚餐 - 晶品城 B2 水月 豬排飯 ","date":"2022-03-06T09:34:13+08:00","image":"https://luke2336.github.io/p/tanwen/3_hu211a273ce9fa29f63ed99dde98e5d89d_2468881_120x120_fill_q75_box_smart1.jpeg","permalink":"https://luke2336.github.io/p/tanwen/","title":"談文 - 鄭漢步道"},{"content":" Learn Kotlin by Example (kotlinlang.org) Output println() 1fun main() { 2 println(\u0026#34;Hello, World!\u0026#34;) 3} Function fun 1fun sum(x: Int, y: Int): Int { 2 return x + y 3} 4 5// Single-Expression 6fun mul(x: Int, y: Int) = x * y 7 8// Default Arguments 9fun printMSG (msg1: String = \u0026#34;Hello\u0026#34;, msg2: String) { 10 println(\u0026#34;$msg1, $msg2!\u0026#34;) 11} 12 13fun main() { 14 println(sum(1, 2)) 15 println(mul(2, 5)) 16 printMSG(\u0026#34;Hi\u0026#34;, \u0026#34;Jack\u0026#34;) 17 printMSG(msg2 = \u0026#34;Kelly\u0026#34;) 18} vararg 1fun sum(vararg a: Int): Int { 2 var ret = 0 3 for (x in a) ret = ret + x 4 return ret 5} 6 7fun main() { 8 println(sum(1, 0, -1, 2)) 9} Variable val var val 一定要初始化 1fun main() { 2 val v = 1 // immutalbe 3 var x: Int // mutable 4 x = 1 5 println(x + v) 6} null 用 ? 代表 nullable 1fun main() { 2 var notNull: String = \u0026#34;Hi!\u0026#34; 3 // notNull = null // error 4 var canNull: String? = \u0026#34;Hello!\u0026#34; 5 canNull = null 6 7 fun len(s: String) = println(s.length) 8 9 len(notNull) 10 // len(canNull) // error 11 canNull = \u0026#34;OAO\u0026#34; 12 len(canNull) 13 14 fun nullLen(s: String?) { 15 var L:Int = 0 16 if (s != null) L = s.length 17 println(L) 18 } 19 20 canNull = null 21 nullLen(canNull) 22} Flow Control when 類似 c++ 中的 switch。\n1fun cases(obj: Any) { 2 when (obj) { 3 1 -\u0026gt; println(\u0026#34;One\u0026#34;) 4 is String -\u0026gt; println(\u0026#34;String\u0026#34;) 5 else -\u0026gt; println(\u0026#34;Else\u0026#34;) 6 } 7} 8 9fun main() { 10 cases(1) 11 cases(1.0) 12 cases(\u0026#34;a\u0026#34;) 13} for 1fun main() { 2 val L = listOf(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;) 3 for (x in L) { 4 println(\u0026#34;I like $x.\u0026#34;) 5 } 6} 1fun main() { 2 for (i in 0..3) print(i) //0123 3 println(\u0026#34;\u0026#34;) 4 for (i in 0..8 step 2) print(i) //02468 5 println(\u0026#34;\u0026#34;) 6 for (i in 3 downTo 0) print(i) //3210 7 println(\u0026#34;\u0026#34;) 8 for (i in 8 downTo 0 step 2) print(i) //86420 9 println(\u0026#34;\u0026#34;) 10} while 1fun main() { 2 var i = 0 3 var sum = 0 4 while (i \u0026lt; 5) { 5 sum += i 6 i++ 7 } 8 println(sum) 9} if 1fun main() { 2 val x = \u0026#39;t\u0026#39; 3 if (x in \u0026#39;a\u0026#39;..\u0026#39;e\u0026#39;) 4 println(\u0026#34;Good\u0026#34;) 5 else 6 println(\u0026#34;Bad\u0026#34;) 7} Collections List MutableList, List mutableListOf(), listOf() add() getOrNull(), getOrElse() 1fun main() { 2 val L: List\u0026lt;Int\u0026gt; = listOf(1, 2, 3) 3 var mL: MutableList\u0026lt;Int\u0026gt; = mutableListOf(0) 4 L.forEach { 5 x -\u0026gt; mL.add(x) 6 } 7 mL.forEach { 8 i -\u0026gt; println(\u0026#34;elemetn: $i\u0026#34;) 9 } 10 println(\u0026#34;L[2] = ${L.getOrNull(2)}\u0026#34;) // 3 11 println(\u0026#34;L[3] = ${L.getOrNull(3)}\u0026#34;) // null 12 println(\u0026#34;L[10] = ${L.getOrElse(10, {it})}\u0026#34;) // 10 13 println(\u0026#34;${L.subList(1, 2)}\u0026#34;) // [2] 14} Search \u0026amp; Sort sort(), shuffle(), reverse() indexOf(), lastIndexOf() indexOfFirst(), indexOfLast() binarySearch() fill() 1fun main() { 2 var mL: MutableList\u0026lt;Int\u0026gt; = mutableListOf(2, 1, 7, 5, 9, 1) 3 println(mL.indexOf(1)) // 1 4 println(mL.lastIndexOf(1)) // 5 5 mL.sort() // [1, 1, 2, 5, 7, 9] 6 println(mL.indexOf(1)) // 0 7 println(mL.lastIndexOf(1)) // 1 8 println(mL.indexOfFirst{ it \u0026gt; 5 }) // 4 9 println(mL.binarySearch(3)) // -4 10 println(mL.binarySearch(1, 1, 5)) // 1 11 mL.fill(0) 12 println(mL) // [0, 0, 0, 0, 0, 0] 13} Set Set, MutableSet setOf(), mutableSetOf() add(): return Boolean intersect(), union(), subtract() 1fun main() { 2 val S1: Set\u0026lt;Int\u0026gt; = setOf(4, 3, 2, 1) 3 val S2: Set\u0026lt;Int\u0026gt; = setOf(1, 2, 3, 4) 4 println(\u0026#34;Two sets are equal: ${S1 == S2}\u0026#34;) // true 5 val S3: Set\u0026lt;Int\u0026gt; = setOf(0, 2, 4, 6) 6 println(\u0026#34;S2 union S3: ${S2 union S3}\u0026#34;) // [1, 2, 3, 4, 0, 6] 7 println(\u0026#34;S2 intersect S3: ${S2 intersect S3}\u0026#34;) // [2, 4] 8 println(\u0026#34;S2 subtract S3: ${S2 subtract S3}\u0026#34;) // [1, 3] 9 println(\u0026#34;S3 subtract S2: ${S3 subtract S2}\u0026#34;) // [0, 6] 10 println(\u0026#34;S1 subtract S2: ${S1 subtract S2}\u0026#34;) // [] 11 var S4: MutableSet\u0026lt;Int\u0026gt; = mutableSetOf(1, 2, 3, 4) 12 println(\u0026#34;${S4.add(0)}\u0026#34;) // true 13 println(\u0026#34;${S4.add(1)}\u0026#34;) // false 14} Map 1fun main() { 2 val map = mapOf(\u0026#34;key\u0026#34; to 42); 3 println(\u0026#34;${map[\u0026#34;key\u0026#34;]}\u0026#34;) // 42 4 println(\u0026#34;${map[\u0026#34;key2\u0026#34;]}\u0026#34;) // null 5 println(\u0026#34;${map.getValue(\u0026#34;key\u0026#34;)}\u0026#34;) // 42 6} ","date":"2022-02-27T10:14:36+08:00","permalink":"https://luke2336.github.io/p/hello_kotlin/","title":"Hello, Kotlin!"},{"content":" 又在疫情下度過了一年。 大事件 Date News 2021/01/06 拜登就職 2021/01/12 部桃事件 2021/02/01 合併為陽明交通大學 2021/02/06 黃捷罷免案不通過 2021/03/17 鮭魚之亂 2021/03/23 長榮蘇伊士運河事件 2021/04/02 太魯閣出軌 2021/05/13 分區供電 2021/07/23 東奧開幕 2021/07/27 降為二級警戒 2021/09/11 美軍從阿富汗撤軍 2021/10/14 城中城火災 2021/12/18 公投 ","date":"2022-02-25T09:54:10+08:00","image":"https://luke2336.github.io/p/news_2021/news_hufa7791a1468366d31a63b50f3da8e791_36231_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/news_2021/","title":"2021 簡記"},{"content":" 給大家參考一下交大的申請交換經驗。 官網。 申請過程及結果 於 109 上學期末申請交換，預計 110 下學期。 申請的志願排序為： 北京大學 復旦大學 上海交大 計分比例： 成績 60% 自傳 15% 讀書計畫 20% 其他有利審查資料 5% 獎學金 於 109 下學期申請。 獲得 13 萬元。 自傳： 製作簡歷，展示大學期間競賽成績。 說明自己能妥善地利用資源，舉例來說充分利用了交大和清大的資源。 研修計畫： 說明自己的選課計畫。 簡單帶過文化交流的部分。 成績單： 只需要到二下的資料，平均成績約為 87.7。 因為是大陸地區，所以不需要英檢證明。 需繳交 1 萬元保證金，但只要是因疫情放棄即可全退。 放棄： 考量到疫情及無法完整接種兩劑疫苗到生效，決定放棄資格。 ","date":"2022-02-09T16:35:46+08:00","image":"https://luke2336.github.io/p/exchange/grade_hu407f3fdf1c00cf42443c0259a53384ff_49680_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/exchange/","title":"交大交換申請"},{"content":" https://atcoder.jp/contests/abc237/tasks。 很早就放棄掙扎的一場。 很久沒打 ABC 了，難度似乎提升很多。 A. Not Overflow 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8int main() { 9 ios::sync_with_stdio(0), cin.tie(0); 10 ll N; 11 cin \u0026gt;\u0026gt; N; 12 ll min = -(1ll \u0026lt;\u0026lt; 31); 13 ll max = (1ll \u0026lt;\u0026lt; 31) - 1; 14 if (min \u0026lt;= N \u0026amp;\u0026amp; N \u0026lt;= max) { 15 cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; 16 } else { 17 cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; 18 } 19 return 0; 20} B. Matrix Transposition 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8int main() { 9 ios::sync_with_stdio(0), cin.tie(0); 10 int H, W; 11 cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W; 12 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; A(H, vector\u0026lt;int\u0026gt;(W)); 13 for (int i = 0; i \u0026lt; H; i++) { 14 for (int j = 0; j \u0026lt; W; j++) { 15 cin \u0026gt;\u0026gt; A[i][j]; 16 } 17 } 18 for (int i = 0; i \u0026lt; W; i++) { 19 for (int j = 0; j \u0026lt; H; j++) { 20 cout \u0026lt;\u0026lt; A[j][i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[j == H - 1]; 21 } 22 } 23 return 0; 24} C. kasaka 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8bool ispal(string s) { 9 for (int i = 0; i \u0026lt; s.length() / 2; i++) { 10 if (s[i] != s[s.length() - 1 - i]) { 11 return false; 12 } 13 } 14 return true; 15} 16 17int main() { 18 ios::sync_with_stdio(0), cin.tie(0); 19 string s; 20 cin \u0026gt;\u0026gt; s; 21 int cnt = 0; 22 for (int i = 0; s[i]; i++) { 23 if (s[i] == \u0026#39;a\u0026#39;) cnt--; 24 else break; 25 } 26 for (int i = s.length() - 1; i \u0026gt;= 0; i--) { 27 if (s[i] == \u0026#39;a\u0026#39;) cnt++; 28 else break; 29 } 30 string str = \u0026#34;\u0026#34;; 31 for (int i = cnt; i \u0026gt; 0; i--) { 32 str += \u0026#34;a\u0026#34;; 33 } 34 str += s; 35 if (ispal(str)) { 36 cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; 37 } else { 38 cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; 39 } 40 return 0; 41} D. LR insertion Linked List。 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8int main() { 9 ios::sync_with_stdio(0), cin.tie(0); 10 int N; 11 cin \u0026gt;\u0026gt; N; 12 string s; 13 cin \u0026gt;\u0026gt; s; 14 vector\u0026lt;int\u0026gt; left(N + 1, -1), right(N + 1, -1); 15 for (int i = 0; s[i]; i++) { 16 if (s[i] == \u0026#39;L\u0026#39;) { 17 left[i + 1] = left[i]; 18 if (left[i] != -1) right[left[i]] = i + 1; 19 right[i + 1] = i; 20 left[i] = i + 1; 21 } else { 22 right[i + 1] = right[i]; 23 if (right[i] != -1) left[right[i]] = i + 1; 24 left[i + 1] = i; 25 right[i] = i + 1; 26 } 27 } 28 int head = 0; 29 for (int i = 0; i \u0026lt;= N; i++) { 30 if (left[i] == -1) head = i; 31 } 32 for (int i = head; i != -1; i = right[i]) { 33 cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 34 } 35 return 0; 36} E. Skiing Dijkstra。 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;ll, int\u0026gt; pii; 6#define pb push_back 7 8#define INF 1000000000000000000ll 9 10int main() { 11 ios::sync_with_stdio(0), cin.tie(0); 12 int N, M; 13 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; 14 vector\u0026lt;int\u0026gt; h(N); 15 for (int i = 0; i \u0026lt; N; i++) 16 cin \u0026gt;\u0026gt; h[i]; 17 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; edge(N); 18 for (int i = 0; i \u0026lt; M; i++) { 19 int u, v; 20 cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; 21 u--, v--; 22 edge[u].push_back(v); 23 edge[v].push_back(u); 24 } 25 vector\u0026lt;ll\u0026gt; dis(N, -INF); 26 ll ans = 0; 27 dis[0] = 0; 28 priority_queue\u0026lt;pii\u0026gt; pq; 29 pq.emplace(0, 0); 30 while (!pq.empty()) { 31 int u = pq.top().second; 32 pq.pop(); 33 for (int uu : edge[u]) { 34 int value; 35 if (h[u] \u0026gt;= h[uu]) { 36 value = h[u] - h[uu]; 37 } else { 38 value = 2 * (h[u] - h[uu]); 39 } 40 if (dis[u] + value \u0026gt; dis[uu]) { 41 dis[uu] = dis[u] + value; 42 pq.emplace(dis[uu], uu); 43 ans = max(dis[uu], ans); 44 } 45 } 46 } 47 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 48 return 0; 49} ","date":"2022-01-30T20:51:14+08:00","image":"https://luke2336.github.io/p/atcoder_abc237/Standing_hue27d2c333067e8fbd232ed5f6a1913b8_218561_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/atcoder_abc237/","title":"AtCoder Beginning Contest 237"},{"content":"主要是分享一下折騰三個月的轉正過程。\n在提供 Resume 的階段，會要求提供認識的 Googler 名字（有點作為推薦人的概念）（要是 Host 和 Co-Host 以外的人）。 Recruiter 整個流程都安排得很有效率且會提醒一些注意事項，算是體驗良好。 因為暑假的 Code 量有點少，於是被加了兩場面試。 面試 Recruiter 提醒我是英文的之後，向他詢問可不可以換成中文的，於是就換成跟上海和新店辦公室的人面試。 雖然 Recruiter 建議刷一下 Leetcode，但我這半年刷不到 20 題。 通過 Hiring Committee 後，被通知之前成功的 Team Match 被取消。 原本到第四場都是 ChromeOS 的 Team，但一直失敗，於是最後就請 Recruiter 也幫忙找看看新店或板橋的 Team，所以最後就到新店的 Pixel Team。 Team Match 主要是和 Manager 聊半個小時後，雙方再向 Recruiter 確認喜不喜歡對方。 滿多場 Team Match 都被問到「對 Linux 熟不熟悉」「對 Kernel 熟不熟悉」。 因為沒有 Competing Offer，所以 Offer 就沒有討論空間了。 有聽到一些朋友是先簽 Offer 才 Team Match。 如果不是 Intern 轉正的話，聽說是至少要面試 6 回合。 Recruiter 會要求 Onboard 的日期是星期一，而且是要拿到畢業證書。 日程 Date Status 2021/09/28 收到 email 要求提供 Resume 和 Transcript 2021/10/19 Team Match 1 2021/10/20 Team Match 2 2021/10/28 Team Match 3 2021/12/08 被要求加面試 2 場 2021/12/23 Interview 1 2021/12/24 Interview 2 2022/01/18 通過 Hiring Committee 2022/01/19 Team Match 4 2022/01/25 Team Match 5 2022/01/27 Team Match 6 2022/01/28 Verbal Offer Offer 會討論到一下幾種東西。\nBase Bonus：一個 % 數 Stack：會拆成四年 交通津貼 年假 找工作的心得 除了 Google 以外，還投了以下幾間公司，全都沒有內推。 MediaTek：無聲卡。 Synopsys：無聲卡。 Cadence：無聲卡。 Microsoft：無聲卡。 Siemens：感謝信。 Ring：OA、無聲卡。 只能說自己履歷上能看的東西只有 ICPC 的成績還有 Google 的實習經驗，沒有 side project，然後沒有碩班學歷可能也有影響。 ","date":"2022-01-28T21:26:20+08:00","permalink":"https://luke2336.github.io/p/google-return/","title":"Google Taiwan 實習轉正"},{"content":"目標 通過交大換修標準 785 分。 準備過程 考了 2021/12/19 的多益，拿到聽力 415 閱讀 380。上一次考是高中畢業時，只考五百多。 整體來說大約花了三週準備。 用書都是從交大圖書館借。 單字：牛津英語大師用THINKING MAP教你多益單字 閱讀：NEW TOEIC 新制多益 : 閱讀5回 全真模擬試題+詳盡解析 準備方法是把單字書裡不熟的字抄下來，然後考前複習，覺得這本書依照場合來整理單字還滿方便的。 閱讀寫了三回，大致上是對 80 題上下，主要是用來練習答題速度。 聽力則是完全裸考，但有擬定好策略。 策略 Part 1 注意 5W1H Part 2 同樣注意 5W1H 注意放慢語速處、加重音、停頓處 Part 3, Part 4 聽之前盡量先看完題目 注意相似字、反義字 Part 5, Part 6 高中文法 搭配詞 Part 7 先看首段首句 先看題目再找答案 快速掃過文章即可 注意文章種類，分為書信、徵人、廣告\u0026hellip;\u0026hellip; 考試當天 聽力有幾題跟不上，但就直接果斷放棄，往後看。 閱讀剛剛好在最後五分鐘寫完。 ","date":"2022-01-10T17:11:16+08:00","permalink":"https://luke2336.github.io/p/toeic_prepare/","title":"多益準備"},{"content":" 春天去清大賞梅。 球拍第一次打到斷線，學會剪線。比了小梅竹，也參加久違的體育週比賽。 面試了 Google 的實習，最後上了，整個暑假都在實習。 決定不讀研究所。看著身邊的人都在申請中煩惱，但自己置身事外的感覺很奇妙，有著不順應潮流的焦慮，但也很開心自己很早就下定決心，沒花太多力氣猶豫。 年底則是面臨轉正、找工作的壓力。 參加 ICCAD，但因為實習的關係，最後沒有做完。 Github 上漸漸有些東西出現。 上半年陸續把欠的醫生看完，看了牙醫、外科、神經內科、婦科\u0026hellip;開學後打了兩劑 AZ。 比了台清交程式比賽。年度賽拿了第三名，但後面的比賽都打得爛爛的。尤其是最後一場 ICPC 直接大爆炸，只拿了銅牌，很不甘心。 英檢還是考不過 QQ 下半年沒有繼續修德文，之前學的東西就很快忘光了，希望近期可以複習起來。 開始練習煮東西，也開始叫 UberEat。 重新開始寫書法。 逛了竹東夜市、慈雲路夜市。去了苗栗、台中、高雄等地方玩，開始會自己一個人出門玩。 2021 Spring 修了正規、EDA、計算方法之實務應用、進階英文寫作、教育學概論、德文二，還旁聽了難解問題。覺得是個很累很充實的學期，不知道是怎麼撐過去的。算是寫了很多作業，讓寫程式的能力進步不少。英文寫作也是收穫很大的一門課。 2022 Fall 修了 NSD、賽局理論、隨機演算法、競技羽球，然後跟葉老師做專題。 看了很多動畫，大部分都是在巴哈上面看的。 半妖的夜叉姬（覺得跟犬夜叉的風格差很多，有點失望） 舞伎家的料理人（每個月只出一集，多當作打發時間看） 我們仍未知道那天所看見的花名 本田小狼與我（最後沒看完） 天地創造設計部（覺得題材滿有趣的一部作品） 白沙的 Aquatope 來自深淵 隱瞞之事 花開物語 不愉快的妖怪庵 妖怪旅館營業中 寶石商人理察的謎鑑定 重啟咲良田 只有我不存在的城市 死亡筆記本 月與萊卡與吸血公主 2021 過完了，覺得離畢業更近了些，有些徬徨，不確定未來的路要怎麼走。但能開始規劃未來也算是一件好事，有些猶豫畢業後要留在新竹還是在台北工作，有些不知道怎麼從家裡獨立出去，想著想著，卻也會開始想像自己未來的房間長怎樣，生活長怎樣，怎樣跟伴侶相處等等，不知不覺有了些藍圖。\n","date":"2022-01-03T14:54:11+08:00","image":"https://luke2336.github.io/p/review2021/Cake_hue2c742c38af44793a116c26b28141832_87296_120x120_fill_q75_box_smart1.JPG","permalink":"https://luke2336.github.io/p/review2021/","title":"2021 回顧"},{"content":" 在暑假順利畢業。 在畢業前找到工作。 考過英檢。 喜歡的人和自己都身體健康。 每週花一點時間學德文。 能維持好現有的人際關係。 能經濟獨立，有一定的自由。 能更成熟獨立。 家裡一切平安順遂。 ","date":"2022-01-01T22:10:34+08:00","permalink":"https://luke2336.github.io/p/newyear2022/","title":"2022 新年願望"},{"content":"一月 新年第一天就決定分手了。 含羞草開花了。 校門的招牌要被換掉了，一堆人去拍照。 看了爺爺與貓（ねことじいちゃん）。 PCCA 去海水屋聚餐。 去台中玩，喝了春水堂的紅茶凍飲。然後去了第一市場附近，走了電子街，去了幸發亭吃蜜豆冰，覺得這種冰很特別，加了很多種水果。之後去了台中都會公園看夕陽，晚上去文心路吃港式飲茶，覺得油雞和葡式蛋塔超級好吃。 交換申請結果出來了，上了第一志願北京大學。 二月 去館前路的台灣銀行開戶。 雙證件、印章、$1000。 大概花 30 分鐘，官方說法是 40 分鐘。我隔壁的先生連 email 都沒有，感覺就要弄很久。 量完體溫後，保全會問你要辦什麼，說要開戶，就直接拿到號碼牌，完全不用等，就直接被叫號了。 會問職業，還有確認是否要在那家分行開戶，之後就一直簽名。 要下載兩個手機 app（強迫推銷），「台灣銀行」和「台灣行動支付」，行員會讓你在製作卡片時自己做這件事。結果行員聽到我沒用過行動支付，她似乎很訝異。 去北一女找老師，等老師下班的時間，看了樂儀旗的練習。之後一起去了館前路的「咖啡弄」吃了午餐，覺得還滿棒的！之後我們到北門附近散步，逛了一些歷史建築。 去木柵動物園玩。 去金山萬里。 去七堵友蚋、石公潭。 去龜吼漁港吃了巧晏漁坊，第一次吃，覺得相對別家價格較低，口味也不錯，雖然生意有點好，位子很小。點了油雞、蝦、海瓜子，都覺得不錯。 跟外婆去黃金瀑布和三貂角燈塔。 第一次去大湖公園，順便去南港車站的蔦屋書店逛逛。 新聞：Google無限空間雲端掰了！明年起校園免費上限100TB。 公園裡的貓，大黃，走了。 淒慘的開學日，NYCU Portal 轟轟烈烈的爆炸了半天。 羽球拍第一次打到斷線。 去台中後站的泉源公園看了生態湖和帝國製糖廠。 三月 Google SWE Intern 線上面試。 去清大吃空堂咖啡。 看了動畫かくりよの宿飯、不機嫌なモノノケ庵。 和老師們吃了 LaLa Kitchen。 交換獎學金的文件。 參加跟清大電機的小梅竹！ 寫 ICCAD Probelm B。 去一餐吃了新開的 10 元壽司。 吃了導聚，去了建功中學對面的芙歐，點了煙燻鮭魚義大利麵，加上套餐，覺得滿飽的，味道還行，但價位大概都 300 左右，平常應該不太會去吃。 去公館跟弟弟吃 pizza。 找了外籍生當室友。 跟學長去逛了竹東夜市。 四月 去台大打台清交程式競賽，拿了第八名。 去桃園逛了 IKEA。 Google Code Jam 1A 晉級到 Round 2。 寫 SAT solver。 吃了好吃的天婦羅。 吃了好吃又很有飽足感的韓式料理，有很多免費小菜可以選，主菜量也夠大份，低消 $170 還能接受。 開始用 Typora 這個 markdown app。 五月 去了橋頭糖廠和西子灣。晚上買了起司配蘋果酒，覺得很棒。 收到了 Google 的 team match 結果，隔天談好了 offer。 參加高一同學會。 疫情升級到第二級警戒。 興達電廠運轉停擺，於是全台分區供電，很幸運的是交大未受此影響。 重新開始玩貓咪大戰爭。 改離散作業，超殺時間的。 六月 期末考。 寫英文寫作課的 Portfolio。 宿舍的盆栽太久沒管他了，似乎被丟掉了，有些難過。 讀教育學概論期末報告的書《受壓迫者教育學》。 因為頭暈和發燒去看了一般內科，剛好是輪到感染科，因為燒了 10 天，現場也量到 37.6，於是就被丟去急診的隔離室，待了兩小時，被戳了兩下採檢，做了 X 光，然後等了一個鐘頭才被放走，花了 2014 元。雖然晚上 PCR 出來是陽性，但還是要自主隔離三天。外套留在男友手裡，於是快冷死了\u0026hellip;\u0026hellip; 最近看完了幾部動畫。 花咲くいろは 色づく世界の明日から 寫了轉系的被審資料。 開始遠端實習。 去竹東看神經內科，做了頸動脈和顱內血管超音波，似乎有些異常。醫生猜測可能是 moyamoya disease。 七月 為了轉系考，刷了一些題。 上了台大的線上通識課。 7/14 轉系考。總共有 169 人考試，160 分及格，大概 42 人。 pA (100) 水題。 pB (80) 大數題，一直解不出來。 pC (100) 背包問題。 pD (100) BFS。 和 Jasmine 學姊開始聊天。 看了神內，MRI 的結果是正常的。 幫 Blog 上了留言區，參考了這篇，使用 Utterances 的 preferred-color-scheme。參考了文章1和文章2，優化了 SEO 搜尋。 Doodle 推出新的東京奧運系列小遊戲。 月底晚上因為手被門夾到，掛急診，幸好沒骨折 八月 決定放棄 ICCAD，專心實習。 看到一些有趣的文章，內容是講陸生來交大交換的心得。 拆箱 Google 的包裹。 等了很久終於從美國寄來了，有一件 T-shirt、一個 Intern 帽帽、一個後背包。 前兩次的 SWAG，分別是 Google 的水壺、高級水壺、Google 的無線快充盤。 中旬開始寫 Design Doc.，很開心 Irene 把她寫的借我參考。 發現電子學和電子實驗的英文班都停開了，轉系沒過，可能畢業困難。突然覺得被 chungsheng 烏鴉嘴中了。 降轉成功了。 從 8/17 開始進 Office，景色超美的，於是一直跑到窗邊工作。 TreapKing 學長幫我做了一杯拉花，超級開心的，於是 bug 就修掉了XD 參考這篇改了 Github 的認證方式。 讀了不怕23K，每月2000元滾千萬の雞尾酒投資法（毎月5000円で自動的にお金が増える方法）。 九月 年度賽拿了第三名，但其實感覺沒有打得特別好，只是其他隊爛掉了而已，風向歪歪的。 題解：https://github.com/mzshieh/2021-ycpc 實習最後一週做了英文的 presentation。 去了資工系羽的暑訓，覺得他們花比較多時間在練球，所以比較累。 交了免修的文件。 打了第一劑疫苗（AZ）。 看了來自深淵 深沉靈魂的黎明。 和旺陽去新竹寶二水庫。 過了不太愉快的中秋節。 拍了畢業照。 十月 專題的 meeting，拿回了一本平行計算相關的書要讀。 競技羽球課上了一些前場的動作。老師說前場的口訣是出手快、腳步踩穩、出拍慢。 NCPC 拿了第 14 名，Jasmine 學姊請我們吃義大利麵。 晚上的多益課是有學到一些英聽的技巧，但還是覺得老師有一半的時間都拿來講廢話或複習，聽了覺得很無聊。 TOPC: Scoreboard 考全民英檢中高級初試，感覺又爆了。 十一月 實作 CSB。 終於可以不用戴口罩打球了 \u0026gt;\u0026lt; 投了 Microsoft 和 Synopsys，純粹想了解自己大學畢業的市場行情，但都被無聲卡。 去建中路的診所打第二劑疫苗（AZ）。 收到 GEPT 英檢成績，63/93，又是因為聽力沒通過。所以就報了 12/19 的 TOEIC。 羽球課練「長切放放挑」還有殺球。 TIWCEF 茶會。 體育週，第一場是對上應數系，結果我被叫去打女單，8:25 慘敗。 第一次去逛慈雲路夜市，買了地瓜球、烤肉串、燒仙草。 ICPC Taipei 打得很爛，只拿到銅獎。前一晚跟隊友在館前路吃藏壽司。 十二月 報帳完後，在東光路吃了火鍋。 導聚去吃了一餐的 La La Kitchen，和兩個大一學弟交換了 FB。 寫信給系主任溝通「基礎圖論」的學分承認問題。 跟隊友們和卡車去吃一燒十味昭和園，覺得味增雞肉還滿好吃的，隊友吃了一堆香草雞腿排。 今年北一校慶因為疫情，沒有對外開放。 學姊快出國了，於是跟她在竹北聚餐了一次。 羽球課練了中前場的防守，覺得正手拍接殺球比較困難。 在新竹高中考了多益。 隨性的投了一家叫 Siemons 的 EDA 工程師，結果今天就收到感謝函了 QQ 但後來查了一下，發現那家外商公司已台商化，可能拿到 offer 也不會想去。 今年聖誕節一整天都在讀書沒出去玩，賽局理論的影片好多，看不完。 去新竹台大看牙醫，找了一下才找到報到處，然後填了初診資料，就去照 X 光。之後由住院醫師先問診，然後我就聽她講了拔智齒的優缺點，雖然有點害怕拔牙也擔心傷到神經，但最後我還是預約 2 月下旬去拔牙，寒假都早就被排滿了。 試著投了 Cadence 的 summer intern，主要是想找 EDA 相關的工作，想培養一些相關的經歷，但不確定應屆畢業生可不可以投。 跟隊友們去吃 pizza，點了墨西哥玉米脆片和三個 pizza，結果四個人吃不完。 12/31 去台中玩，主要是搭捷運，有逛了 IKEA。 ","date":"2021-12-31T06:37:20+08:00","image":"https://luke2336.github.io/p/2021/2_huf4711d8f0d333c78033d48164865a3ae_2207220_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/2021/","title":"記 2021"},{"content":" English Chinese impede 妨礙 counteroffer 還債 distributer 經銷商 contingency plan 應急計劃 adjourn 體會 remorse 懊悔 dissension 意見不合 conform 遵照 criteria 標準 inferior 下級的 intended 未來的 cistern 儲水器 podium 講台 aggregate 集結 tackle 處理、交涉、抓住 compliance 遵行、承諾 transcend 勝過 out of stack 無現貨的 retial 零售 tailor 修改 consensual 一致同意的 liability 債務 impose 徵稅 mandatory 義務的 evasion 逃避 scrutinize 檢閱 reconcile 核對 audit 查帳 bounced check 空頭支票 deficit 赤字 recession 衰退 mortagage 抵押貸款 promissory note 本票 capitalization 資本額 commission 佣金 transaction 交易 triumph 獲得成功 accredit 授權 delegate 委派 jurisdiction 權力 configuration 框架 ascertain 確信 indispensable 不可或缺的 sidestep 迴避 subsidiary 隸屬的 franchiser 加盟授權者 concession 執照 detrimental 不利的 prestigious 有聲望的 recognition 表彰 unanimous 一致通過的 concur with 同 \u0026hellip; 一致 controversial 有爭議的 consent 同意 preside 主持 disputable 有爭議的 nonsensical 荒謬的 minutes 會議紀錄 concierge 管理員 courier 快遞員 epistle 訊息 alineated 不合群的 intangiable 無形的 amiable 友好的 aesthetics 美學 ergonomic 人體工學 pantry room 茶水間 reinforce 加深 streamline 使效率更高 complication 困難 stipulate 規定 drawn 疲憊的 salient 顯著的 commensurate 相稱的 expertise 專長 subsidize 補助 subsidy 補助金 absurd 不合理的 abundant 大量的 eloquent 有說服力的 lay off 解僱 dedicated 盡責的 freelancer 自由業者 despise 鄙視 compensate 賠償 reimburse 退款 perk 額外補助 industrious 勤勞的 merit 功績 resignation 辭職 abdicate 放棄 valedictory 告別的 severance pay 資遣費 boycutt 杯葛 preclude 阻止 protest 抗議 steppage 停工 strike 罷工 forestall 預先制止 lay out 解釋清楚 memorandum 備忘錄 hypnotize 著迷於 imminent 即將發生的 haggle 討價還價 amicable 友善的 obligatory 強制的 merchandise 商品 manifest 明顯的 dispatch 遞送 integral 不可缺的 spacious 寬敞的 amplify 增強 unveil 使公諸於眾 imminent 逼近的 apparatus 設備 gadget 裝置 aptitude 才能 evacuate 撤空 confined 不能外出的 ventialation 通風 procure 取得 succinct 簡明的 comply 依從 lease 租用 controversy 爭議 seclude 使隔離 imperative 迫切的 conversant 熟悉的 quote 報價 possesion 財產 takeover 收購 down payment 頭期款 flat 公寓 deductible 可扣除的 depreciation 貶值 lease 租約 tenant 房客 landload 房東 overhaul 檢修 appeal 上訴 civil 民事的 legitimate 合理的 litigation 訴訟 recreational 娛樂的 amenity 便利設施 aethetic 美感的 adorn 裝飾 entitle 給予權利 deluxe 豪華的 lecomotive 火車頭 peddle 叫賣 excursion 短程旅行 dispatch 派遣 dawdle 拖拖拉拉 articulated 鉸接式的 double-decker 雙層公車 voucher 票券 vessel 船 embark 上船 obligatory 必須的 ambience 情調 steward 管家 reluctant 不願意的 engage beforehand 預定 call off 取消 renowned 有名的 appetizing 開胃的 cater 承辦 lavish 奢華的 sumptuous 豪華的 cordial 友好的 diplomatic 圓滑的 solicitation 招攬 tender 遞交 attive 服裝 etiquette 禮儀 couteously 有禮貌的 modest 端莊的 scatterbrained 糊裡糊塗的 delicacy 美食 obsolete 淘汰的 broker 協商 sanitary 乾淨的 rehearse 排練 fragile 易碎的 prehistoric 史無前例的 curator 館長 effusive 十分熱情的 inaugural address 就職演說 enthuse 使感興趣 alleviate 減輕 physician 內科醫生 irritate 使疼痛 distraction 娛樂 practice 診所 prescription 處方 pertinent 相關的 surgeon 外科醫生 unequalled 出類拔萃的 recuperate 復原 depressnat 鎮定劑 tranquillizer 鎮定劑 jeopardize 危及 dispense 配藥 herbal 草木的 mishap 不幸事故 ","date":"2021-12-18T20:11:46+08:00","permalink":"https://luke2336.github.io/p/toeic1/","title":"TOEIC 單字準備"},{"content":" 中午在市區的大遠百吃飯。 下午去造橋爬口山步道。 回去後累到直接睡死，然後七點半才爬起來吃拉麵。 口山步道 從造橋國中旁的登山口上山，全長大約 40 分鐘，人不多的一條路線。 中間有一些小岔路，所以最好還是看著 OpenSteetMap 比較保險。 其他人都跟我走反方向，可能是我這個方向有不少下坡，覺得很陡，需要小心走。 可以看得到海邊和竹南市區，還有高速公路。 造橋車站 只有停區間車的無人車站。 有一些日治時代留下的宿舍。 ","date":"2021-12-04T20:55:15+08:00","image":"https://luke2336.github.io/p/zaoqiao/1_hu1bf2406b1e3aa6a624051cc30403a9bb_991082_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/zaoqiao/","title":"造橋 - 口山步道"},{"content":" 和高中同學約去陽明山爬山，九點半從劍潭站出發，要上山的人比想樣中多。 中午爬完山後在劍潭站附近吃了麵店，在公園散步，之後整個下午泡在路易莎聊天。 晚上去逛了士林夜市。 紗帽山 坐紅 5 到陽明山公車總站，然後從北面登山口爬到太子亭後折返，約爬了不到兩小時。 沿途遇到四隻鍬形蟲和兩隻石龍子。 步道只有接近山頂處沒有遮蔭，但風很大很涼爽，坡度算是滿陡的，戴著口罩爬滿喘的。 山頂可看到中山堂，及七星山和大屯山。 ","date":"2021-10-10T09:39:05+08:00","image":"https://luke2336.github.io/p/yang-ming/2_hudb20c743c286829e14d984623daaad96_4761224_120x120_fill_q75_box_smart1.JPG","permalink":"https://luke2336.github.io/p/yang-ming/","title":"紗帽山"},{"content":" 位於新竹新豐，靠近西濱。 從蓮花寺的入口上山，到觀景平台的咖啡店看夕陽後折返，下山跟著別人的路線走稜線，因此不到半小時就下山了，中途有看到碉堡。 有一些岔路，可能會需要先查好地圖再開始爬。 步道整理的不錯，但有些路段沒有石階，只有原始的石頭和沙地，走起來就會滑。今天全程幾乎都有遮蔭，因此不算太熱，風景也很不錯。 晚餐去了南寮新的市集，但人很多，消費也偏高。 ","date":"2021-10-02T13:32:08+08:00","image":"https://luke2336.github.io/p/xinfeng/2_hudb20c743c286829e14d984623daaad96_2463148_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/xinfeng/","title":"新豐 - 鳳崎落日登山步道"},{"content":"A - Disjoint Set Union 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7 8class UnionTree { 9private: 10 vector\u0026lt;int\u0026gt; par, sz; 11public: 12 UnionTree(int n) { 13 par.resize(n); 14 for (int i = 0; i \u0026lt; n; i++) { 15 par[i] = i; 16 } 17 sz.resize(n, 1); 18 } 19 int findPar(int x) { 20 return par[x] = (x == par[x] ? x : findPar(par[x])); 21 } 22 bool isSame(int a, int b) { 23 return findPar(a) == findPar(b); 24 } 25 void uni(int a, int b) { 26 if (isSame(a, b)) { 27 return; 28 } 29 a = par[a]; 30 b = par[b]; 31 if (sz[a] \u0026lt; sz[b]) { 32 swap(a, b); 33 } 34 sz[a] += sz[b]; 35 par[b] = a; 36 } 37}; 38 39int main() { 40 ios::sync_with_stdio(0), cin.tie(0); 41 int n, q; 42 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 43 UnionTree UT(n); 44 for (int i = 0; i \u0026lt; q; i++) { 45 int t, u, v; 46 cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; 47 if (t == 0) { 48 UT.uni(u, v); 49 } else { 50 cout \u0026lt;\u0026lt; UT.isSame(u, v) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 51 } 52 } 53 return 0; 54} B - Fenwick Tree 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7#define maxn 500005 8 9class RangeUpdateBIT { 10 private: 11 ll d[maxn], dd[maxn]; 12 ll sum(int i) { 13 ll s = 0, ss = 0; 14 int c = i + 1; 15 while (i \u0026gt; 0) s += d[i], ss += dd[i], i -= i \u0026amp; -i; 16 return c * s - ss; 17 } 18 void add(int i, ll v) { 19 int c = i; 20 while (i \u0026lt; maxn) 21 d[i] += v, dd[i] += c * v, i += i \u0026amp; -i; 22 } 23 public: 24 RangeUpdateBIT() { 25 memset(d, 0, sizeof(d)); 26 memset(dd, 0, sizeof(dd)); 27 } 28 ll sum(int l, int r) { return sum(r) - sum(l - 1); } 29 void add(int l, int r, ll v) { 30 add(l, v), add(r + 1, -v); 31 } 32}; 33 34int main() { 35 ios::sync_with_stdio(0), cin.tie(0); 36 int n, q; 37 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 38 RangeUpdateBIT BIT; 39 for (int i = 0; i \u0026lt; n; i++) { 40 int a; 41 cin \u0026gt;\u0026gt; a; 42 BIT.add(i + 1, i + 1, a); 43 } 44 for (int i = 0; i \u0026lt; q; i++) { 45 int t; 46 cin \u0026gt;\u0026gt; t;; 47 if (t == 0) { 48 int p, x; 49 cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; x; 50 BIT.add(p + 1, p + 1, x); 51 } else { 52 int l, r; 53 cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; 54 cout \u0026lt;\u0026lt; BIT.sum(l + 1, r) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 55 } 56 } 57 return 0; 58} D - Maxflow 參考：https://zenn.dev/wapa5pow/articles/practice2-d-d7592ec448c361102bb8。 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3#include \u0026lt;atcoder/all\u0026gt; 4using namespace std; 5using namespace atcoder; 6typedef long long ll; 7typedef pair\u0026lt;int, int\u0026gt; pii; 8#define pb push_back 9 10int main() { 11 ios::sync_with_stdio(0), cin.tie(0); 12 int n, m; 13 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 14 vector\u0026lt;string\u0026gt; input(n); 15 for (int i = 0; i \u0026lt; n; i++) { 16 cin \u0026gt;\u0026gt; input[i]; 17 } 18 mf_graph\u0026lt;int\u0026gt; G(n * m + 2); 19 int src = n * m; 20 int dst = src + 1; 21 const int dx[4] = {1, -1, 0, 0}; 22 const int dy[4] = {0, 0, 1, -1}; 23 for (int i = 0; i \u0026lt; n; i++) { 24 for (int j = 0; j \u0026lt; m; j++) { 25 if (input[i][j] == \u0026#39;#\u0026#39;) { 26 continue; 27 } 28 int id = i * m + j; 29 if ((i + j) \u0026amp; 1) { // white 30 G.add_edge(id, dst, 1); 31 } else { // black 32 G.add_edge(src, id, 1); 33 for (int di = 0; di \u0026lt; 4; di++) { 34 int ii = i + dx[di]; 35 int jj = j + dy[di]; 36 if (ii \u0026lt; 0 || ii \u0026gt;= n || 37 jj \u0026lt; 0 || jj \u0026gt;= m || 38 input[ii][jj] == \u0026#39;#\u0026#39;) { 39 continue; 40 } 41 int id2 = ii * m + jj; 42 G.add_edge(id, id2, 1); 43 } 44 } 45 } 46 } 47 auto output = input; 48 int max_flow = G.flow(src, dst); 49 for (auto e : G.edges()) { 50 if (e.from == src || e.to == dst || e.flow == 0) { 51 continue; 52 } 53 int x1 = e.from / m; 54 int x2 = e.to / m; 55 int y1 = e.from % m; 56 int y2 = e.to % m; 57 if (x1 == x2) { 58 if (y1 \u0026gt; y2) { 59 swap(y1, y2); 60 } 61 output[x1][y1] = \u0026#39;\u0026gt;\u0026#39;; 62 output[x2][y2] = \u0026#39;\u0026lt;\u0026#39;; 63 } else if (y1 == y2) { 64 if (x1 \u0026gt; x2) { 65 swap(x1, x2); 66 } 67 output[x1][y1] = \u0026#39;v\u0026#39;; 68 output[x2][y2] = \u0026#39;^\u0026#39;; 69 } 70 } 71 cout \u0026lt;\u0026lt; max_flow \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 72 for (int i = 0; i \u0026lt; n; i++) { 73 cout \u0026lt;\u0026lt; output[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 74 } 75 return 0; 76} E - MinCostFlow 參考：https://zenn.dev/wapa5pow/articles/practice2-e-e6ce54a9fd90bfb9afbc。 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3#include \u0026lt;atcoder/all\u0026gt; 4using namespace std; 5using namespace atcoder; 6typedef long long ll; 7typedef pair\u0026lt;int, int\u0026gt; pii; 8#define pb push_back 9 10int main() { 11 ios::sync_with_stdio(0), cin.tie(0); 12 int n, k; 13 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; 14 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; input(n, vector\u0026lt;int\u0026gt;(n)); 15 for (int i = 0; i \u0026lt; n; i++) { 16 for (int j = 0; j \u0026lt; n; j++) { 17 cin \u0026gt;\u0026gt; input[i][j]; 18 } 19 } 20 const int max_cap = 1000000009; 21 const int inf = 1000000009; 22 int src = 2 * n; 23 int snk = src + 1; 24 mcf_graph\u0026lt;int, ll\u0026gt; G(2 * n + 2); 25 for (int i = 0; i \u0026lt; n; i++) { 26 for (int j = 0; j \u0026lt; n; j++) { 27 G.add_edge(i, j + n, 1, max_cap - input[i][j]); 28 } 29 G.add_edge(src, i, k, 0); 30 G.add_edge(i + n, snk, k, 0); 31 } 32 G.add_edge(src, snk, inf, max_cap); 33 G.flow(src, snk, n * k); 34 vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; output(n, vector\u0026lt;char\u0026gt;(n, \u0026#39;.\u0026#39;)); 35 ll ans = 0; 36 for (auto e : G.edges()) { 37 if (e.from == src || e.to == snk || e.flow == 0) { 38 continue; 39 } 40 int i = e.from; 41 int j = e.to - n; 42 output[i][j] = \u0026#39;X\u0026#39;; 43 ans += max_cap - e.cost; 44 } 45 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 46 for (int i = 0; i \u0026lt; n; i++) { 47 for (int j = 0; j \u0026lt; n; j++) { 48 cout \u0026lt;\u0026lt; output[i][j]; 49 } 50 cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 51 } 52 return 0; 53} F - Convolution 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3#include \u0026lt;atcoder/all\u0026gt; 4using namespace std; 5using namespace atcoder; 6typedef long long ll; 7typedef pair\u0026lt;int, int\u0026gt; pii; 8#define pb push_back 9 10int main() { 11 ios::sync_with_stdio(0), cin.tie(0); 12 int N, M; 13 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; 14 vector\u0026lt;int\u0026gt; a(N), b(M); 15 for (int i = 0; i \u0026lt; N; i++) { 16 cin \u0026gt;\u0026gt; a[i]; 17 } 18 for (int i = 0; i \u0026lt; M; i++) { 19 cin \u0026gt;\u0026gt; b[i]; 20 } 21 auto c = convolution(a, b); 22 for (int i = 0; i \u0026lt; N + M - 1; i++) { 23 cout \u0026lt;\u0026lt; c[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == N + M - 2]; 24 } 25 return 0; 26} G - SCC 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3#include \u0026lt;atcoder/all\u0026gt; 4using namespace std; 5using namespace atcoder; 6typedef long long ll; 7typedef pair\u0026lt;int, int\u0026gt; pii; 8#define pb push_back 9 10int main() { 11 ios::sync_with_stdio(0), cin.tie(0); 12 int n, m; 13 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 14 scc_graph G(n); 15 for (int i = 0; i \u0026lt; m; i++) { 16 int a, b; 17 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 18 G.add_edge(a, b); 19 } 20 auto ans = G.scc(); 21 cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 22 for (auto v : ans) { 23 cout \u0026lt;\u0026lt; v.size(); 24 for (int i : v) { 25 cout \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; i; 26 } 27 cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 28 } 29 return 0; 30} H - Two SAT 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3#include \u0026lt;atcoder/all\u0026gt; 4using namespace std; 5using namespace atcoder; 6typedef long long ll; 7typedef pair\u0026lt;int, int\u0026gt; pii; 8#define pb push_back 9 10int main() { 11 ios::sync_with_stdio(0), cin.tie(0); 12 int n, d; 13 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d; 14 vector\u0026lt;int\u0026gt; a(n * 2); 15 two_sat ts(n * 2); 16 for (int i = 0; i \u0026lt; n; i++) { 17 cin \u0026gt;\u0026gt; a[i] \u0026gt;\u0026gt; a[i + n]; 18 ts.add_clause(i, 1, i + n, 1); 19 } 20 for (int i = 0; i \u0026lt; 2 * n; i++) { 21 for (int j = i + 1; j \u0026lt; 2 * n; j++) { 22 if (abs(a[i] - a[j]) \u0026lt; d) { 23 ts.add_clause(i, 0, j, 0); 24 } 25 } 26 } 27 bool sat = ts.satisfiable(); 28 if (sat) { 29 cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; 30 } else { 31 cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; 32 return 0; 33 } 34 auto ans = ts.answer(); 35 for (int i = 0; i \u0026lt; n; i++) { 36 if (ans[i]) { 37 cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 38 } else { 39 cout \u0026lt;\u0026lt; a[i + n] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 40 } 41 } 42 return 0; 43} ","date":"2021-09-20T10:03:41+08:00","permalink":"https://luke2336.github.io/p/atcoder-practice2/","title":"AtCoder Library Practice Contest"},{"content":"整體來說我都是在 WFH，只有在剛二級時回台北體驗 4 天的 Office 生活。我的 Team 的辦公室是在 101 的 73 樓，其他像是板橋和新店的實習生數量就比較多。\n期間認識了滿多人，有一部分是在國外留學，暑假在台灣實習的朋友，有一部分是台大的朋友，當然清交也有少部分的人，剛好自己的學妹和直屬學姊都有申請上。STEP 女生收得滿多的，於是有時候就會遠端一起聊天，互相認識。比較有趣的是，台灣的 Intern 在中間自己辦了一次互相認識的活動。不然今年遠端，intern 們就比較沒機會了解互相的 project。\n如果不是明年要畢業了，真的很希望能有機會實體 intern 一次。\n申請 請看這篇。 時間 20210621～20210910。 每週五天，每天八小時，但其實時間很彈性，不用像某些公司還得打卡。 每個人的時間大約都是 12 週以上，時間是配合放暑假和開學的時間自己決定的。 內容 每個人都會分到一個 host 跟一個 co-host，然後會 weekly 或 biweekly 開會。 我的 project 大致上是用 Python 寫 unit test 相關的東西。 有機會參與到 Team 裡的會議，但印象中不是強制的。 內部有各種課程影片或演講，都可以自由觀看和參加。 除了自己 Team 內的會議，大部分的活動都是用英文進行。 比較喜歡的部分是，Google 內部有很多短網址可以使用，也有自己內部的 search engine。 幾乎可以看到內部大部分的 code，有一套還不錯用的 code review 系統，對 code review 也很講究。 midpoint 和 final 各有一次自我評量，還有 host 的評價，也會開會討論進度，覺得是很有幫助的制度，會讓自己知道哪裡還需要改善。 最後結束的時候會有一次 presentation 的機會。 自我成長 覺得體驗了 Software Engineer 的生活，讓我能更清楚的考慮自己未來升學和就業的方向。有機會和內部的工程師聊天，讓我多了一些新的價值觀，也漸漸學會要如何調適工作和生活。 對 Python 和 Git 等工具變得比較熟悉，原本真的有點像一張白紙，只能說自己平常技能樹點得太 Theoretical 了。整體來說，碰到了不少偏底層的東西，體會到為什麼學校的基礎課程有演算法、計算機組織、作業系統等等了。 了解 Design Doc. 該長怎樣，看了很多 Doc 後覺得進步很多，覺得以後自己寫 side project 時也可以做類似的紀錄。 福利 優渥的薪水，具體數字沒辦法說，據說 SWE intern 比 STEP 高薪。 有租屋補助，所以我認為不管是不是北部人都可以來體驗。 進辦公室後，有早午餐吃，還有很棒的零食區，還可以每天練習拉花。 有轉正的機會，但主要是看 project 的結果和 host 的評價。 ","date":"2021-09-10T13:18:58+08:00","image":"https://luke2336.github.io/p/google-intern/scene_hue598731da4e1f8be7e3ab0e756d75f91_1460097_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/google-intern/","title":"Google Intern Experience"},{"content":"AtCoder Beginning Contest 216 A. Signed Difficulty 1#pragma GCC optimization(\u0026#34;O3\u0026#34;) 2#include \u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7int main() 8{ 9 ios::sync_with_stdio(0), cin.tie(0); 10 int X, Y; 11 char c; 12 cin \u0026gt;\u0026gt; X \u0026gt;\u0026gt; c \u0026gt;\u0026gt; Y; 13 if (Y \u0026lt;= 2) 14 cout \u0026lt;\u0026lt; X \u0026lt;\u0026lt; \u0026#34;-\\n\u0026#34;; 15 else if (Y \u0026lt;= 6) 16 cout \u0026lt;\u0026lt; X \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 17 else 18 cout \u0026lt;\u0026lt; X \u0026lt;\u0026lt; \u0026#34;+\\n\u0026#34;; 19 return 0; 20} B. Same Name 1#pragma GCC optimization(\u0026#34;O3\u0026#34;) 2#include \u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7typedef pair\u0026lt;string, string\u0026gt; pss; 8int main() 9{ 10 ios::sync_with_stdio(0), cin.tie(0); 11 int n; 12 cin \u0026gt;\u0026gt; n; 13 vector\u0026lt;pss\u0026gt; v(n); 14 for (int i = 0; i \u0026lt; n; i++) 15 cin \u0026gt;\u0026gt; v[i].first \u0026gt;\u0026gt; v[i].second; 16 sort(v.begin(), v.end()); 17 bool same = false; 18 for (int i = 1; i \u0026lt; n; i++) 19 if (v[i] == v[i - 1]) 20 same = true; 21 if (same) 22 cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; 23 else 24 cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; 25 return 0; 26} C. Many Balls 1#pragma GCC optimization(\u0026#34;O3\u0026#34;) 2#include \u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7int main() 8{ 9 ios::sync_with_stdio(0), cin.tie(0); 10 ll n; 11 cin \u0026gt;\u0026gt; n; 12 string ans = \u0026#34;\u0026#34;; 13 while (n) 14 { 15 if (n % 2 == 1) 16 ans = \u0026#34;A\u0026#34; + ans, n--; 17 else 18 ans = \u0026#34;B\u0026#34; + ans, n \u0026gt;\u0026gt;= 1; 19 } 20 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 21 return 0; 22} D. Pair of Balls 建圖後做拓樸排序。\n1#pragma GCC optimization(\u0026#34;O3\u0026#34;) 2#include \u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6#define pb push_back 7int main() 8{ 9 ios::sync_with_stdio(0), cin.tie(0); 10 int n, m; 11 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 12 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; v(m); 13 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G(n + 1); 14 vector\u0026lt;int\u0026gt; deg(n + 1); 15 for (int i = 0; i \u0026lt; m; i++) 16 { 17 int k; 18 cin \u0026gt;\u0026gt; k; 19 v[i].resize(k); 20 for (int j = 0; j \u0026lt; k; j++) 21 cin \u0026gt;\u0026gt; v[i][j]; 22 for (int j = 1; j \u0026lt; k; j++) 23 G[v[i][j - 1]].pb(v[i][j]), deg[v[i][j]]++; 24 } 25 queue\u0026lt;int\u0026gt; q; 26 for (int i = 1; i \u0026lt;= n; i++) 27 if (deg[i] == 0) 28 q.push(i); 29 while (!q.empty()) 30 { 31 int u = q.front(); 32 q.pop(); 33 for (int uu : G[u]) 34 { 35 deg[uu]--; 36 if (deg[uu] == 0) 37 q.push(uu); 38 } 39 } 40 for (int i = 1; i \u0026lt;= n; i++) 41 if (deg[i]) 42 { 43 cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; 44 return 0; 45 } 46 cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; 47 return 0; 48} F. Max Sum Counting 排序後做背包 DP。\n1#pragma GCC optimization(\u0026#34;O3\u0026#34;) 2#pragma GCC optimization(\u0026#34;O3\u0026#34;) 3#include \u0026lt;bits/stdc++.h\u0026gt; 4using namespace std; 5typedef long long ll; 6typedef pair\u0026lt;int, int\u0026gt; pii; 7#define pb push_back 8const ll mod = 998244353; 9int main() 10{ 11 ios::sync_with_stdio(0), cin.tie(0); 12 int n; 13 cin \u0026gt;\u0026gt; n; 14 vector\u0026lt;pii\u0026gt; v(n); 15 for (int i = 0; i \u0026lt; n; i++) 16 cin \u0026gt;\u0026gt; v[i].first; 17 for (int i = 0; i \u0026lt; n; i++) 18 cin \u0026gt;\u0026gt; v[i].second; 19 sort(v.begin(), v.end()); 20 vector\u0026lt;ll\u0026gt; dp[2]; 21 dp[0].resize(5001); 22 dp[1].resize(5001); 23 dp[0][0] = 1; 24 ll ans = 0; 25 for (int i = 0; i \u0026lt; n; i++) 26 { 27 for (int j = 5000; j \u0026gt;= v[i].second; j--) 28 { 29 int a = dp[0][j] + dp[1][j]; 30 int b = dp[1][j - v[i].second] + dp[0][j - v[i].second]; 31 dp[0][j] = a % mod; 32 dp[1][j] = b % mod; 33 if (j \u0026lt;= v[i].first) 34 ans = (ans + dp[1][j]) % mod; 35 } 36 } 37 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 38 return 0; 39} ","date":"2021-08-29T21:51:11+08:00","image":"https://luke2336.github.io/p/atcoder_abc216/1_hue0f350596d5060d89dae33b22b720a50_72094_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/atcoder_abc216/","title":"AtCoder Beginning Contest 216"},{"content":"原因 因為不想修原系的電子學和電子實驗。 在三上時決定要轉系，三下就修資工的課為主。 看到下一屆的修業規定較適合自己，不用修計網概、編譯器、微處理機等等，於是決定降轉。 自己的成績滿足提畢需求，因此降轉不影響畢業。 準備 上機考前三名。 平均成績高於 85 分，系排 25~50%。 自傳及動機著重在自己不適合原系，強調自己能準時畢業（差 4 門專業選修即符合畢業標準）。 有利資料為選出自己專業科目的優異成績及演算法競賽成績。 審查標準 轉系名額上限為教育部核定名額的兩成 第一志願必須為資工系，操行須在82分以上。 申請文件 歷年成績單（含排名） 自傳及轉系動機說明（兩頁內） 其他有利審查之資料 就學業成績、上機考成績、重點科目（如：計算機概論、基礎程式設計、微積分等）與課外競賽表現擇優錄取。 心得 這屆資工和電機收的名額都很多，但建議還是要將專業科目修到 80 分以上，且上機考有基本的分數，證明自己能適應資工系。 因為原系有選課權，所以才會已經修了很多課，不至於延畢。 等待的時間很焦慮，因為突然發現電機系不開英文班的電子學和實驗，於是無法用原系的修業規定畢業，需要提出申訴之類的手段。 ","date":"2021-08-21T20:31:26+08:00","permalink":"https://luke2336.github.io/p/transfer/","title":"交大資工轉系經驗"},{"content":" Floksiki 黃綠的配色很好看！ Momentum Plugin，每天會換一張風景照，覺得很有趣。 ","date":"2021-08-01T16:25:52+08:00","image":"https://luke2336.github.io/p/chromethemes/Theme_hu893a3f51b41f9cf2f2efe0684af4b83f_1605244_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/chromethemes/","title":"Chrome Themes 推薦"},{"content":"因為沒有找內推，所以整個過程非常漫長。因為 12 月在忙交換的申請，所以就直接拿上一個年度的履歷去投。原本等到 2 月沒下文，以為不會上了，但開學時卻突然收到面試通知。面試算是裸考，沒有準備，幸好是中文面試，兩場連續。因為第一場 HR 弄反連結，於是有點 Delay 到第二場，所以兩場都有點緊張，於是表現的並沒有很好。覺得自己去年面得比較好，但不幸因為疫情被取消。原本以為無望時，3 月底又接到 HR 的通知，說 4 月底開始 team match。之後超怕 match 不到 team，但這幾天終於接到通知了。福利比想像中高，因為疫情也可以選擇 remote 或 on-site，還有不少津貼。\n因為我完全沒有準備，所以沒辦法寫一篇「第一次面試就上手」。全都是靠打比賽的知識撐場，平常和隊友討論的習慣算是有稍微發揮到吧。\n謠傳說，履歷愈早丟，被面試到的機會愈高，後面的日程也比較不會被卡到。\n日程表 Date Status 2020/12/16 Invitation Mail 2020/12/17 Summit Resume 2021/02/23 Interview Information 2021/03/03 2 Online Interview 2021/03/11 Hiring Committee Information Form 2021/03/24 Hiring Committee Approved 2021/05/06 Team Match Result \u0026amp; Offer Get 需要的資料 English Resume 1 Page Transcript ","date":"2021-05-07T14:49:37+08:00","permalink":"https://luke2336.github.io/p/google-intern-apply/","title":"Google Internship Application"},{"content":" 以下是我寫的教育學概論期中報告，想說既然寫了，也順便放上來。\n這次作業有兩種選項，一種是寫參考書籍的閱讀報告，另一種是寫「我所關心的教育議題」，我選了後者撰寫。字數限制是 2000~2500 字，我寫了 2100 字。\n因為是通識報告，所以寫的時候並不想只針對自己的科系去舉例，但最後還是有點針對電機資訊相關科系。寫這份報告除了是作業以外，也是在認真思考為什麼現在的制度，大部分的人都有所抱怨。\n這個標題是參考之前網路新聞的標題。\n大學是不是職業訓練所？ 在資工系，我常常聽到同學們抱怨說，「線性代數、微積分、自動機語言等數學課對於未來沒有太大的幫助」「作業都是手寫證明導致就業時都拿不出像樣的作品集」「讀大學只是為了學歷，平常應該多接 case和做 side project，不應該把時間花在考試和寫作業」。這些言論讓我開始思考了一個問題「工程學院只是為了培養業界需要的工程師嗎？」而這個問題可以延伸到「大學是不是職業訓練所？」以及「大學能不能作為職業訓練所？」\n如果以政治學的角度來看，「大學等同職業訓練所」誰可以獲利，很明顯的，業界能將訓練員工的成本轉嫁到所有納稅人身上，也能更方便的挑選需要的員工；而利益損失的則有學界以及想往學界發展的學生。由這個角度，我想探討究竟是什麼原因讓台灣的大學漸漸變得像職業訓練所，還有我認為哪些是大學應提供的基本能力及大學的社會責任。\n首先，誰真正決定了大學的走向？我認為既不是政府，也不是企業家，而是填志願的學生。像是醫藥、電機、資工、法律等第一志願，都是學生們以就業後的薪水做考量做出的決定，像是數學、哲學、中文、社會學等系，則基於出路的原因較不受歡迎，由此可見，多數人認為大學的科系和未來就業的選擇高度相關。\n再者，為什麼高等教育無法和技職教育獨立並行呢？我認為這受到台灣的社會觀念影響，受過大學、碩士教育的薪水普遍較高，導致多數人認為唸大學是必須的。當大學生們普遍為了文憑而唸大學時，大學就需要去最大化所有大學生的利益，也就是它需要去維護文憑的價值。文憑價值的評量又牽扯到了企業對於那間大學人才的評量，因此最後導致大學需要培養企業需要的人才。\n我認為這會導致一些嚴重的教育議題，大學的課程都是為了培養企業所需的人才而設計的，而不是為了讓學生有獨立思考、發現問題、解決問題等能力，那再過幾代，是不是研究會漸漸枯竭，技術會達到極限，或是沒有足夠多的人才被培養成能傳播知識的人。那假設產業結構出現變化，其他產業興起，過去培養的人是不是都無能去跟上時代呢？\n除此之外，我常聽到同學們抱怨說「學校在教的技術早就退流行了，完全派不上用場」。是的，假若學校都是在教技術，而不是創造技術的基本功或是基礎推理能力，學生們無法舉一反三，那他們學到的知識就永遠停留在他們的二十歲，但他們的下半輩子顯然不能只靠那些知識生活，因此培養自學能力是必須的，像是如何尋找需要的資料，如何檢驗資料的正確性，如何將已經會的知識應用在遇到的問題上，這些都是我認為大學應該培養的技能。\n綜合以上幾點後，我們可以思考，對於只渴望學習就業相關技術的人，大學能帶給他哪些文憑以外的收穫，是否能透過在業界的實務經驗來達到更有效率的學習。以下，我想說明大學其實並不是一個好的職業訓練環境。\n仔細檢視我們的大學制度，假設要四年畢業，一個學期需要修 16 學分，而對於每一個學分，上課、複習、寫作業的時間，平均需要花三小時，再加上體育課或導師時間等零學分的課程，少說一週要花 50 小時上課和讀書，也就是平均一天要花到 8 小時。但請注意到，以上僅僅是完成基本的教師要求，也就是根本就沒有多餘的時間，去針對自己有興趣的部分深入的研究。因此，期待大學生有自主學習甚至研究的能力，其實是不可能的。另外，以大學部的課程來說，扣掉加退選、考試，一門三學分的課，實際一學期也就 45 小時，是無法培養學生的實務能力的。舉例來說，以程式設計課程為例，教師往往是出作業，然後讓學生回去做，然後交完作業後，並不會告訴學生可以怎樣改進等等。反之，在業界，員工只需要專研他負責的部分，而能體驗完整去將一個主題做到最優的情況，不是像在學校裡，必須去最大化所有科目的分數總和，而犧牲了試著去將學習做到最好的機會。在業界，實務的成果也是會受到客戶較多檢驗及要求的，能實際理解怎樣的能力是業界真正需要的。\n總結上段所敘述的幾點，我認為大學中的學習，對於只是想要在業界生存的人其實是沒效率的，他想在大學中獲得的技術，在業界能更有效率地取得並檢驗學習成果。因此，這些人與其抱怨，xx課是他們未來工作不需要學習的，不如說，他們對大學本身的期待是不切實際的，大學不應該被期待是個好的職業訓練所。\n最後，我想提出幾點在大學制度中，受到「職業訓練」這個概念影響的缺陷。首先，我認為「必修學分」這個制度其實是可以被討論的，當我詢問系上教授我們為何需要修必修時，他給我的回應是，xx系畢業的學生應該得學會這些。其實，反過來想，為什麼我們是強制規定學生要會這些東西，而不是讓他們去探索他們想要的生涯規劃中，他們需要哪些能力，需要如何安排自己的學習。第二點，很多科系設定「實習」為必修學分，我認為這個本意是好的，但實務上並沒有好的配套措施，像是實習生為了學分被資方剝削的新聞層出不窮，實際上沒得到學習，而只是被當作廉價勞力的新聞層出不窮。\n總結我對大學與職業教育的看法，我認為大部分的大學科系不應該和職業訓練綁定，大學應該是教導學生學習的能力，由企業給予員工職業的訓練，這樣能讓人們獲得更有效率的學習，也不會被一些東拼西湊的政策影響，造成不管是想走學術或是想去業界的學生，都被強迫學習自己無興趣的東西，或是無時間學習自己更有興趣的東西，讓課堂的學習品質上升，使得教育資源能得發揮最大效益。\n","date":"2021-04-14T19:25:34+08:00","image":"https://luke2336.github.io/p/pedagogy-report/nctu_hub3ee5bfc79d1e1998b33e0ae68963b0e_45413_120x120_fill_box_smart1.gif","permalink":"https://luke2336.github.io/p/pedagogy-report/","title":"大學是不是職業訓練所？"},{"content":"\n","date":"2021-04-02T11:43:34+08:00","image":"https://luke2336.github.io/p/fl5/Note_ch5_1_hu7884cf915aa86e1fa464391c0fadef92_7094435_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/fl5/","title":"正規語言 Lec 5 筆記"},{"content":" 難解問題課的一個演算法，覺得滿喜歡的。 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3void heaps(int k, vector\u0026lt;int\u0026gt; \u0026amp;s, int n) { 4 if (k == 1) { 5 for (int i = 0; i \u0026lt; n; i++) 6 cout \u0026lt;\u0026lt; s[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == n - 1]; 7 return; 8 } 9 for (int i = 0; i \u0026lt; k - 1; ++i) { 10 heaps(k - 1, s, n); 11 if (k \u0026amp; 1) swap(s[i], s[k - 1]); 12 else swap(s[0], s[k - 1]); 13 } 14 heaps(k - 1, s, n); 15} 16void permutation(int n) { 17 vector\u0026lt;int\u0026gt; v(n); 18 for (int i = 0; i \u0026lt; n; i++) v[i] = i; 19 heaps(n, v, n); 20} 21int main() { 22 int n; cin \u0026gt;\u0026gt; n; 23 permutation(n); 24 return 0; 25} ","date":"2021-03-02T19:19:58+08:00","permalink":"https://luke2336.github.io/p/heaps_algorithm/","title":"Heap's Algorithm"},{"content":"AtCoder Beginning Contest 192 pD 被卡了很久，pF 沒靈感，只好掉分。\nA. Star $$O(1)$$\n1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 int x; cin \u0026gt;\u0026gt; x; 7 cout \u0026lt;\u0026lt; 100 - x % 100 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 8 return 0; 9} B. uNrEaDaBlE sTrInG $$O(|S|)$$\n1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 string s; 7 cin \u0026gt;\u0026gt; s; 8 int len = s.length(); 9 bool check = true; 10 for (int i = 0; i \u0026lt; len; i += 2) 11 if (isupper(s[i])) 12 check = false; 13 for (int i = 1; i \u0026lt; len; i += 2) 14 if (islower(s[i])) 15 check = false; 16 if (check) cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; 17 else cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; 18 return 0; 19} C. Kaprekar Number $$O(K \\log N)$$\n1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4#define pb push_back 5int f(int x) { 6 vector\u0026lt;int\u0026gt; v; 7 while (x) { 8 v.pb(x % 10); 9 x /= 10; 10 } 11 sort(v.begin(), v.end()); 12 int g1 = 0, g2 = 0; 13 for (int i = v.size() - 1; i \u0026gt;= 0; i--) 14 g1 = g1 * 10 + v[i]; 15 for (int i = 0; i \u0026lt; v.size(); i++) 16 g2 = g2 * 10 + v[i]; 17 return g1 - g2; 18} 19int main() { 20 ios::sync_with_stdio(0), cin.tie(0); 21 int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; 22 while (k--) n = f(n); 23 cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 24 return 0; 25} D. Base n 因為 int64 裝不下，就直接開 python 寫了，下次應該會用 __int128_t。 解法：二分搜，但 X 長度為 1 的時候要特判。 被卡了很久，這場的大敗筆 QAQ $$O(|X| \\log M)$$\n1s = input() 2m = int(input()) 3d = 0 4for c in s: 5 d = max(d, int(c)) 6low = d + 1 7high = 1000000000000000000 8ans = d 9if len(s) \u0026lt;= 1: 10 if int(s) \u0026lt;= m: 11 print(1) 12 else: 13 print(0) 14else: 15 while low \u0026lt;= high: 16 mid = (low + high) // 2 17 cnt = 0 18 for c in s: 19 cnt = cnt * mid + int(c) 20 if cnt \u0026lt;= m: 21 ans = mid 22 low = mid + 1 23 else: 24 high = mid - 1 25 print(ans - d) E. Train 解法：最短路徑 Dijkstra。 被 Long Long Int 卡了一下 QQ $$O(M \\log N)$$\n1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;ll, int\u0026gt; pii; 6#define pb push_back 7struct edge { 8 int to, t, k; 9 edge(int _to, int _t, int _k) { 10 to = _to, t = _t, k = _k; 11 } 12}; 13int main() { 14 ios::sync_with_stdio(0), cin.tie(0); 15 int n, m, x, y; 16 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; 17 vector\u0026lt;vector\u0026lt;edge\u0026gt; \u0026gt; G(n + 1); 18 for (int i = 0; i \u0026lt; m; i++) { 19 int a, b, t, k; 20 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; t \u0026gt;\u0026gt; k; 21 G[a].pb(edge(b, t, k)); 22 G[b].pb(edge(a, t, k)); 23 } 24 vector\u0026lt;ll\u0026gt; dis(n + 1, -1); 25 priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, greater\u0026lt;pii\u0026gt; \u0026gt; pq; 26 dis[x] = 0; 27 pq.push({dis[x], x}); 28 while (!pq.empty()) { 29 int u = pq.top().second; pq.pop(); 30 if (u == y) break; 31 for (edge e : G[u]) { 32 ll time = dis[u]; 33 if (time % e.k) time += e.k - time % e.k; 34 if (dis[e.to] == -1 || dis[e.to] \u0026gt; time + e.t) { 35 dis[e.to] = time + e.t; 36 pq.push({dis[e.to], e.to}); 37 } 38 } 39 } 40 cout \u0026lt;\u0026lt; dis[y] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 41 return 0; 42} F. Potion 看了 Dreamoon 的講解才想到要怎麼設 DP 狀態，覺得這題是可想出來的難度。 題意：給定 N ≤ 100 個數字 ≤ 1e7，將 k 個數字融合的分數為他們的和，另外每天會增加 k，且只能在第 0 天融合。給定一個數字 1e9 ≤ X ≤ 1e18，問最少要多少天才能湊到剛好 X 的分數。 解法：對於每個 k 都求 DP[i][j] 以 i 個數字和模 j 的最大值。 $$O(N^4)$$\n1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4typedef long long ll; 5int main() { 6 ios::sync_with_stdio(0), cin.tie(0); 7 int n; 8 ll x; 9 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; 10 vector\u0026lt;int\u0026gt; a(n); 11 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 12 ll ans = x; 13 for (int k = 1; k \u0026lt;= n; k++) { 14 ll dp[100][100] = {}; 15 for (int x : a) { 16 for (int i = k; i \u0026gt;= 1; i--) { 17 for (int j = 0; j \u0026lt; k; j++) { 18 if (dp[i - 1][j] % k != j) continue; 19 if (!dp[i - 1][j] \u0026amp;\u0026amp; i \u0026gt; 1) continue; 20 int r = (j + x) % k; 21 dp[i][r] = max(dp[i][r], dp[i - 1][j] + x); 22 } 23 } 24 } 25 if (dp[k][x % k] \u0026amp;\u0026amp; (x - dp[k][x % k]) % k == 0) 26 ans = min(ans, (x - dp[k][x % k]) / k); 27 } 28 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 29 return 0; 30} ","date":"2021-02-20T21:11:32+08:00","image":"https://luke2336.github.io/p/atcoder_abc192/1_hu031e4b198f8c992baa3a9f6aaeba91cc_104593_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/atcoder_abc192/","title":"AtCoder Beginning Contest 192"},{"content":"很混亂的一年，所有的事情都受到疫情影響。\n國內事件 Date News 2020/01/06 蘇花改通車 2020/01/11 蔡英文當選總統 2020/01/24 陳時中擔任 CECC 指揮官 2020/01/31 北捷環狀線通車 2020/02/06 7 天 2 片口罩 2020/03/02 大學延後開學 2020/03/19 限制入境 2020/04/09 14 天 9 片口罩 2002/05/29 通姦除罪化釋憲 2002/05/31 敦南誠品熄燈 2020/06/06 罷免高雄市長韓國瑜、議長跳樓 2020/07/01 5G 2020/07/30 前總統李登輝過世 2020/08/28 宣布萊豬進口 2020/11/07 清大前校長劉炯朗過世 2020/12/12 中天關台 2020/12/12 北一女校慶聊天擺攤事件 2020/12/25 民法下修 18 歲成年三讀通過 2021/01/20 部桃事件 2021/02/01 陽明交大合校 2021/02/06 高雄市議員黃捷罷免案 2021/02/09 趙少康宣布代表國民黨參選總統 交大學聯會於罷韓時的「返鄉專車」具政治立場，我認為不妥。 2020 這波韓流令人感慨台灣新聞媒體的力量，媒體能造神，也能把一個人轟下台，台灣的民意主要還是靠媒體炒作，還有靠網民帶風向。 國外新聞 Date News 2019/12/30 李文亮對華南海鮮市場疫情發出警告 2020/01/08 烏航於伊朗空域解體 2020/01/22 武漢封城 2020/01/31 英國正式脫歐 2020/02/04 公主號停靠橫濱 2020/02/11 WHO 命名 Covid 19 2020/02/20 韓國新天地教會事件 2020/03/24 東京奧運宣布停辦 2020/04/05 英國女王發布演說 2020/04/16 日本發布緊急事態 2020/06/30 香港國安法正式生效 2020/08/04 黎巴嫩港口爆炸 2020/11/03 美國大選，拜登獲勝 2021/01/20 拜登就任 2021/01/27 華爾街 Gamestop 散戶事件 2021/02/01 緬甸政變 香港議題在台灣大選後就被國內媒體淡化。 美中衝突不斷擴大，華為等中國企業被封殺。 美國大選爭議很多。 ","date":"2021-02-10T19:01:18+08:00","image":"https://luke2336.github.io/p/news_2020/news_hufa7791a1468366d31a63b50f3da8e791_36231_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/news_2020/","title":"2020 簡記"},{"content":"ICPC 2020 Taipei 出了一題水母圖的同構，於是今天找了這題樹同構練習，採用括號字串的方法，而不是 Hashing。\n水母圖 對於環上每個點當 root 去生出樹字串。 串接起來後，用環狀字串的演算法去比較。 TIOJ 1214 - 樹論 之 樹同構測試 $$O(|G|^2 \\log \\Delta(G)) = O(n^2 \\log n)$$\nn ≤ 100。給定兩棵樹的邊，問他們是否同構 \u0026ldquo;isomorphic\u0026rdquo; 先 DFS 找出所有的樹重心（最多 2 個）。樹重心的定義為，最大子樹大小最小的點。 從重心開始做 DFS，將每個點用 () 表示，中間夾括入他所有子樹字串，將他們排序後加入。每次排序為度數個，所以總共需要排序 deg - 1 個，所有點加起來為 n 個，再乘上字串比較的複雜度 O(n)。 最後再將重心們的字串排序後串接，比較兩棵樹是否相同。 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4#define pb push_back 5int n; 6int dfs(int u, int p, int \u0026amp;mi, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;G, vector\u0026lt;int\u0026gt; \u0026amp;ret) { 7 int cnt = 0, mx = 0; 8 for (int uu : G[u]) { 9 if (uu == p) continue; 10 int r = dfs(uu, u, mi, G, ret); 11 mx = max(mx, r), cnt += r; 12 } 13 mx = max(mx, n - cnt - 1); 14 if (mx \u0026lt;= mi) { 15 if (mx \u0026lt; mi) ret.clear(), mi = mx; 16 ret.pb(u); 17 } 18 return cnt + 1; 19} 20vector\u0026lt;int\u0026gt; centroid(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;G) { 21 vector\u0026lt;int\u0026gt; ret; 22 int mi = n; 23 dfs(1, -1, mi, G, ret); 24 return ret; 25} 26string tree(int u, int p, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;G) { 27 string ret = \u0026#34;\u0026#34;; 28 vector\u0026lt;string\u0026gt; sub; 29 for (int uu : G[u]) 30 if (uu != p) sub.pb(tree(uu, u, G)); 31 sort(sub.begin(), sub.end()); 32 for (string s : sub) ret += s; 33 return \u0026#34;(\u0026#34; + ret + \u0026#34;)\u0026#34;; 34} 35string solve() { 36 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; G(n + 1); 37 for (int i = 1; i \u0026lt; n; i++) { 38 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 39 G[a].pb(b), G[b].pb(a); 40 } 41 vector\u0026lt;string\u0026gt; ans; 42 for (int u : centroid(G)) ans.pb(tree(u, -1, G)); 43 sort(ans.begin(), ans.end()); 44 string ret = \u0026#34;\u0026#34;; 45 for (string s : ans) ret += s; 46 return ret; 47} 48int main() { 49 ios::sync_with_stdio(0), cin.tie(0); 50 while (1) { 51 cin \u0026gt;\u0026gt; n; if (!n) break; 52 cout \u0026lt;\u0026lt; (solve() == solve() ? \u0026#34;Same\u0026#34; : \u0026#34;Different\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 53 } 54 return 0; 55} ","date":"2021-02-08T20:36:05+08:00","permalink":"https://luke2336.github.io/p/tioj1214/","title":"TIOJ 1214 樹同構"},{"content":"常用指令 command 用途 clear clear terminal window ls list directory content ls -a 將隱藏檔案也列出 cd change directory to home cd .. change directory to parent cd - change directory to last working directory cd / change directory to root pwd print working directory rm file_name remove file mkdir dir_name make directory rmdir dir_name remove directory rm -R dir_name remove the directory and all files in the directory cp -R A B 將 A 資料夾的東西全部複製到 B mv A dir_name 將 A 搬到資料夾 cat file_name 查看內容 grep text file_name 抓取內容 ","date":"2021-02-07T14:08:22+08:00","permalink":"https://luke2336.github.io/p/mac_cmd/","title":"MacOS Command Line Note"},{"content":"Codeforces 10 D. LCIS dp[i][j] 為 a[1\u0026hellip;i], b[1\u0026hellip;j] 結尾為 b[j] 的 LCIS 的長度。\n$$dp_{i, j} := \\begin{cases} \\max_{p \u0026lt; j, b_{p} \u0026lt; b_{j}} dp_{i - 1, p} + 1 \u0026amp;, a_{i} = b_{j} \\\\ dp_{i - 1, j} \u0026amp;, \\text{otherwise}. \\end{cases}$$\n複雜度：O(nm)，n, m 為兩序列長度。\n1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt; 3using namespace std; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 // INPUT 7 int L[2]; 8 vector\u0026lt;int\u0026gt; v[2]; 9 for (int i = 0; i \u0026lt; 2; i++) { 10 cin \u0026gt;\u0026gt; L[i]; 11 v[i].resize(L[i] + 1); 12 for (int j = 1; j \u0026lt;= L[i]; j++) 13 cin \u0026gt;\u0026gt; v[i][j]; 14 } 15 // LCIS 16 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(L[0] + 1, vector\u0026lt;int\u0026gt;(L[1] + 1)); 17 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; par(L[0] + 1, vector\u0026lt;int\u0026gt;(L[1] + 1)); 18 for (int i = 1; i \u0026lt;= L[0]; i++) { 19 int p = 0; 20 for (int j = 1; j \u0026lt;= L[1]; j++) { 21 if (v[0][i] == v[1][j]) { 22 dp[i][j] = dp[i - 1][p] + 1; 23 par[i][j] = p; 24 } else { 25 dp[i][j] = dp[i - 1][j]; 26 par[i][j] = j; 27 if (v[0][i] \u0026gt; v[1][j] \u0026amp;\u0026amp; 28 dp[i - 1][j] \u0026gt; dp[i - 1][p]) 29 p = j; 30 } 31 } 32 } 33 // BACKTRACKING 34 int p = 0; 35 for (int j = 1; j \u0026lt;= L[1]; j++) 36 if (dp[L[0]][p] \u0026lt; dp[L[0]][j]) 37 p = j; 38 vector\u0026lt;int\u0026gt; ans; 39 for (int i = L[0]; i \u0026gt; 0; i--) { 40 if (v[0][i] == v[1][p] \u0026amp;\u0026amp; p != par[i][p]) 41 ans.push_back(v[0][i]); 42 p = par[i][p]; 43 } 44 cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 45 for (int i = ans.size() - 1; i \u0026gt;= 0; i--) 46 cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[!i]; 47 return 0; 48} ","date":"2021-01-29T12:05:24+08:00","permalink":"https://luke2336.github.io/p/lcis/","title":"Longest Common Increasing Subsequence(LCIS)"},{"content":"AtCoder Beginners Selection 用 AtCoder 的水題來練習 Kotlin 的基礎語法。\nPracticeA - Welcome to AtCoder 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 4private fun readInts() = readStrings().map { it.toInt() } 5 6fun main() { 7 val a = readInt() 8 val(b, c) = readInts() 9 val s = readLn() 10 println(\u0026#34;${a + b + c} $s\u0026#34;) 11} ABC086A - Product 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 4private fun readInts() = readStrings().map { it.toInt() } 5 6fun main() { 7 val(a, b) = readInts() 8 println(if (a % 2 == 1 \u0026amp;\u0026amp; b % 2 == 1 ) \u0026#34;Odd\u0026#34; else \u0026#34;Even\u0026#34;) 9} ABC081A - Placing Marbles 1private fun readLn() = readLine()!! 2fun countOne(s: String) = s.filter {it == \u0026#39;1\u0026#39;}.count() 3 4fun main() { 5 println(countOne(readLn())) 6} ABC081B - Shift only 1import kotlin.math.* 2 3private fun readLn() = readLine()!! 4private fun readInt() = readLn().toInt() 5private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 6private fun readInts() = readStrings().map { it.toInt() } 7 8fun main() { 9 val n = readInt() 10 val A = readInts() 11 var ans = A[0] 12 for (x in A) { 13 var cnt = 0 14 var tmp = x 15 while (tmp % 2 == 0) { 16 tmp /= 2 17 cnt++ 18 } 19 ans = min(ans, cnt) 20 } 21 println(ans) 22} ABC087B - Coins 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3 4fun main() { 5 val A = readInt() 6 val B = readInt() 7 val C = readInt() 8 val X = readInt() 9 var ans = 0 10 for (i in 0..A) { 11 for (j in 0..B) { 12 val sum = i * 500 + j * 100 13 if (sum \u0026lt;= X \u0026amp;\u0026amp; (X - sum) \u0026lt;= C * 50) 14 ans++ 15 } 16 } 17 println(ans) 18} ABC083B - Some Sums 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 4private fun readInts() = readStrings().map { it.toInt() } 5 6fun main() { 7 val(N, A, B) = readInts() 8 var ans = 0 9 for (i in 1..N) { 10 var tmp = i 11 var cnt = 0 12 while (tmp \u0026gt; 0) { 13 cnt += tmp % 10 14 tmp /= 10 15 } 16 if (cnt in A..B) 17 ans += i 18 } 19 println(ans) 20} ABC088B - Card Game for Two 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 4private fun readInts() = readStrings().map { it.toInt() } 5 6fun main() { 7 val N = readInt() 8 var A = readInts() 9 var cnt = IntArray(105) {0} 10 for (i in 0..N-1) cnt[A[i]]++ 11 var ans = 0 12 var r = 1 13 for (i in 100 downTo 1) { 14 for (j in 1..cnt[i]) { 15 ans += r * i 16 r = -r 17 } 18 } 19 println(ans) 20} ABC085B - Kagami Mochi 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3 4fun main() { 5 val N = readInt() 6 var A = IntArray(101) {0} 7 var ans = 0 8 for (i in 1..N) { 9 val x = readInt() 10 if (A[x] == 0) { 11 ans++ 12 A[x] = 1 13 } 14 } 15 println(ans) 16} ABC085C - Otoshidama 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 4private fun readInts() = readStrings().map { it.toInt() } 5 6fun main() { 7 val(N, Y) = readInts() 8 for (i in 0..N) { 9 for (j in 0..(N - i)) { 10 val k = N - i - j 11 if (i * 10000 + j * 5000 + k * 1000 == Y) { 12 println(\u0026#34;$i $j $k\u0026#34;) 13 return 14 } 15 } 16 } 17 println(\u0026#34;-1 -1 -1\u0026#34;) 18} ABC049C - Daydream 1fun main() { 2 val D = listOf(\u0026#34;dream\u0026#34;, \u0026#34;dreamer\u0026#34;, \u0026#34;erase\u0026#34;, \u0026#34;eraser\u0026#34;) 3 val DL = listOf(5, 7, 5, 6) 4 val S = readLine()!! 5 val L = S.length 6 var DP = BooleanArray(L + 1) {false} 7 DP[0] = true 8 for (i in 1..L) { 9 for (j in 0..3) { 10 val l = i - DL[j] 11 if (l \u0026lt; 0) continue 12 if (DP[l] \u0026amp;\u0026amp; S.substring(l, i) == D[j]) { 13 DP[i] = true 14 break 15 } 16 } 17 } 18 println(if (DP[L]) \u0026#34;YES\u0026#34; else \u0026#34;NO\u0026#34;) 19} ABC086C - Traveling 1import kotlin.math.abs 2private fun readLn() = readLine()!! 3private fun readInt() = readLn().toInt() 4private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 5private fun readInts() = readStrings().map { it.toInt() } 6 7fun main() { 8 val N = readInt() 9 var t = 0 10 var x = 0 11 var y = 0 12 for (i in 1..N) { 13 val(nt, nx, ny) = readInts() 14 val d = abs(nx - x) + abs(ny - y) 15 val dt = nt - t 16 if (d \u0026gt; dt || (dt - d) % 2 != 0) { 17 println(\u0026#34;No\u0026#34;) 18 return 19 } 20 t = nt 21 x = nx 22 y = ny 23 } 24 println(\u0026#34;Yes\u0026#34;) 25} ","date":"2021-01-19T17:00:49+08:00","permalink":"https://luke2336.github.io/p/atcoder_abs/","title":"AtCoder Beginners Selection"},{"content":"清華踏青 天氣很好，於是就搭小紅巴出去走走。\n第二招待所 去二招吃印度料理，被老闆娘說很久沒看到我，今天生意相對比較好的樣子。\n梅園 第一次在梅花開的時候過去，上次去是秋天某次滿月和電資系羽的一個學長去夜遊。梅花開的很茂盛，賞花的人也絡繹不絕，剛剛在二招吃飯的一桌老人們也在這邊。有很多蜜蜂在採蜜，有一株有結了三顆梅子，看起來很好吃。\n相思湖 蝴蝶園 台積館 發現了一條蝴蝶園通往台積館的小徑，就從南大門走回交大，然後在石園發現了三隻五色鳥。之後買了蛋捲冰淇淋就回宿舍休息了。\n","date":"2021-01-15T10:34:07+08:00","image":"https://luke2336.github.io/p/plum/%E6%A2%85_huf87c3e5759bcbd66fce3c7eb4965cced_8217019_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/plum/","title":"清大梅園"},{"content":"因為 pA 卡住，所以慘慘的 QAQ\n掉了 31 分到 1685。\nAtCoder Regular Contest 111 A. Simple Math 2 題意 $$1 \\leq n \\leq 10^{18}, 1 \\leq m \\leq 10^4, \\text{find }\\lfloor \\frac{10^n}{m}\\rfloor \\mod m.$$\n解法 求 (10 ** n) % (m * m) // m。 紀錄餘數的循環節。 卡題原因： 忘記循環不一定從一開始。 用了 unordered_map 判斷餘數是否出現過導致 TLE，換成 array 就變很快了。 Code 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4#define pb push_back 5int s[100000008]; 6int main() { 7 ll n, m, mm; 8 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 9 mm = m * m; 10 ll r, d = 1; 11 vector\u0026lt;int\u0026gt; v; // 紀錄餘數 12 for (int i = 0; i \u0026lt;= n; i++) { 13 r = d % mm; 14 if (s[r] || (i \u0026amp;\u0026amp; r == v[0])) break; 15 s[r] = i; 16 v.pb(r); 17 d = r * 10; 18 } 19 if (n \u0026lt; v.size()) { 20 cout \u0026lt;\u0026lt; v[n] / m \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 21 return 0; 22 } 23 int t = s[r]; // 循環節起點 24 int id = t + (n - t) % (v.size() - t); 25 cout \u0026lt;\u0026lt; v[id] / m \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 26 return 0; 27} B. Reversible Cards 題意 給定 N 張卡（≤2e5），每張卡上正反面各有一個數字（1~4e5），讓你每張牌只能選擇一面，問最多有幾個相異數字？\n解法 建立一個 Source，給每張牌 cap = 1 的邊，然後每張牌建立到正反兩面的數字 cap = 1 到邊，每個數字建立到 Sink cap = 1 的邊，之後求最大流 max-flow 即為答案\n因為是二分圖，所以用 Dinic 複雜度約為 O(sqrt(V)E) ~ 2e8。\nCode 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define pb push_back 6#define inf 1e9 7#define maxn 200000 8#define maxk 400000 9class Dinic { 10 private: 11 struct edge { int d, r; ll c; }; 12 vector\u0026lt;vector\u0026lt;edge\u0026gt;\u0026gt; adj; vector\u0026lt;int\u0026gt; lv, ve; int n; 13 bool mklv(int s, int d) { 14 lv.assign(n, -1); lv[s] = 0; queue\u0026lt;int\u0026gt; q({s}); 15 while (!q.empty()) { 16 int v = q.front(); q.pop(); 17 for (auto\u0026amp; e : adj[v]) { 18 if (e.c == 0 || lv[e.d] != -1) continue; 19 lv[e.d] = lv[v] + 1, q.push(e.d); 20 } 21 } 22 return lv[d] \u0026gt; 0; 23 } 24 ll aug(int v, ll f, int d) { 25 if (v == d) return f; 26 for (; ve[v] \u0026lt; adj[v].size(); ve[v]++) { 27 auto\u0026amp; e = adj[v][ve[v]]; 28 if (lv[e.d] != lv[v] + 1 || !e.c) continue; 29 ll sent = aug(e.d, min(f, e.c), d); 30 if (sent \u0026gt; 0) { 31 e.c -= sent, adj[e.d][e.r].c += sent; 32 return sent; 33 } 34 } 35 return 0; 36 } 37 public: 38 Dinic(int n) : n(n + 1) { clear(); } 39 void clear() { adj.assign(n, {}); } 40 void add_edge(int src, int dst, ll cap) { 41 edge ss{dst, (int)adj[dst].size(), cap}; 42 edge dd{src, (int)adj[src].size(), 0}; 43 adj[src].push_back(ss), adj[dst].push_back(dd); 44 } 45 ll max_flow(int s, int d) { 46 ll ret = 0; 47 while (mklv(s, d)) { 48 ve.assign(n, 0); 49 while (ll f = aug(s, inf, d)) ret += f; 50 } 51 return ret; 52 } 53}; 54int main() { 55 ios::sync_with_stdio(0), cin.tie(0); 56 int n; cin \u0026gt;\u0026gt; n; 57 Dinic D(maxn + maxk + 2); 58 int dst = maxn + maxk + 1; 59 for (int i = 1; i \u0026lt;= n; i++) { 60 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 61 D.add_edge(0, i, 1); 62 D.add_edge(i, maxn + a, 1); 63 D.add_edge(i, maxn + b, 1); 64 } 65 for (int i = 1; i \u0026lt;= maxk; i++) 66 D.add_edge(maxn + i, dst, 1); 67 cout \u0026lt;\u0026lt; D.max_flow(0, dst) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 68 return 0; 69} ","date":"2021-01-09T22:03:11+08:00","image":"https://luke2336.github.io/p/atcoder_arc111/Task_hub011ebed9f9067cad07b468f76d582b6_109523_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/atcoder_arc111/","title":"AtCoder Regular Contest 111"},{"content":"AtCoder Educational DP Contest [於 Feb, 2020 完成]\n這套從簡到難的 DP 題組，有不少經典題，很適合照順序刷。 開始刷了之後，才發現自己實力的不足，有幾題想了很久還是想不出來，只好去翻別人的解答。刷完發現 code 都不長，狀態也不難列，但轉移式都要想很久。\nA. Frog 1 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); 5 int dp[2] = {}, a[2] = {}; 6 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[1], \u0026amp;a[0]); 7 dp[0] = abs(a[1] - a[0]); 8 for (int i = 3; i \u0026lt;= N; i++) { 9 int x; scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); 10 dp[i % 2] = min(dp[i % 2] + abs(x - a[i % 2]), 11 dp[(i + 1) % 2] + abs(x - a[(i + 1) % 2])); 12 a[i % 2] = x; 13 } 14 printf(\u0026#34;%d\\n\u0026#34;, dp[N % 2]); 15 return 0; 16} B. Frog 2 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxn 100005 4int main() { 5 int n, k; 6 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); 7 int a[maxn], dp[maxn]; 8 for (int i = 1; i \u0026lt;= n; i++) 9 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 10 for (int i = 1; i \u0026lt;= n; i++) { 11 if (i \u0026lt;= k) dp[i] = abs(a[i] - a[1]); 12 else { 13 dp[i] = dp[i - 1] + abs(a[i] - a[i - 1]); 14 for (int j = 2; j \u0026lt;= k; j++) 15 dp[i] = min(dp[i], 16 dp[i - j] + abs(a[i] - a[i - j])); 17 } 18 } 19 printf(\u0026#34;%d\\n\u0026#34;, dp[n]); 20 return 0; 21} C. Vacation 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 5 int dp[2][3] = {}; 6 for (int i = 1; i \u0026lt;= n; i++) 7 for (int j = 0; j \u0026lt; 3; j++) { 8 int x; scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); 9 dp[i % 2][j] = x + max(dp[(i + 1) % 2][(j + 1) % 3], 10 dp[(i + 1) % 2][(j + 2) % 3]); 11 } 12 printf(\u0026#34;%d\\n\u0026#34;, max(dp[n % 2][0], 13 max(dp[n % 2][1], dp[n % 2][2]))); 14 return 0; 15} D. Knapsack 1 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxW 100005 4int main() { 5 int n, W; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;W); 6 long long dp[maxW] = {}; 7 for(int i = 0; i \u0026lt; n; i++) { 8 int w, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); 9 for(int j = W; j \u0026gt;= w; j--) 10 dp[j] = max(dp[j], dp[j - w] + v); 11 } 12 printf(\u0026#34;%lld\\n\u0026#34;, dp[W]); 13 return 0; 14} E. Knapsack 2 dp[j] 為價值為 j 需要的物品最低重量。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int n, W; 5 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;W); 6 int dp[100005] = {}; 7 for (int i = 1; i \u0026lt; 100005; i++) 8 dp[i] = 1000000005; 9 for (int i = 0; i \u0026lt; n; i++) { 10 int v, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); 11 for(int j = 100000; j \u0026gt;= v; j--) 12 dp[j] = min(dp[j], dp[j-v] + w); 13 } 14 for (int i = 100000; i \u0026gt;= 0; i--) 15 if (dp[i] \u0026lt;= W) { 16 printf(\u0026#34;%d\\n\u0026#34;, i); 17 break; 18 } 19 return 0; 20} F. LCS 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int dp[3005][3005]; 4int p[3005][3005]; 5int main() { 6 ios_base::sync_with_stdio(0), cin.tie(0); 7 string s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; 8 int lens = s.length(), lent = t.length(); 9 for (int i = 1; i \u0026lt;= lens; i++) { 10 for (int j = 1; j \u0026lt;= lent; j++) { 11 if (s[i - 1] == t[j - 1]) { 12 dp[i][j] = dp[i - 1][j - 1] + 1; 13 p[i][j] = 1; 14 } else if (dp[i][j - 1] \u0026gt; dp[i - 1][j]) { 15 dp[i][j] = dp[i][j - 1]; 16 p[i][j] = 2; 17 } else { 18 dp[i][j] = dp[i - 1][j]; 19 p[i][j] = 3; 20 } 21 } 22 } 23 string ans = \u0026#34;\u0026#34;; 24 int ni = lens, nj = lent; 25 while (ni \u0026amp;\u0026amp; nj) { 26 if (p[ni][nj] == 1) { 27 ans = s[ni - 1] + ans; 28 ni--, nj--; 29 } else if (p[ni][nj] == 2) nj--; 30 else ni--; 31 } 32 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 33 return 0; 34} G. Longest Path 類似拓樸排序的方式在 DAG（有向無環圖）上做 dp。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxn 100005 4int main() { 5 int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); 6 int in[maxn] = {}, dp[maxn] = {}; 7 vector\u0026lt;int\u0026gt; e[maxn]; 8 for (int i = 0; i \u0026lt; m; i++) { 9 int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); 10 e[a].push_back(b); 11 in[b]++; 12 } 13 queue\u0026lt;int\u0026gt; q; 14 for (int i = 1; i \u0026lt;= n; i++) 15 if (!in[i]) q.push(i); 16 while (!q.empty()) { 17 int u = q.front(); q.pop(); 18 for (int uu: e[u]) { 19 in[uu]--; 20 dp[uu] = max(dp[uu], dp[u] + 1); 21 if (!in[uu]) q.push(uu); 22 } 23 } 24 int ans = 0; 25 for (int i = 1; i \u0026lt;= n; i++) 26 ans = max(ans, dp[i]); 27 printf(\u0026#34;%d\\n\u0026#34;, ans); 28 return 0; 29} H. Grid 1 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define mod 1000000007 4int main() { 5 int h, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;h, \u0026amp;w); 6 int dp[1005] = {}; 7 char c[1005]; 8 for (int i = 1; i \u0026lt;= h; i++) { 9 scanf(\u0026#34;%s\u0026#34;, c + 1); 10 for (int j = 1; j \u0026lt;= w; j++) 11 if (c[j] == \u0026#39;#\u0026#39;) dp[j] = 0; 12 else if (i == 1 \u0026amp;\u0026amp; j == 1) dp[j] = 1; 13 else dp[j] = (dp[j] + dp[j - 1]) % mod; 14 } 15 printf(\u0026#34;%d\\n\u0026#34;, dp[w]); 16 return 0; 17} I. Coins 機率的 dp，所以難得用到 double。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxn 3000 4int main() { 5 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 6 double dp[maxn] = {1.0}; 7 for (int i = 1; i \u0026lt;= n; i++) { 8 double p; scanf(\u0026#34;%lf\u0026#34;, \u0026amp;p); 9 for (int j = min(i, n / 2); j \u0026gt; 0; j--) 10 dp[j] = dp[j] * (1 - p) + dp[j - 1] * p; 11 dp[0] = dp[0] * (1 - p); 12 } 13 double ans = 1; 14 for(int i = 0; i \u0026lt;= n / 2; i++) 15 ans -= dp[i]; 16 printf(\u0026#34;%.9f\\n\u0026#34;, ans); 17 return 0; 18} J. Sushi i 為剩 3 個，j 為剩 2 個，k 為剩 1 個的盤子數量。\n$$DP_{i,j,k} = 1 + \\frac{(n-i-j-k) DP_{i,j,k} + i DP_{i-1,j+1,k} + j DP_{i,j-1,k+1} + k DP_{i,j,k-1}}{n}$$\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxn 305 4double dp[maxn][maxn][maxn]; 5inline double dfs(int i, int j, int k, int n) { 6 if(i \u0026lt; 0 || j \u0026lt; 0 || k \u0026lt; 0) return 0; 7 if (dp[i][j][k] \u0026gt; -1) return dp[i][j][k]; 8 return dp[i][j][k] = (i * dfs(i - 1, j + 1, k, n) + 9 j * dfs(i, j - 1, k + 1, n) + 10 k * dfs(i, j, k - 1, n) + 11 n) / (i + j + k); 12} 13int main() { 14 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 15 int cnt[4] = {}; 16 for (int i = 0; i \u0026lt; n; i++) { 17 int x; cin \u0026gt;\u0026gt; x; 18 cnt[x]++; 19 } 20 for (int i = 0; i \u0026lt;= n; i++) 21 for (int j = 0; j \u0026lt;= n; j++) 22 for (int k = 0; k \u0026lt;= n; k++) 23 dp[i][j][k] = -10; 24 dp[0][0][0] = 0; 25 printf(\u0026#34;%.9f\\n\u0026#34;, dfs(cnt[3], cnt[2], cnt[1], n)); 26 return 0; 27} K. Stones 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxn 105 4#define maxk 100005 5int main() { 6 int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); 7 int a[maxn]; 8 bool dp[maxk] = {0}; 9 for (int i = 0; i \u0026lt; n; i++) 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 11 for (int i = 0; i \u0026lt;= k; i++) 12 if(!dp[i]) 13 for (int j = 0; j \u0026lt; n; j++) 14 if(i + a[j] \u0026lt;= k) 15 dp[i + a[j]] = true; 16 if (dp[k]) printf(\u0026#34;First\\n\u0026#34;); 17 else printf(\u0026#34;Second\\n\u0026#34;); 18 return 0; 19} L. Deque 第一次遇到這題是在 2019NCPC，當時思考了很久能不能 Greedy，後來才想到是 0-sum game。於是用了 minimax 的概念，設計出狀態。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long LL; 4int main() { 5 ios_base::sync_with_stdio(0), cin.tie(0); 6 int n; cin \u0026gt;\u0026gt; n; 7 vector\u0026lt;LL\u0026gt; v(n+2); 8 for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; v[i]; 9 vector\u0026lt;vector\u0026lt;LL\u0026gt; \u0026gt; dp(n + 2, vector\u0026lt;LL\u0026gt;(n + 2,0)); 10 for (int len = 1; len \u0026lt;= n; len++) 11 for (int i = 1, j = len; j \u0026lt;= n; i++, j++) 12 if(len % 2 == n % 2) 13 dp[i][j] = max(dp[i + 1][j] + v[i], 14 dp[i][j - 1] + v[j]); 15 else 16 dp[i][j] = min(dp[i + 1][j] - v[i], 17 dp[i][j - 1] - v[j]); 18 cout \u0026lt;\u0026lt; dp[1][n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 19 return 0; 20} M. Candies dp[i][j] 發到第 i 人剩下 j 顆糖的方法數，用滾動優化空間複雜度。\ndp[i][j] = dp[i-1][j] + \u0026hellip; + dp[i-1][j+a[i]]。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxk 100005 4#define maxn 105 5#define mod 1000000007 6int main() { 7 int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); 8 int a[maxn], dp[2][maxk]; 9 for (int i = 1; i \u0026lt;= n; i++) 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 11 dp[0][k] = 1; 12 for(int i = 1; i \u0026lt;= n; i++) { 13 int sum = 0; 14 for(int j = k; j \u0026gt;= 0; j--) { 15 sum = (sum + dp[(i + 1) \u0026amp; 1][j]) % mod; 16 if(j + a[i] + 1 \u0026lt;= k) 17 sum = (sum + mod 18 - dp[(i + 1) \u0026amp; 1][j + a[i] + 1]) % mod; 19 dp[i \u0026amp; 1][j] = sum; 20 } 21 } 22 printf(\u0026#34;%d\\n\u0026#34;, dp[n \u0026amp; 1][0]); 23 return 0; 24} N. Slimes dp[i][j] 為合併史萊姆 i ~ j 所需的最小 cost。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxn 405 4#define INF 100000000000000 5typedef long long LL; 6int main() { 7 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 8 int a[maxn]; 9 for (int i = 1; i \u0026lt;= n; i++) 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 11 LL sum[maxn] = {}; 12 LL dp[maxn][maxn] = {}; 13 for (int i = 1; i \u0026lt;= n; i++) 14 sum[i] = sum[i - 1] + a[i]; 15 for (int len = 2; len \u0026lt;= n ; len++) 16 for(int i = 1, j = i + len - 1; j \u0026lt;= n; i++, j++) { 17 dp[i][j] = INF; 18 for (int k = i; k \u0026lt; j; k++) 19 dp[i][j] = min(dp[i][j], 20 dp[i][k] + dp[k + 1][j] + sum[j] - sum[i - 1]); 21 } 22 printf(\u0026#34;%lld\\n\u0026#34;, dp[1][n]); 23 return 0; 24} O. Matching 位元 dp。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxn 23 4#define maxm (1\u0026lt;\u0026lt;21)+5 5#define mod 1000000007 6int dp[maxm] = {1}; 7int main() { 8 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 9 int a[maxn][maxn]; 10 for (int i = 0; i \u0026lt; n; i++) 11 for (int j = 0; j \u0026lt; n; j++) 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); 13 int M = (1 \u0026lt;\u0026lt; n) - 1; 14 for (int j = 0; j \u0026lt;= M; j++) { 15 int i = __builtin_popcount(j) - 1; 16 for (int k = 0; k \u0026lt; n; k++) 17 if (j \u0026amp; (1 \u0026lt;\u0026lt; k) \u0026amp;\u0026amp; a[i][k]) 18 dp[j] = (dp[j] + dp[j - (1 \u0026lt;\u0026lt; k)]) % mod; 19 } 20 printf(\u0026#34;%d\\n\u0026#34;, dp[M]); 21 return 0; 22} P. Independent Set 經典樹 dp。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxn 100005 4#define mod 1000000007 5vector\u0026lt;int\u0026gt; e[maxn]; 6long long dp[maxn][2] = {}; 7void dfs(int v, int p) { 8 dp[v][0] = dp[v][1] = 1; 9 for (int u : e[v]) { 10 if (u == p) continue; 11 dfs(u, v); 12 dp[v][0] = dp[v][0] * (dp[u][0] + dp[u][1]) % mod; 13 dp[v][1] = dp[v][1] * dp[u][0] % mod; 14 } 15} 16int main() { 17 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 18 for (int i = 1; i \u0026lt; n; i++) { 19 int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); 20 e[a].push_back(b), e[b].push_back(a); 21 } 22 dfs(1, 0); 23 printf(\u0026#34;%lld\\n\u0026#34;, (dp[1][1] + dp[1][0]) % mod); 24 return 0; 25} Q. Flowers 帶權最長遞增子序列（Weighted Longest Increasing Subsequence）。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxn 200005 4typedef long long LL; 5int main() { 6 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 int h[maxn], a[maxn]; 8 for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;h[i]); 9 for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 10 map\u0026lt;int, LL\u0026gt; m; m[0] = 0; 11 for(int i = 0; i\u0026lt;n; i++) { 12 map\u0026lt;int,LL\u0026gt;::iterator iter, iter_tmp; 13 iter = m.lower_bound(h[i]); 14 iter--; 15 LL val = iter-\u0026gt;second + a[i]; 16 iter++; 17 while(iter != m.end() \u0026amp;\u0026amp; iter-\u0026gt;second \u0026lt;= val) { 18 iter_tmp = iter; 19 iter_tmp++; 20 m.erase(iter); 21 iter = iter_tmp; 22 } 23 m[h[i]] = val; 24 } 25 printf(\u0026#34;%lld\\n\u0026#34;, m.rbegin()-\u0026gt;second); 26 return 0; 27} R. Walk 矩陣快速冪。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxn 55 4#define mod 1000000007 5typedef long long LL; 6struct matrix { 7 int sz; 8 int m[maxn][maxn]; 9 matrix(){} 10 matrix(int n) : sz(n) { memset(m, 0, sizeof(m)); } 11 void operator = (const matrix \u0026amp;A) { 12 for (int i = 0; i \u0026lt; sz; i++) 13 for (int j = 0; j \u0026lt; sz; j++) 14 m[i][j] = A.m[i][j]; 15 } 16 matrix operator*(const matrix \u0026amp;A) { 17 matrix B(sz); 18 for (int i = 0; i \u0026lt; sz; i++) 19 for (int j = 0; j \u0026lt; sz; j++) { 20 B.m[i][j] = 0; 21 for (int k = 0; k \u0026lt; sz; k++) 22 B.m[i][j] = ((LL)m[i][k] * A.m[k][j] % mod 23 + B.m[i][j]) % mod; 24 } 25 return B; 26 } 27}; 28matrix pow(matrix A, LL k) { 29 matrix ans(A.sz); 30 for (int i = 0; i \u0026lt; A.sz; i++) 31 ans.m[i][i] = 1; 32 while (k) { 33 if (k \u0026amp; 1) ans = ans * A; 34 k \u0026gt;\u0026gt;= 1; 35 A = A * A; 36 } 37 return ans; 38} 39int main() { 40 int n; 41 LL k; 42 scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;k); 43 matrix A(n); 44 for (int i = 0; i \u0026lt; n; i++) 45 for (int j = 0; j \u0026lt; n; j++) 46 scanf(\u0026#34;%d\u0026#34;, \u0026amp;A.m[i][j]); 47 matrix ans = pow(A, k); 48 int cnt = 0; 49 for (int i = 0; i \u0026lt; n; i++) 50 for (int j = 0; j \u0026lt; n; j++) 51 cnt = (cnt + ans.m[i][j]) % mod; 52 printf(\u0026#34;%d\\n\u0026#34;, cnt); 53 return 0; 54} S. Digit Sum dp[i][j][k]：到第 i 個字母，同餘 j 的方法數，k 代表前 i 位是否和 input 的前 i 位一致。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define mod 1000000007 4int dp[2][102][2] = {}; 5inline void add(int \u0026amp;a, int b) { 6 a = (a + b % mod) % mod; 7} 8int main() { 9 ios_base::sync_with_stdio(0); 10 cin.tie(0); 11 string s; int d; 12 cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; d; 13 int len = s.length(); 14 dp[1][0][1] = 1; 15 for (int i = 0; i \u0026lt; len; i++) { 16 memset(dp[i \u0026amp; 1], 0, sizeof(dp[i \u0026amp; 1])); 17 for (int j = 0; j \u0026lt; d; j++) 18 for (int k = 0; k \u0026lt;= 9; k++) 19 if(k \u0026lt; s[i]-\u0026#39;0\u0026#39;) 20 add(dp[i \u0026amp; 1][(j + k) % d][0], 21 dp[!(i \u0026amp; 1)][j][0]), 22 add(dp[i \u0026amp; 1][(j + k) % d][0], 23 dp[!(i \u0026amp; 1)][j][1]); 24 else if (k == s[i] - \u0026#39;0\u0026#39;) 25 add(dp[i \u0026amp; 1][(j + k) % d][0], 26 dp[!(i \u0026amp; 1)][j][0]), 27 add(dp[i \u0026amp; 1][(j + k) % d][1], 28 dp[!(i \u0026amp; 1)][j][1]); 29 else 30 add(dp[i \u0026amp; 1][(j + k) % d][0], 31 dp[!(i \u0026amp; 1)][j][0]); 32 } 33 cout \u0026lt;\u0026lt; (dp[!(len \u0026amp; 1)][0][0] + 34 dp[!(len \u0026amp; 1)][0][1] - 1 + mod) % mod \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 35 return 0; 36} T. Permutation dp[i][j] 定義為前 i + 1 個數字結尾為 j 的組合數為多少（1 ≤ j ≤ i + 1）。 前綴和加速到 O(n²)。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int mod = 1000000007; 4int main() { 5 ios_base::sync_with_stdio(0),cin.tie(0); 6 int n; 7 string s; 8 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; 9 vector\u0026lt;int\u0026gt; dp(n + 1, 0), sum(n + 1, 1); 10 dp[1] = 1, sum[0] = 0; 11 for (int i = 1; i \u0026lt; n; i++) { 12 for (int j = 1; j \u0026lt;= i + 1; j++) { 13 if (s[i - 1] == \u0026#39;\u0026gt;\u0026#39;) 14 dp[j] = (sum[i] - sum[j - 1] + mod) % mod; 15 else 16 dp[j] = sum[j - 1]; 17 } 18 for (int j = 1; j \u0026lt;= n; j++) 19 sum[j] = (sum[j - 1] + dp[j]) % mod; 20 } 21 cout \u0026lt;\u0026lt; sum[n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 22 return 0; 23} U. Grouping 學會枚舉子集的辦法了！！\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4int main() { 5 ios_base::sync_with_stdio(0), cin.tie(0); 6 int n; cin \u0026gt;\u0026gt; n; 7 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a(n, vector\u0026lt;int\u0026gt;(n)); 8 for (int i = 0; i \u0026lt; n; i++) 9 for (int j = 0; j \u0026lt; n; j++) 10 cin \u0026gt;\u0026gt; a[i][j]; 11 int m = (1 \u0026lt;\u0026lt; n); 12 vector\u0026lt;ll\u0026gt; cnt(m), dp(m); 13 for (int s = 0; s \u0026lt; m; s++) 14 for (int i = 0; i \u0026lt; n; i++) 15 if (s \u0026amp; (1 \u0026lt;\u0026lt; i)) 16 for (int j = i; j \u0026lt; n; j++) 17 if (s \u0026amp; (1 \u0026lt;\u0026lt; j)) 18 cnt[s] += a[i][j]; 19 for (int s = 0; s \u0026lt; m; s++) 20 for (int sub = s; sub \u0026gt; 0; sub = (sub - 1) \u0026amp; s) 21 dp[s] = max(dp[s], dp[s - sub] + cnt[sub]); 22 cout \u0026lt;\u0026lt; dp[m - 1] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 23 return 0; 24} V. Subtree 參考 codeforces 這篇討論 才寫出來。\n解法：（有根樹）。\nup/down[node] 是 node 以上/下的點塗黑的方法數。 down 的不難算，直接 dfs 做樹 dp 就行了。 up 需要用到 down 的結果，算如果取 parent，其他子樹 down 的方法數。 +1 代表不取 parent。 最後各點的結果為 up * down。 算其他子樹的方法和，因為需要取 mod 且模數不為質數，故需要維護其前/後綴積。 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4#define maxn 100005 5#define pb push_back 6int mod; 7vector\u0026lt;int\u0026gt; e[maxn]; 8vector\u0026lt;ll\u0026gt; pre[maxn], suf[maxn]; 9ll up[maxn], down[maxn]; 10void dfs1(int u, int p) { 11 for (int uu : e[u]) 12 if (uu != p) dfs1(uu, u); 13 for (int i = 0; i \u0026lt; e[u].size(); i++) { 14 int uu = e[u][i]; 15 pre[u][i] = i ? pre[u][i-1] : 1; 16 if(uu != p) 17 pre[u][i] = pre[u][i] * (1 + down[uu]) % mod; 18 } 19 for (int i = e[u].size() - 1; i \u0026gt;= 0; i--) { 20 int uu = e[u][i]; 21 suf[u][i] = (i \u0026lt; e[u].size() - 1) ? suf[u][i + 1] : 1; 22 if(uu != p) 23 suf[u][i] = suf[u][i] * (1 + down[uu]) % mod; 24 } 25 down[u] = suf[u][0]; 26} 27void dfs2(int u, int p) { 28 for (int i = 0; i \u0026lt; e[u].size(); i++) { 29 int uu = e[u][i]; 30 if (uu == p) continue; 31 ll cnt = up[u]; 32 if(i) 33 cnt = cnt * pre[u][i - 1] % mod; 34 if(i + 1 \u0026lt; e[u].size()) 35 cnt = cnt * suf[u][i + 1] % mod; 36 up[uu] = cnt + 1; // 1是不取par 37 dfs2(uu, u); 38 } 39} 40int main() { 41 ios_base::sync_with_stdio(0); 42 cin.tie(0); 43 int n; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; mod; 44 for (int i = 1; i \u0026lt; n; i++) { 45 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 46 e[a].pb(b), e[b].pb(a); 47 } 48 e[1].pb(0), up[1] = 1; 49 for (int i = 1; i \u0026lt;= n; i++) { 50 pre[i].resize(e[i].size()); 51 suf[i].resize(e[i].size()); 52 } 53 dfs1(1, 0), dfs2(1, 0); 54 for (int i = 1; i \u0026lt;= n; i++) 55 cout \u0026lt;\u0026lt; down[i] * up[i] % mod \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 56 return 0; 57} W. Intervals 題意： 給定 M (1 ≤ M ≤ 200000) 組 (l[i], r[i]) (1 ≤ l[i] ≤ r[i] ≤ N ≤ 200000) 和 a[i] (|a[i]| ≤ 1000000000)。 當 l[i] ~ r[i] 至少有一個 1 的 a[i] 分，問構造出長度 N 的 01 字串最高得幾分。 解法： 轉移式：dp[i] = max{ dp[j] + sum{a[k]} }, j \u0026lt; l[k] ≤ i ≤ r[k] 優化：區間加值線段樹維護最大值。 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, ll\u0026gt; pil; 5#define ls i \u0026lt;\u0026lt; 1 6#define rs i \u0026lt;\u0026lt; 1 | 1 7class RangeUpdateSegmentTree { 8 private: 9 struct node { 10 int l, r; 11 ll x = 0, adt = 0; 12 }; 13 vector\u0026lt;node\u0026gt; a; 14 void push(int i) { 15 if (a[i].adt) { 16 a[ls].adt += a[i].adt, a[rs].adt += a[i].adt; 17 a[ls].x += a[i].adt, a[rs].x += a[i].adt; 18 a[i].adt = 0; 19 } 20 } 21 void pull(int i) { 22 a[i].x = max(a[ls].x, a[rs].x); 23 } 24 void build(int l, int r, int i) { 25 a[i].l = l, a[i].r = r; 26 if (l == r) return; 27 int mid = (l + r) \u0026gt;\u0026gt; 1; 28 build(l, mid, ls), build(mid + 1, r, rs); 29 } 30 public: 31 RangeUpdateSegmentTree(int n) : a(n \u0026lt;\u0026lt; 2) { 32 build(0, n, 1); 33 } 34 void add(int l, int r, ll val, int i = 1) { 35 if (a[i].l \u0026gt;= l \u0026amp;\u0026amp; a[i].r \u0026lt;= r) { 36 a[i].x += val; 37 a[i].adt += val; 38 return; 39 } 40 push(i); 41 int mid = (a[i].l + a[i].r) \u0026gt;\u0026gt; 1; 42 if (l \u0026lt;= mid) add(l, r, val, ls); 43 if (r \u0026gt; mid) add(l, r, val, rs); 44 pull(i); 45 } 46 ll maxx(int l, int r, int i = 1) { 47 if (l \u0026lt;= a[i].l \u0026amp;\u0026amp; a[i].r \u0026lt;= r) return a[i].x; 48 push(i); 49 ll ret = -9e18; 50 int mid = (a[i].l + a[i].r) \u0026gt;\u0026gt; 1; 51 if (l \u0026lt;= mid) ret = max(ret, maxx(l, r, ls)); 52 if (r \u0026gt; mid) ret = max(ret, maxx(l, r, rs)); 53 pull(i); 54 return ret; 55 } 56}; 57int main() { 58 ios_base::sync_with_stdio(0); 59 cin.tie(0); 60 int n, m; 61 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 62 vector\u0026lt;ll\u0026gt; add(n + 1); 63 vector\u0026lt;vector\u0026lt;pil\u0026gt;\u0026gt; del(n + 1); 64 for (int i = 0; i \u0026lt; m; i++) { 65 int l, r; ll a; 66 cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; a; 67 add[l] += a; 68 del[r].push_back(pil(l, a)); 69 } 70 RangeUpdateSegmentTree ST(n + 1); 71 ll ans = 0; 72 for (int i = 1; i \u0026lt;= n; i++) { 73 ST.add(0, i - 1, add[i]); 74 ll tmp = ST.maxx(0, i - 1); 75 ans = max(ans, tmp); 76 ST.add(i, i, tmp); 77 for (pil p : del[i]) 78 ST.add(0, p.first - 1, -p.second); 79 } 80 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 81 return 0; 82} X. Tower 將 solidness 排序後，再做 dp。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long LL; 4typedef pair\u0026lt;int,int\u0026gt; pii; 5typedef pair\u0026lt;int,pii\u0026gt; box; 6#define s first 7#define w second.first 8#define v second.second 9#define maxn 1005 10#define maxs 20005 11int main() { 12 int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); 13 box b[maxn]; 14 for(int i=0; i\u0026lt;n; i++){ 15 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;b[i].w, \u0026amp;b[i].s, \u0026amp;b[i].v); 16 b[i].s += b[i].w; 17 } 18 sort(b, b + n); 19 LL dp[maxs] = {}; 20 LL ans = 0; 21 for (int i = 0; i \u0026lt; n; i++) { 22 for (int j = b[i].s; j \u0026gt;= b[i].w; j--) { 23 dp[j] = max(dp[j], dp[j - b[i].w] + b[i].v); 24 ans = max(ans, dp[j]); 25 } 26 } 27 printf(\u0026#34;%lld\\n\u0026#34;, ans); 28 return 0; 29} Y. Grid 2 如果沒有障礙物，答案會是 C(h - 1 + w - 1, h - 1)。 有障礙物，就將障礙物那格的答案扣掉 C(x[i] - x[j] + y[i] - y[j], x[i] - x[j]) 次。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4typedef long long ll; 5#define x first 6#define y second 7#define mod 1000000007 8#define LEN 200005 9ll frc[LEN], inv[LEN]; 10ll modinv(ll a, ll p = mod) { 11 if (p == 1) return 0; 12 ll pp = p, y = 0, x = 1; 13 while (a \u0026gt; 1) { 14 ll q = a / p, t = p; 15 p = a % p, a = t, t = y, y = x - q * y, x = t; 16 } 17 if (x \u0026lt; 0) x += pp; 18 return x; 19} 20void init() { 21 frc[0] = frc[1] = inv[0] = inv[1] = 1; 22 for (int i = 2; i \u0026lt; LEN; i++) { 23 frc[i] = frc[i - 1] * i % mod; 24 inv[i] = modinv(frc[i]); 25 } 26} 27inline ll C(int a, int b) { 28 return frc[a + b] * inv[a] % mod * inv[b] % mod; 29} 30inline void sub(ll \u0026amp;a, ll b) { 31 a = (a - b % mod + mod) % mod; 32} 33int main() { 34 ios_base::sync_with_stdio(0); 35 cin.tie(0); 36 init(); 37 int h, w, n; 38 cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w \u0026gt;\u0026gt; n; 39 vector\u0026lt;pii\u0026gt; p(n); 40 for (int i = 0; i \u0026lt; n; i++) 41 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 42 sort(p.begin(), p.end()); 43 p.push_back(pii(h, w)); 44 vector\u0026lt;ll\u0026gt; dp(n + 1, 0); 45 for (int i = 0; i \u0026lt;= n; i++) { 46 dp[i] = C(p[i].x - 1, p[i].y - 1); 47 for (int j = 0; j \u0026lt; i; j++) 48 if (p[i].y \u0026gt;= p[j].y) 49 sub(dp[i], dp[j] * C(p[i].x - p[j].x, p[i].y - p[j].y)); 50 } 51 cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 52 return 0; 53} Z. Grid 3 h[i] 為遞增，故可斜率優化，總複雜度 O(N)。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4int main() { 5 ios_base::sync_with_stdio(0), cin.tie(0); 6 int n; ll C; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; C; 7 vector\u0026lt;ll\u0026gt; h(n + 1); 8 for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; h[i]; 9 vector\u0026lt;ll\u0026gt; dp(n + 1); 10 deque\u0026lt;int\u0026gt; dq(1, 1); 11 auto X = [\u0026amp;](int i) { 12 return -2 * h[i]; 13 }; 14 auto Y = [\u0026amp;](int i) { 15 return h[i] * h[i] + dp[i]; 16 }; 17 auto F = [\u0026amp;](int i, int j) { 18 return h[i] * X(j) + Y(j) + C + h[i] * h[i]; 19 }; 20 auto cross = [](ll x1, ll y1, ll x2, ll y2) { 21 return x1 * y2 - x2 * y1; 22 }; 23 for (int i = 2; i \u0026lt;= n; i++) { 24 while (dq.size() \u0026gt;= 2) { 25 if (F(i, dq[0]) \u0026gt;= F(i, dq[1])) 26 dq.pop_front(); 27 else break; 28 } 29 dp[i] = F(i, dq[0]); 30 while (dq.size() \u0026gt;= 2) { 31 int j = dq.back(), k = dq[dq.size()-2]; 32 if (cross(X(j)-X(k), Y(j)-Y(k), X(i)-X(j), Y(i)-Y(j)) \u0026gt;= 0) 33 dq.pop_back(); 34 else break; 35 } 36 dq.push_back(i); 37 } 38 cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 39 return 0; 40} ","date":"2021-01-04T11:59:31+08:00","permalink":"https://luke2336.github.io/p/atcoder_education_dp/","title":"AtCoder Educational DP Contest"},{"content":"十一月 Blog 用 hugo 架了新的 Blog。 ICPC 報帳 幫 Hyperbola 處理了報帳的事情。 十二月 選課。 某天練完題後，去吃了和味。 電路學的期末專題有點隨便地做完了。 久違的和學長去風雲四樓吃了飯。 用三倍券買了第一雙羽球鞋。 PCCA 試著改了練習方式，每 30 分鐘一輪，換一次隊友解題。 寫交換的備審資料。 和學長第一次去蒙民偉樓四樓吃甜點喝茶。 回去北一參加校慶。 北一女校慶擺攤事件 倫子老師的貼文 開始用 Toggl 這款 APP 計時。 聖誕節悅庭來找我玩，送了我瑪露連。 家教的學生有其他事要做，於是我就失業了。 認識語言的報告寫完，中午就交出去了，傍晚便收到評語，得到了 94 分，覺得很開心，因為有幾個問題被認為提得不錯，主要是對於演化的部分。 在資電館 124 跨年。 ","date":"2020-12-31T06:37:15+08:00","image":"https://luke2336.github.io/p/2020/1_hu91617f4502a279ea5bd55f41a3835b30_1908015_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/2020/","title":"記 2020"},{"content":"CH14 這章用 Frequency Domain 來討論電路學，主要的重點有以下幾個：\nFrequency \u0026amp; Magnitude Responce Bode Plots Resonance, Half-Power Freq., Quality Factor Filter: Lowpass, Highpass, Bandpass, Bandstop Magnitude \u0026amp; Frequency Scaling ","date":"2020-12-30T15:29:08+08:00","image":"https://luke2336.github.io/p/circuit_ch14/filter_hudfe54b12c77ca286871ad834f4483d46_985085_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/circuit_ch14/","title":"電路學第 14 章"},{"content":"CH5 - Process Synchronization The Critical-Section Problem 有些資源只能同時被一個 process 使用。\n1 2 3 4 5 6 do { entry_section(); // critical section exit_section(); // remainder section while (true); Mutual Excusion Progress (Freedom from Deadlock) Bounded Wait (Freedom from Starvation) preemptive: 資源被使用時可以被打斷 non-preemptive Peterson\u0026rsquo;s Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class PetersonLock { // shared var. bool flag[2]; int victim; public: void lock() { int i = ThreadID.get(); int j = 1 - i; flag[i] = true; victim = i; while (flag[j] \u0026amp;\u0026amp; victim == i); } void unlock() { int i = ThreadID.get(); flag[i] = false; } }; 1 2 3 4 5 6 do { lock(); // critical section unlock(); // remainder section while (true); Test \u0026amp; Set 1 2 3 4 5 6 // atomic bool test_and_set (bool *target) { bool ret = *target; *taget = true; return ret; } 1 2 3 4 5 6 7 8 9 10 11 12 13 do { wait[i] = true; while (wait[i] \u0026amp;\u0026amp; test_and_set(\u0026amp;lock) ); wait[i] = false; // critical section j = (i + 1) % n; while ( (j != i) \u0026amp;\u0026amp; !waiting[j] ) j = (j + 1) % n; if (j == i) lock = flase; else wait[j] = false; } while (true); Compare \u0026amp; Swap 1 2 3 4 5 6 int compare_and_swap (int * val, int expected, int new_val) { int tmp = *val; if (*val == expected) *val = new_value; return tmp; } 1 2 3 4 5 6 do { while (compare_and_swap(\u0026amp;lock, 0, 1) ); // critical section lock = 0; // remainder section } while (true); Mutex acqueire() and release() are atomic.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 acquire() { while (!available) ; available = false; } release () { available = true; } do { acquire(); // critical section release(); // remainder section } while (true); Semaphore counting/binary semaphore semaphore S : integer wait() and signal() are atomic 1 2 3 4 5 6 7 8 wait(S) { while (S \u0026lt;= 0) yeild(); S--; } signal(S) { S++; } Implementation (Blocking) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct sempaphore { int cnt; queue q; } void wait(semaphore *S) { S-\u0026gt;cnt--; if (S-\u0026gt;cnt \u0026lt; 0) { S-\u0026gt;q.push(process); block(); } } void signal(semaphore *S) { S-\u0026gt;cnt++; if (S-\u0026gt;cnt \u0026gt;= 0) { P = S-\u0026gt;q.pop(); wakeup(P); } } Examples 1. Bounded-Buffer Problem 1 2 3 4 init Semaphores: mutex-\u0026gt;cnt = 1; full-\u0026gt;cnt = 0; empty-\u0026gt;cnt = N; 1 2 3 4 5 6 7 8 9 10 11 // producer do { // produce an item wait(empty); wait(mutex); // add the item to buffer; buffer[in] = product; in = (in + 1) % N; signal(mutex); signal(full); } while (true); 1 2 3 4 5 6 7 8 9 10 11 // consumer do { // produce an item wait(full); wait(mutex); // add the item to buffer; product = buffer[out]; out = (out + 1) % N; signal(mutex); signal(empty); } while (true); 2. Readers-Writers Problem 3. Dining-Philosophers Problem ","date":"2020-12-28T14:40:40+08:00","image":"https://luke2336.github.io/p/os_ch5/OS_hua83155582a3c2050bdc7c536a4fdf44a_55922_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/os_ch5/","title":"OS CH5 複習"},{"content":"方向 / 方位 中文 German 上 über 下 unter 左 links 右 rechts 中文 German 東 der Osten 西 der Westen 南 der Süden 北 der Norden Berlin liegt im Osten von Deutschland. in die Mitte 數字用法 Zahlen German Zahlen German Zahlen German 0 null 10 zehn 20 zwanzig 1 eins 11 elf 21 einundzwanzig 2 zwei 12 zwölf 3 drei 13 dreizehn 4 vier 14 vierzehn 5 fünf 15 fünfzehn 6 sechs 16 sechzehn 7 sieben 17 siebzehn 8 acht 18 achtzehn 9 neun 19 neunzehn Zahlen German 20 zwanzig 30 dreißig 40 vierzig 50 fünfzig 60 sechzig 70 siebzig 100 (ein)hundert 101 hunderteins 1.000 (ein)tausend 10.000 zehntausend 100.000 hunderttausend 1.000.000 eine Million 1.000.000.000 eine Billion 價格 Preis 小數點 (,) 千分位 (.) 100 Cent = 1 Eruo 9,99 € = 9 Euro 99 9,99 € = 50 Cent WH 疑問句 German English Was What Wer Who Wie How Wo Where Woher From where 動詞變化 中文 人稱 規則 machen leben wohnen arbeiten haben sprechen sein 我 ich e mache lebe wohne arbeite habe spreche bin 你 du st machst lebst wohnst arbeitest hast sprichst bist 他/她 er/sie t macht lebt wohnt arbeitet hat spricht ist 我們 wir - machen leben wohnen arbeiten haben sprechen sind 你們 ihr t macht lebt wohnt arbeitet habt spricht seid 他們/您(們) sie/Sie - machen leben wohnen arbeiten haben sprechen sind 自我介紹 Name 姓名 Wie heißen Sie / heißt du? Wer sind Sie / bist du? Ich bin/heiße ___. Mein Name ist ___. Herkunft 籍貫 Woher kommen Sie / kommst du? Ich komme aus Taiwan. Wohnort 居住地 Wo wohnen Sie / wohnst du? Ich wohne in ___. Alter 年齡 Wie alt sind Sie / bist du? Ich bin 20 Jahre alt Beruf 職業 Was sind Sie / bist du von Beruf? Was machen Sie / machst du beruflich? Ich bin / arbeite als ___ bei ___. Famienstand Ich habe ein Kind / zwei, keine Kinder. Ich bin verheirater（結婚） / geschieden（離婚） / Single. Ich leben (nicht) zusammen.（同居） 問候語 打招呼 Hallo. Guten Morgen. Guten Tag. Guten Abend. Gute Nacht. How are you? Wie gets es Ihnen? / Wie geht\u0026rsquo;s? Sehr gut. Gut, danke. Es geht. Nicht so gut. Gut, danke. Und Ihnen? Auch gut. Googbye Auf Wiedersehen. Tschüs. Burufe 中文 男生 女生 工程師 der Ingenieur 機械師 der Mechatroniker 演員 der Schauspieler 大學生 der Student die Studentin 記者 der Journalist die Journalistin 髮型師 die Friseurin 建築師 die Architektin 秘書 die Sekretärin 醫生 der Arzt die Ärztin 教師 der Lehrer 小販 der Verkäufer 服務生 die Kellnerin Mann / Frau 男生 女生 Kollege Kollegin Freund Freundin Partner Partnerin Familie 中文 English German 父親 Father der Vater 母親 Mother die Mutter 父母 Parent die Eltern 兒子 Son der Sohn 女兒 Daughter die Tochter 兄弟 Brother der Bruder 姐妹 Sister die Schwester 兄弟姊妹 Sibling die Geschwister 祖父 Grandpa der Großvater / Opa 祖母 Grandma die Großmutter / Oma 祖父母 Grandparent die Großeltern 孫女 Granddaughter die Enkelin 孫子 Grandson der Enkel 先生 Husband der Ehemann 太太 Wife die Ehefrau 所有格 主格 der / das die ich mein meine du dein deine er/es sein seine sie ihr ihre wir unser unsere Sie Ihr Ihre 所有格 Akkusativ nach haben, brauchen, suchen, \u0026hellip; definiter Artikel indefiniter Artikel Netativ-Artikel Sie hat den einen keinen Laptop. das ein kein Formula. die eine keine Briefmarke. die - keine Stifte. Sprachen Welche Sprachen sprechen Sie / sprichst du? Ich spreche sehr gut / gut / ein bisschen \u0026hellip; der Land Sprachen das Deutschland Deutsch das Frankreich Französisch die USA die Niederlande Niederländisch England Englisch das Mexiko das Spanien Spanisch die Türkei das Polen Polnisch das Tschechien Tschechisch das Russsland Russisch das Österreich Möbel 家具 English German Plural bed das Bett Betten picture das Bild Bilder armchair der Sessel Sessel lamp die Lampe Lampen chair der Stuhl Stühle sofa das Sofa Sofas couch die Couch Couchen table der Tisch Tische closet（抽屜） der Schrank Schränke carpet（地毯） der Teppich Teppiche Gegenstände English German Plural pencil der Bleistift Bleistifte glasses die Brille Brillen book das Buch Bucher bottle die Flasche Flaschen lighter das Feuerzeug Feuerzeuge camera der Fotoapparat Fotoapparate chain die Kette Ketten pen der Kugelschreiber Kugelschreiber key der Schlüssel Schlüssel bag die Tasche Taschen Im Büro English German Plural laptop der Laptop Laptops e-mail die E-Mail E-Mails cell phone das Handy Handys SMS die SMS bill die Rechnung Rechnungen phone das Telefon Telefone form das Formular Formulare printer der Drucker Drucker mouse die Maus Mauß computer der Computer Computer pen der Stift Stifte notebook das Notizbuch Notizbucher calender der Kalender Kalender screen der Bildschirm Bildschirme Personalpronomen maskulin neutral feminin der das die er es sie Beratungsgespräche German English Brauchen Sie Hilfe Do you need help Ja, bitte. Wie viel / Was kostet (denn) die Lampe? Die Lampe kostet 119 Euro. Das ist ein Sonderangebot（特價）. Das ist (sehr / zu / aber) teuer / günstig / billig. Der Tisch ist zu groß / zu klein. Ich finde die Lampe (wirklich) sehr schön. Das finde ich auch. 我同意 / Das finde ich night. 我不同意 Finden Sie? / Findest du? 你同意嗎？ teuer 昂貴 günstig / billig 便宜 groß 大 klein 小 schön 漂亮 Materialien 材質 Die Brille ist aus ___. 中文 German 木頭 Holz 金屬 Metall 紙 Papier 塑膠 Kunststoff / Plastik 玻璃 Glas Farben 顏色 中文 German 紅色 röte / rot 綠色 grün 橘色 orange 黑色 schwarz 棕色 braun 藍色 blau 黃色 gelb 白色 weiß Formen 形狀 中文 German 方形 eckig 圓形 rund nach Wörtern fragen A: Entschuldigung, wie heißt das auf Deutsch? B: Das ist eine Uhr. A: We bitte? Noch einmal, bitte. B: Das ist eine Uhr. A: We schreibt man Uhr? B: U - H - R. A: Danke. B: Bitten schön. Kein Problem. Internet bestellen 網購 Anrede: Frau / Herr Vorname Falmiliename Geburtsdatum: Tag / Monat / Jahr （生日） Postleitzahl (PLZ) （郵遞區號） ","date":"2020-12-28T10:19:18+08:00","image":"https://luke2336.github.io/p/german1/Mecschen_hu875aa82bae0e23a00094e510776f9b98_89069_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/german1/","title":"德文（一）筆記"},{"content":"「認識語言」期末報告 以下介紹五個我在「認識語言」下半學期學到的重點。\n1. Chomsky 和行為主義 (Behaviorism) 的對立 語言的學習是後天的 (nurutre)，還是天生就有的 (nuture) 學習能力？\n行為主義興起的背景，要從佛洛伊德的時代開始談起，當時心理學是立足於潛意識等無法觀測的東西，因此很多科學家無法認同心理學屬於科學的一支。\n在 Parlov、Skinner 和 Waston 等人的努力下，產生了行為主義學派。他們透過設計實驗來研究人或動物的行為模式，像是古典制約的實驗中，Parlov 的狗被制約，每次接收到搖鈴刺激 (stimulus)，就會不由自主的流口水。而 Skinner 進一步提出了操作制約，透過食物來讓老鼠自己學會按開關。\n行為主義者宣稱，他們可透過制約，也就是給予 positive/negative reforcement，使人類學習，這屬於 stimulus-response learning。他們認為母語的學習也可以透過同樣的管道。\n對此，Chomsky 有不同的看法，他認為語言的習得無法僅僅透過後天的經驗，先天的能力是必須的，因此他提出了 Universal Grammar。\u0026ldquo;What you know exceeds what you were taught.\u0026quot;，舉例來說，小孩子會犯一些大人不會犯的錯誤，像是 \u0026ldquo;holded\u0026rdquo;，這是他們無法透過模仿習得，可以推論出他們先天具備一些學習語言的能力，像是統計、歸納等等。\nChomsky 說明了在語言的學習上，本能和經驗都是重要的。我認為他的想法是重要且具有突破性的，因為他不只影響了語言學的發展，更對心理學造成了重大的影響，他證明了行為主義是無法解釋所有現象的，讓心理學研究慢慢走出行為主義的框架。\n2. Universal Grammar (UG) Universal Grammar 是 Chomsky 的理論，為了描述所有語言的共同點。Universal Grammar 是由 principles 和 parameters 共同組成。\n由於孩童學習語言的時間是有限的，且他們能得到的資訊量也是有限的，但他們能表達的語句，卻是無限的。可見，這些語句不僅僅是藉由經驗而習得，而需要藉由人類天生就有的 Universal Grammar，將得到的句子提取出一些共通的 principles。像是人們能判斷句子中的代名詞或是反身代名詞是在指誰，都是我們在學習時無法直接解釋的，這些天生就具備的能力，就是屬於 Universal Grammar。\n但這些 principles 卻只能解釋語言具有共通性，而無法解釋語言的差異性，因此他在理論中加入了 parameters 的想法。\n在英語中，是先表達動詞，然後才是受詞。然而，在日語中，兩者卻是相反的。又或是在英文中，我們會將 Where/Who 等疑問詞放在句子開頭，而在中文中，我們卻會任意擺放哪裡/誰/何時在句子的其他位置。這些現象無法被 principles 概括，因此我們有了 parameters。parameters 提供了孩童在學習時，能藉由聽到的資訊，將母語中沒有的 parameters 捨棄，讓他們能專注於學習母語中有的文法或發音。\n我認為 UG 重要的原因在於它解釋了大部分的語言學習現象，但其發展卻極具挑戰，畢竟這個理論需要符合世界上的所有語言，所以每當科學家舉出一個反例時，這個理論就必須做出修改，因此這個理論勢必逐漸簡化成現今的模樣。\nUG 到底是如何演化出來的，我認為這是一個滿有趣的問題。人腦中的 Universal Grammar 到底是愈來愈複雜，又或是愈來愈簡化呢？如果按照我對 Universal Grammar 的認識，有了 parameters 的幫助，或許 principles 是可以發展成愈來愈多的？\n3. 嬰兒的語言發展階段 嬰兒的母語發展有幾個重要的階段：\n在懷孕的最後幾週，嬰兒的聽力系統已接近發育完全，因此他們就會開始聆聽外界聲音，剛出生的嬰兒就對母語有偏好。 3 個月：larynx lowerling，嬰兒的喉頭會下降，他們能發出更多的聲音。 6 ~ 10 個月：phoneme comprehension，嬰兒開始失去辨識母語以外的音的能力，不再能分辨所有語言中的音，這讓他們能更專注於學習母語。 6 ~ 12 個月：他們透過 Babbling 來學會發音。 1 歲多時他們能一些單詞 (1-word)。快 2 歲時，他們會說兩個詞的句子 (2-words)。 2 ~ 2.5 歲時，telegraphic stage，他們的單字量迅速擴增，並且能組合成完整的句子，儘管文法不一定正確。 2.5 歲後：他們開始發展像成人的語句，並且已習得大多數文法規則，但他們會出現 over-generalization 的狀況，也就是有了像 \u0026ldquo;goed\u0026rdquo; 或是 \u0026ldquo;holded\u0026rdquo; 等成人不會犯錯誤。 科學家是如何針對不會說話的嬰兒進行研究呢？他們有幾種有趣的研究方式，例如：\nPacifier experiment：他們利用嬰兒吸食奶嘴的速度來研究嬰兒對事物的興趣，例如他們在聽到的聲音從 /ba/ 變成 /pa/ 時，他們會改變吸食速度。 Head-turn Experiment：科學家可能藉由讓嬰兒學會某些規則，例如聽到 ABA 時，玩偶會出現在左方，反之，聽到 AAB ，則會出現在右方。之後，在透過紀錄嬰兒轉頭的方向，來實驗嬰兒是否能學會規則。 這幾個發展的階段，有解釋到幾個我以前無法理解的疑問。首先，我了解到我們長大後學習語言，為什麼無法達到學母語一樣的成果。接著，我也理解到人類演化出喉頭下降是非常重要的，像是我們的近親 - 猿類，就沒有這個演化結果，這讓他們有些音是發不出來的（例如：/i/、/a/、/u/）。而這個演化其實是對人類高風險的，因為這會干擾消化道和呼吸道分離。但他卻出現在三個月大時，以適者生存的角度來看，語言對於人類的生存是非常重要的。\n非常有趣的一點是，全世界的嬰兒都是用相近的時程來發展，顯然這些都是演化的結果。在上課中有提過，猿類對語言的學習至多是線性的結構，無法像人類一樣有階層狀/洋蔥狀的結構，也無法創造太長的句子。有些好奇有沒有研究能知道這樣的大腦發展的演化和人類發音器官構造的演化，究竟是誰先誰後？還有是否有其他生物一樣有 phoneme comprehension 的現象？\n4. 雙母語嬰兒的認知能力 在討論雙母語和單母語嬰兒的認知差異前，我們需要先定義認知能力是什麼？\nExecutive functions (EF) 是認知心理學中，對於人類一些認知能力的統稱，包含了管理工作記憶、控制衝動、能處理多項工作（能快速轉換）的能力。這些能力主要是由前額葉所控制。\n根據研究，雙母語和單母語嬰兒習得母語的所需時間是相近的。這是由於雙母語的學習會刺激認知能力的發展，而發展較好的認知能力也有助於雙母語的學習。\n嬰兒在雙母語環境下，他的大腦需要處理兩種語言，因此需要前額葉的幫助，使得嬰兒能快速在兩種語言中切換。根據 Kovács \u0026amp; Mehler 對 7 個月大的研究，當同時有兩個規則時，單母語環境的嬰兒只能學會較簡單的那種，而雙母語嬰兒能學會兩種，得到了雙母語嬰兒有較佳 EF 的結論。\n很重要的一點是，根據科學家的研究，EF 的發展最快速的時期是在 6 歲前，因此父母在 6 歲前給予嬰兒適當的刺激有助於發展他們的 EF，像是唸外語故事書就是很好的方式。而對於雙語的人，就算他們長時間只使用單一語言，但他們的前額葉仍需要去抑制另外一種語言，因此研究也指出雙語的人比單語的人得到老年癡呆的平均年齡晚 4 年。\n我很好奇的一點是，人類嬰兒學習語言的能力和其認知能力是相輔相成的，那他們最多能學習多少種語言才會達到認知能力的極限？\n5. Finite State Grammars (FSGs) Finite State Grammar 是 Chomsky 提出的概念。我們都知道，句子是由 finite 的字詞組成而成，但其組成方法是無限的。對於一個有限長度的句子，我們可以透過一種特殊的 finite state machine 生成，這種 finite state machine 運用了 transition probability (TP) 的概念，藉由 TP 來定義一種 Markov chain。\n然而，這種想法是無法實際運用在生成自然語言，他遠遠不足以表達人類的文法。由於 FSGs 只能藉由上一個狀態去決定下一個狀態，故在定義狀態時，只會是線性的，無法表達出階層的概念，也無法透過機率去生成合乎文法的句子，像是不同時態的 is/was，出現在某個名詞後面的機率會是相近的。因此，最後有了 Phrase Sturcture Grammars (PSGs)，讓句子能嵌入進句子中，有了階層狀的結構，而能表達出字詞間的關聯性，不在侷限於相鄰的字間。\nFSGs 的重要性在於，他提供了一種簡單的運算方式，讓電腦能生成語句。且他將一些遞迴的想法，透過 state diagram 中的 cycle / loop 來達成。\n句子的組成無法用 Finite State Machine 來表達，但英文的構詞是否能用 Finte State Machine 來找到一些規則？\nFeedback 因為提出的問題不錯，所以得到 94 分。\n有些好奇有沒有研究能知道這樣的大腦發展的演化和人類發⾳器官構造的演化，究竟是誰先誰後? 應該是發音器官的演化比較早，因為喉頭下降的生理現象雖然黑猩猩與猿類沒有，但是在其他的生物上有歐！例如鹿類就有，但是在其他生物上演化出此生理特徵不是了語言，而是為了增加吼叫聲的威嚇力，讓敵人感覺你的體積龐大，由於有這個另外的演化動力，所以學者的假說是發聲器官的改變早於大腦演化。\n是否有其他⽣生物一樣有 phoneme comprehension 的現象? 其他的生物也會有phoneme comprehension的categorical perception的現象！\n","date":"2020-12-28T10:09:29+08:00","image":"https://luke2336.github.io/p/understanding_language_final_report/larynx_hu3faf1b4f02e93994d059e4838f6c6f9b_396678_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/understanding_language_final_report/","title":"認識語言 期末報告"},{"content":"AtCoder Beginning Contest 186 pE 讓我卡了一下，於是就掉分了。pF 想到了一個假解，浪費了不少時間。可能是因為剛打完 CF，所以狀態不好。\nA. Brick 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int n, w; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; w; 5 cout \u0026lt;\u0026lt; n / w \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 6 return 0; 7} B. Blocks on Grid 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 ios_base::sync_with_stdio(0); cin.tie(0); 5 int h, w; cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w; 6 int sum = 0, m = 105; 7 for (int i = 0; i \u0026lt; h; i++) { 8 for (int j = 0; j \u0026lt; w; j++) { 9 int x; cin \u0026gt;\u0026gt; x; 10 sum += x; 11 m = min(m, x); 12 } 13 } 14 cout \u0026lt;\u0026lt; sum - m * h * w \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 15 return 0; 16} C. Unlucky 7 求 1 ~ n 中，有多少個數的十進位和八進位都沒有 7。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3bool check(int n, int k) { 4 while (n) { 5 if (n % k == 7) return false; 6 n /= k; 7 } return true; 8} 9int main() { 10 int n; cin \u0026gt;\u0026gt; n; 11 int cnt = 0; 12 for (int i = 1; i \u0026lt;= n; i++) 13 cnt += check(i, 10) \u0026amp; check(i, 8); 14 cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 15 return 0; 16} D. Sum of difference 求 |ai - aj|, i \u0026lt; j 的總和。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4int main() { 5 ios_base::sync_with_stdio(0); cin.tie(0); 6 int n; cin \u0026gt;\u0026gt; n; 7 vector\u0026lt;ll\u0026gt; a(n); 8 for (int i = 0; i \u0026lt; n; i++) 9 cin \u0026gt;\u0026gt; a[i]; 10 sort(a.begin(), a.end()); 11 vector\u0026lt;ll\u0026gt; sum(n + 1); 12 for (int i = n - 1; i \u0026gt;= 0; i--) 13 sum[i] = sum[i + 1] + a[i]; 14 ll ans = 0; 15 for (int i = 0; i \u0026lt; n; i++) 16 ans += sum[i + 1] - a[i] * (n - i - 1); 17 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 18 return 0; 19} E. Throne 先用 extgcd(k, n) 求 xk + bn = gcd(k, n)，再求 xk % n = s 的最小整數解。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;ll, ll\u0026gt; pii; 5ll gcd (int a, int b) { 6 return b ? gcd(b, a % b) : a; 7} 8pii extgcd(ll a, ll b) { 9 if (!b) return {1, 0}; 10 ll k = a / b; 11 pii p = extgcd(b, a - k * b); 12 return {p.second, p.first - k * p.second}; 13} 14int main() { 15 ios_base::sync_with_stdio(0); cin.tie(0); 16 int T; cin \u0026gt;\u0026gt; T; 17 while (T--) { 18 ll n, s, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; 19 ll g = gcd(n, k); 20 if (s % g) { 21 cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; continue; 22 } 23 ll ans = -extgcd(k, n).first * s / g; 24 ans %= n / g; 25 if (ans \u0026lt;= 0) ans += n / g; 26 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 27 } 28 return 0; 29} F. Rook on Grid 給定一個 H x W 的棋盤，以及 M 個障礙物。 (H, W, M ≤ 2e5)\n求從 (1, 1) 出發 Rook 能在兩步內到達的格子有幾個？\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define x first 6#define y second 7#define maxn 200005 8class RangeUpdateBIT { 9 private: 10 ll d[maxn], dd[maxn]; 11 ll sum(int i) { 12 ll s = 0, ss = 0; 13 int c = i + 1; 14 while (i \u0026gt; 0) s += d[i], ss += dd[i], i -= i \u0026amp; -i; 15 return c * s - ss; 16 } 17 void add(int i, ll v) { 18 int c = i; 19 while (i \u0026lt; maxn) 20 d[i] += v, dd[i] += c * v, i += i \u0026amp; -i; 21 } 22 public: 23 RangeUpdateBIT() { 24 memset(d, 0, sizeof(d)); 25 memset(dd, 0, sizeof(dd)); 26 } 27 ll sum(int l, int r) { return sum(r) - sum(l - 1); } 28 void add(int l, int r, ll v) { 29 add(l, v), add(r + 1, -v); 30 } 31}; 32int main() { 33 ios::sync_with_stdio(0); cin.tie(0); 34 int h, w, m; cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w \u0026gt;\u0026gt; m; 35 vector\u0026lt;pii\u0026gt; p(m); 36 vector\u0026lt;int\u0026gt; col(w + 1, h + 1), row(h + 1, w + 1); 37 for (int i = 0; i \u0026lt; m; i++) { 38 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 39 col[p[i].y] = min(col[p[i].y], p[i].x); 40 row[p[i].x] = min(row[p[i].x], p[i].y); 41 } 42 sort(p.begin(), p.end()); 43 ll ans = 0; 44 for (int i = 1; i \u0026lt;= w \u0026amp;\u0026amp; col[i] \u0026gt; 1; i++) 45 ans += col[i] - 1; 46 RangeUpdateBIT T; 47 T.add(row[1], w + 1, 1); 48 for (int j = 2, pi = 0; j \u0026lt;= h \u0026amp;\u0026amp; row[j] \u0026gt; 1; j++) { 49 while (pi \u0026lt; m \u0026amp;\u0026amp; p[pi].x \u0026lt; j) pi++; 50 int R = (pi \u0026lt; m \u0026amp;\u0026amp; p[pi].x == j) ? p[pi].y : w + 1; 51 ans += T.sum(1, R - 1); 52 while (pi \u0026lt; m \u0026amp;\u0026amp; p[pi].x ==j) { 53 if (!T.sum(p[pi].y, p[pi].y)) 54 T.add(p[pi].y, p[pi].y, 1); 55 pi++; 56 } 57 } 58 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 59 return 0; 60} ","date":"2020-12-19T22:03:36+08:00","image":"https://luke2336.github.io/p/atcoder_abc186/AtCoder_ABC186_Standing_hu77a0085b7da25359ba47647131298366_239541_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/atcoder_abc186/","title":"AtCoder Beginning Contest 186"},{"content":"Codeforces Round #691 (Div. 2) 因為 pC 找不到 bug，就一直亂丟，於是打得超爛。Rating 加了 43 到 1695。\npA. Red-Blue Shuffle 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define pb push_back 6int main() { 7 ios_base::sync_with_stdio(0); cin.tie(0); 8 int T; cin \u0026gt;\u0026gt; T; 9 while (T--) { 10 int n; cin \u0026gt;\u0026gt; n; 11 string R, B; 12 cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; B; 13 int r = 0, b = 0; 14 for (int i = 0; i \u0026lt; n; i++) 15 if (R[i] \u0026gt; B[i]) r++; 16 else if (R[i] \u0026lt; B[i]) b++; 17 if (r \u0026gt; b) cout \u0026lt;\u0026lt; \u0026#34;RED\\n\u0026#34;; 18 else if (r \u0026lt; b) cout \u0026lt;\u0026lt; \u0026#34;BLUE\\n\u0026#34;; 19 else cout \u0026lt;\u0026lt; \u0026#34;EQUAL\\n\u0026#34;; 20 } 21 return 0; 22} pB. Move and Turn 總共走 n 步，每走一步要從東西向換成左右向，問總共有幾種不同的終點？\n首先，計算兩種各自需要走幾步，假設一種為 a 和 b 步，則各自有 a 和 b 種線性組合 (x - y = a)，接下來考慮第一步為東西或南北，若 a 和 b 不同，則答案為 a * b * 2，否則為 a * b。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define pb push_back 6int main() { 7 ios_base::sync_with_stdio(0); cin.tie(0); 8 int n; cin \u0026gt;\u0026gt; n; 9 int a = n / 2, b = n - n / 2; 10 int ans = (a + 1) * (b + 1); 11 if (a != b) ans *= 2; 12 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 return 0; 14} pC. Row GCD 給定 1 ≤ n, m ≤ 2e5，給定 a1 ~ an, b1 ~ bm，回答 a1 + bj ~ an + aj 的最大公因數 GCDj。\n輾轉相除法是用相減，所以直接用數列差的 GCD 去和 a1 + bj 取 GCD 即可。\n需要小心 n = 1 的狀況，不小心踩到坑了 QAQ\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define pb push_back 6int main() { 7 ios_base::sync_with_stdio(0); cin.tie(0); 8 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 9 vector\u0026lt;ll\u0026gt; a(n); 10 for (int i = 0; i \u0026lt; n; i++) 11 cin \u0026gt;\u0026gt; a[i]; 12 sort(a.begin(), a.end()); 13 ll g = n \u0026gt; 1 ? a[1] - a[0] : 0; 14 for (int i = 2; i \u0026lt; n; i++) 15 g = __gcd(g, a[i] - a[0]); 16 for (int j = 0; j \u0026lt; m; j++) { 17 ll b; cin \u0026gt;\u0026gt; b; 18 cout \u0026lt;\u0026lt; __gcd(g, a[0] + b) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 19 } 20 return 0; 21} ","date":"2020-12-19T19:07:58+08:00","image":"https://luke2336.github.io/p/cf_contest_1459/CF_1459_Standing_hu690baba5c3b018443698fd9ea11bde1f_196062_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/cf_contest_1459/","title":"Codeforces Round 691 Div. 2"},{"content":"CPTC 001 Problem Coder Topic A Hyperbola Binary Search B Kelly Greedy, Sort C Hyperbola Enumerate, Prefix Sum D Hyperbola 互動題, DP E Kelly 數位 DP 今天難得全都 1AC。讀完題後也有迅速抓出水題，兩題都在正常速度開完。pD 被曲線通靈出來，他邊寫我邊聽 LinLee 講題目。我決定把 pE 拿去做，pC 則留給他們想。pE 算是定義好狀態就很好寫的題目，之前常在 AtCoder 看到類似的題目。\npB 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4int main() { 5 int n, m; 6 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n ,\u0026amp;m); 7 vector\u0026lt;int\u0026gt; deg(n); 8 for (int i = 0; i \u0026lt; m; i++) { 9 int a, b; 10 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); 11 deg[a-1]++, deg[b-1]++; 12 } 13 vector\u0026lt;int\u0026gt; h(n); 14 for (int i = 0; i \u0026lt; n; i++) 15 scanf(\u0026#34;%d\u0026#34;, \u0026amp;h[i]); 16 sort(h.begin(), h.end()); 17 sort(deg.begin(), deg.end()); 18 ll ans = 0; 19 for (int i = 0; i \u0026lt; n; i++) 20 ans += ll(h[i]) * ll(deg[n - i - 1]); 21 printf(\u0026#34;%lld\\n\u0026#34;, ans); 22 return 0; 23} pE 一開始會想用 cal(R) - cal(L - 1)，但後來想到 L 會是 0，且減一其實有點小麻煩，所以就用 cal(R) - cal(L - 1)，如果 L 是 rainbow number 就再把答案加一。 另外也有把前綴是 0 的 case 獨立算出來，讓狀態定義的比官解簡潔。 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxn 105 4typedef long long ll; 5const ll mod = 1000000007; 6inline int d (char c) {return c - \u0026#39;0\u0026#39;;} 7int check(string s) { 8 for (int i = 1; s[i]; i++) 9 if (s[i - 1] == s[i]) return 0; 10 return 1; 11} 12ll cal(string s) { 13 int len = s.length(); 14 ll ans = 0, tmp = 1; 15 for (int i = 1; i \u0026lt; len; i++) { //長度小於 len 的數量 16 tmp = tmp * 9 % mod; 17 ans = (ans + tmp) % mod; 18 } 19 s = \u0026#39;0\u0026#39; + s; 20 ll dp[maxn][10][2] = {}; 21 dp[0][0][1] = 1; 22 for (int i = 1; i \u0026lt;= len; i++) { //長度等於 len 的數量 23 if (s[i] != s[i - 1]) // dp[i][j][1] 代表前 i 位和 s 一樣 24 dp[i][d(s[i])][1] = dp[i - 1][d(s[i - 1])][1]; 25 for (int j = 0; j \u0026lt;= 9; j++) { 26 for (int k = 0; k \u0026lt;= 9; k++) 27 if (k != j) dp[i][j][0] += dp[i - 1][k][0]; 28 if (d(s[i - 1]) != j \u0026amp;\u0026amp; d(s[i]) \u0026gt; j) 29 dp[i][j][0] += dp[i - 1][d(s[i - 1])][1]; 30 d[i][j][0] %= mod; 31 } 32 } 33 for (int i = 0; i \u0026lt;= 9; i++) 34 ans = (ans + dp[len][i][0] + dp[len][i][1]) % mod; 35 return ans; 36} 37int main () { 38 int T; cin \u0026gt;\u0026gt; T; 39 while (T--) { 40 string L, R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; 41 cout \u0026lt;\u0026lt; (cal(R) - cal(L) + check(L) + mod) % mod \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 42 } 43 return 0; 44} ","date":"2020-12-16T10:20:38+08:00","permalink":"https://luke2336.github.io/p/cptc/","title":"CPTC"},{"content":"CSES - 1197 - Cycle Finding 卡車說可以從一個假點開始做 SSSP，也就是將所有點的距離都先設成 0。 我的寫法複雜度看起來不好，感覺假解了，但想不到該怎麼改，可能會 TLE。 想了一個確定複雜度是 O(VE) 的解，將整張圖做 SCC，形成一個 DAG，從每個 in-degree 為 0 的 SCC 選一個點做 DFS。 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, ll\u0026gt; pii; 5#define pb push_back 6vector\u0026lt;int\u0026gt; ans; 7vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G; 8vector\u0026lt;bool\u0026gt; visit; 9vector\u0026lt;bool\u0026gt; use; 10vector\u0026lt;ll\u0026gt; dis; 11int dfs(int v) { 12 use[v] = visit[v] = true, ans.pb(v); 13 for (pii e : G[v]) { 14 int u = e.first; 15 ll w = e.second; 16 if (dis[u] \u0026lt;= dis[v] + w) continue; 17 dis[u] = dis[v] + w; 18 if (visit[u]) return u; 19 int ret = dfs(u); 20 if (ret) return ret; 21 } 22 visit[v] = false, ans.pop_back(); 23 return 0; 24} 25int solve(int n) { 26 for (int i = 1, ret; i \u0026lt; n; i++) 27 if (!use[i] \u0026amp;\u0026amp; (ret = dfs(i))) return ret; 28 return 0; 29} 30bool SPFA (int n) { 31 queue\u0026lt;int\u0026gt; q; 32 vector\u0026lt;int\u0026gt; cnt(n); 33 vector\u0026lt;bool\u0026gt; inque(n); 34 for (int i = 1; i \u0026lt; n; i++) { 35 if (cnt[i]) continue; 36 inque[i] = 1, q.push(i); 37 while (!q.empty()) { 38 int u = q.front(); q.pop(); 39 inque[u] = false; 40 for (pii p : G[u]) { 41 int uu = p.first; ll w = p.second; 42 if (dis[uu] \u0026gt; dis[u] + w) { 43 dis[uu] = dis[u] + w, cnt[uu]++; 44 if (cnt[uu] \u0026gt; n) return false; 45 if (!inque[uu]) inque[uu] = true, q.push(uu); 46 } 47 } 48 } 49 } return true; 50} 51int main() { 52 ios_base::sync_with_stdio(0); cin.tie(0); 53 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; n++; 54 G.resize(n), visit.resize(n), dis.resize(n), use.resize(n); 55 for (int i = 0; i \u0026lt; m; i++) { 56 int a, b; ll c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; 57 if (a == b \u0026amp;\u0026amp; c \u0026lt; 0) // loop 58 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 59 G[a].pb(pii(b, c)); 60 } 61 if (SPFA(n)) { cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; return 0;} 62 int v = solve(n), flag = 0; 63 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; 64 for (int x : ans) { 65 if (x == v) flag = 1; 66 if (flag) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 67 } 68 cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 69 return 0; 70} ","date":"2020-12-05T22:36:18+08:00","permalink":"https://luke2336.github.io/p/negative_cycle/","title":"有向圖找負環 (Negative-Cycle)"},{"content":"CF-GYM100274 pA 問題：2 \u0026lt;= n \u0026lt;= 1e18，2 \u0026lt;= k \u0026lt;= 1e12，求 n! 是 k 的幾次方。 作法：將 k 做質因數分解，然後各自算出次方數後，再取最小值。 時間：$$O(\\log n \\sqrt k)$$ 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;ll, int\u0026gt; pli; 5vector\u0026lt;pli\u0026gt; prime_factor (ll k) { 6 vector\u0026lt;pli\u0026gt; ret; 7 for (ll i = 2; i * i \u0026lt;= k; i++) { 8 if (k % i) continue; 9 pli p = pli(i, 0); 10 while (k % i == 0) k /= i, p.second++; 11 ret.push_back(p); 12 } 13 if (k \u0026gt; 1) ret.push_back(pli(k ,1)); 14 return ret; 15} 16int main() { 17 ios_base::sync_with_stdio(0); cin.tie(0); 18 int T; cin \u0026gt;\u0026gt; T; 19 while (T--) { 20 ll n, k, ans = -1; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; 21 vector\u0026lt;pli\u0026gt; fac = prime_factor(k); 22 for (pli p : fac) { 23 ll cnt = 0, m = n; 24 while (m) cnt += (m = m / p.first); 25 cnt /= p.second; 26 if (ans == -1 || cnt \u0026lt; ans) ans = cnt; 27 } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 } return 0; 29} pB 問題：給定兩個相同長度的字串，問能不能各自找到長度至少一半的子字串，使得字元和字元兩兩的絕對值差不超過 1。例如 \u0026ldquo;aabb\u0026rdquo; 和 \u0026ldquo;bbbb\u0026rdquo; 就是符合的。 作法：平移後，對重疊處做最大連續和。 時間：$$O(n^2)$$ 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 ios_base::sync_with_stdio(0); cin.tie(0); 5 int T; cin \u0026gt;\u0026gt; T; 6 while (T--) { 7 int n; cin \u0026gt;\u0026gt; n; 8 string a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 9 int ans = 0; 10 for (int i = 0; i \u0026lt; n; i++) { 11 for (int j = 0, sum = 0; j + i \u0026lt; n; j++) 12 if (abs(a[j] - b[j + i]) \u0026lt;= 1) 13 ans = max(ans, ++sum); 14 else sum = 0; 15 for (int j = 0, sum = 0; j + i \u0026lt; n; j++) 16 if (abs(a[j + i] - b[j]) \u0026lt;= 1) 17 ans = max(ans, ++sum); 18 else sum = 0; 19 } 20 if (ans * 2 \u0026gt;= n) cout \u0026lt;\u0026lt; \u0026#34;POSITIVE\\n\u0026#34;; 21 else cout \u0026lt;\u0026lt; \u0026#34;NEGATIVE\\n\u0026#34;; 22 } 23 return 0; 24} pC Topological Sort pD 暴力枚舉＋剪枝 pE DP pF 水題 pG 幾何實作 pH DP pI Flow pJ 找樹的半徑。 pK Coloring on Plannar Graph pL DP ","date":"2020-12-03T23:56:03+08:00","image":"https://luke2336.github.io/p/cf_gym_100274/CF_GYM_100274_Standing_hu86de04910a8cc0bed8d9ac64ef74d33f_119393_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/cf_gym_100274/","title":"Codeforces GYM 100274"},{"content":"Codeforces Round #615 (Div. 3) 第一次 CF 賽中破台，排名 +178，總算 1700 了。 pD 稍微想了一下子，pE 實作上卡了很久，有些邊界問題沒考慮清楚。pF 想了一下子才發現很好寫，但忘了考慮一直鏈的情況，所以 WA 了一次。\nA. Collecting Coins 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long LL; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 int t; cin \u0026gt;\u0026gt; t; 7 while (t--) { 8 LL a, b, c, n; 9 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; n; 10 LL sum = n + a + b + c; 11 if (sum % 3) { 12 cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; 13 continue; 14 } 15 sum /= 3; 16 if (sum \u0026lt; a || sum \u0026lt; b || sum \u0026lt; c) { 17 cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; 18 continue; 19 } 20 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; 21 } 22 return 0; 23} B. Collecting Coins 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4#define x first 5#define y second 6int main() { 7 ios::sync_with_stdio(0), cin.tie(0); 8 int t; cin \u0026gt;\u0026gt; t; 9 while (t--) { 10 int n; cin \u0026gt;\u0026gt; n; 11 vector\u0026lt;pii\u0026gt; p(n); 12 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 13 sort(p.begin(),p.end()); 14 bool success = true; 15 for (int i = 1; i \u0026lt; n; i++) 16 if(p[i].x \u0026lt; p[i-1].x || p[i].y \u0026lt; p[i-1].y) 17 success = false; 18 if(!success) { 19 cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; 20 continue; 21 } 22 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; 23 int xx = 0, yy = 0; 24 for(int i = 0; i \u0026lt; n; i++) { 25 while (xx != p[i].x) cout \u0026lt;\u0026lt; \u0026#34;R\u0026#34;, xx++; 26 while (yy != p[i].y) cout \u0026lt;\u0026lt; \u0026#34;U\u0026#34;, yy++; 27 } 28 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 29 } 30 return 0; 31} C. Product of Three Numbers 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int t; cin \u0026gt;\u0026gt; t; 6 while (t--) { 7 int n; cin \u0026gt;\u0026gt; n; 8 vector\u0026lt;int\u0026gt; ans; 9 for (int i = 2; i * i \u0026lt;= n \u0026amp;\u0026amp; ans.size() \u0026lt; 2; i++) { 10 if (n % i) continue; 11 ans.push_back(i); 12 n /= i; 13 } 14 if (ans.size() != 2 || n \u0026lt;= ans.back()) { 15 cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; 16 continue; 17 } 18 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; 19 ans.push_back(n); 20 for (int i = 0; i \u0026lt; 3; i++) 21 cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==2]; 22 } 23 return 0; 24} D. MEX maximizing 每次新增一個數字到序列裡，可對序列每個數字任意加減x的整數倍，問操作完後，序列中所缺的最小正整數最大是多少？\n一開始可以確定答案不可能超過當前 query 的次數，且答案會單調遞增。可以知道 y[i] 可以加減 x 的整數倍，故可以直接 y[i] 紀錄 mod x 出現幾次，然後將答案往後爬。複雜度 O(q)。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define MAX 800005 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 int q, x; cin \u0026gt;\u0026gt; q \u0026gt;\u0026gt; x; 7 int ans = 0; 8 int cnt[MAX] = {}; 9 for (int i = 0; i \u0026lt; q; i++) { 10 int a; cin \u0026gt;\u0026gt; a; 11 cnt[a % x]++; 12 while (cnt[ans % x]){ 13 cnt[ans % x]--; 14 ans++; 15 } 16 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 17 } 18 return 0; 19} E. Obtain a Permutation 只需要將每個 column 單獨計算，再將所有結果相加即可。\n單一個 column，對每一格去算到達正確位置需要幾次操作，用個陣列去計算，轉 k 次能讓多少個格子到達正確位置。總複雜度 O(mn)。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define MAX 200005 4int cnt[MAX] = {}; 5int main() { 6 ios::sync_with_stdio(0), cin.tie(0); 7 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a(n, vector\u0026lt;int\u0026gt;(m)); 9 for (int i = 0; i \u0026lt; n; i++) 10 for (int j = 0; j \u0026lt; m; j++) 11 cin \u0026gt;\u0026gt; a[i][j]; 12 int sum = 0; 13 for (int j = 0; j \u0026lt; m; j++) { 14 for (int i = 0; i \u0026lt; n; i++) { 15 if (a[i][j] \u0026lt;= n * m \u0026amp;\u0026amp; (j+1) % m == a[i][j] % m) { 16 int ii = (a[i][j] - 1) / m; 17 cnt[(i + n - ii) % n]++; 18 } 19 } 20 int ans = MAX; 21 for (int i = 0; i \u0026lt; n; i++) { 22 ans = min(ans, n - cnt[i] + i); 23 cnt[i] = 0; 24 } 25 sum += ans; 26 } 27 cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 return 0; 29} F. Three Paths on a Tree 找出相異三點，使得兩兩之間的路徑聯集起來邊數最多。\n若樹為一直鏈（竹子），則答案為兩端點，和中間任一點。其餘的情況，可以確定答案必有一點落在直徑上，且三點皆為葉子。故先做兩次 BFS 找出直徑，再做樹 DP 得到答案。複雜度 O(n)。\n1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define maxn 200005 4vector\u0026lt;int\u0026gt; v[maxn]; 5bool visit[maxn] = {1,1}; 6typedef pair\u0026lt;int, int\u0026gt; pii; 7int ans = 0; 8int out[3]; 9pii dfs(int u, int dep, int scr) { 10 visit[u] = true; 11 int mx1 = 0, mx2 = 0, a1 = u, a2 = u; 12 for (int uu : v[u]) { 13 if(visit[uu]) continue; 14 pii d = dfs(uu, dep + 1, scr); 15 if (d.first \u0026gt;= mx1) 16 mx2 = mx1, a2 = a1, mx1 = d.first, a1 = d.second; 17 else if (d.first \u0026gt; mx2) 18 mx2 = d.first, a2 = d.second; 19 } 20 if (mx1 + mx2 + dep \u0026gt;= ans) { 21 ans = mx1 + mx2 + dep; 22 out[0] = scr, out[1] = a1, out[2] = a2; 23 } 24 return pii(mx1 + 1, a1); 25} 26int main() { 27 ios::sync_with_stdio(0), cin.tie(0); 28 int n; cin \u0026gt;\u0026gt; n; 29 for (int i = 1; i \u0026lt; n; i++) { 30 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 31 v[a].push_back(b), v[b].push_back(a); 32 } 33 queue\u0026lt;int\u0026gt; q; 34 int a = 1; 35 q.push(1); 36 while (!q.empty()) { 37 int u = q.front(); q.pop(); 38 a = u; 39 for(int uu : v[u]) 40 if (!visit[uu]) 41 visit[uu] = true, q.push(uu); 42 } 43 int b = a; 44 memset(visit, 0, sizeof(visit)); 45 q.push(a); 46 while(!q.empty()) { 47 int u = q.front(); q.pop(); 48 b = u; 49 for (int uu : v[u]) 50 if (!visit[uu]) 51 visit[uu] = true, q.push(uu); 52 } 53 memset(visit, 0, sizeof(visit)); 54 dfs(a, 0, a); 55 memset(visit, 0, sizeof(visit)); 56 dfs(b, 0, b); 57 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 58 if (out[1] == out[2] || out[0] == out[2]) { 59 for (int i = 1; i \u0026lt;= n; i++) 60 if (i != out[0] \u0026amp;\u0026amp; i != out[1]){ 61 out[2] = i; 62 break; 63 } 64 } 65 for (int i = 0; i \u0026lt; 3; i++) 66 cout \u0026lt;\u0026lt; out[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == 2]; 67 return 0; 68} ","date":"2020-01-24T11:26:38+08:00","image":"https://luke2336.github.io/p/cf_contest_1294/Standing_hub14a319cfdec87b6d002912f49ac6bcd_142700_120x120_fill_box_smart1_3.png","permalink":"https://luke2336.github.io/p/cf_contest_1294/","title":"Codeforces Round #615 (Div. 3)"},{"content":"這篇是遊記＋比賽紀錄，所以就寫得很零碎了。 本來就很想寫這篇，但一直拖到寒假才有空～～\n為什麼去日本呢？ 因為去日本高機率會被電爆，假如要去確實不應該在我們想拿票時去。外國隊名額有限，交大只能派一隊，但剛好沒人要跟我們搶。\n我亂分析了一下，日本是實作、數學、幾何題比較多，我們隊有實作大師，似乎還行。日本似乎沒有東南亞那麼多模板題，對我們這種剛開始打的菜鳥似乎比較沒那麼虧。\n日本雖然沒有官方旅遊行程，但自己玩也很棒，雖然物價有點高。\n行前 暑假一知道可以出國就去辦了台北辦護照，順便回北一女逛了一下。\n出國前三天去旅行社弄了 48hr 的東京地鐵券。\n因為懶得排行程，排行程似乎變因過多，我們決定第四天自由行，第五天去淺草逛逛。\n因為我們原本想住的旅館看起來很不恰當，於是被教練說服比賽期間都跟他住商務旅館（鶴見東橫Inn）。\n日本賽制是不限參考資料頁數，但我們還是決定帶彩色的 25 頁 codebook 和一本字典。\n賽前有練習或討論了超過 5 年的考古。\nDAY1 因為怕打太爛，比賽前不敢排旅遊行程，於是搭 18:25(+8)-22:05(+9) 的飛機。\n跟教練搭計程車，所以提早了不少到機場，但因為我不到20歲，搞保險搞了好久。然後就是人生第一次搭飛機了，幸好我不是一個人出國。\n我們在機場還很認真的研究考古題，上飛機後就開始研究飛機餐了，隊友超愛吃奶油。\n下飛機後，領完行李後，我花了三分鐘弄了張免費網卡，詳請請參考這篇，結果最後只用了 100/500MB。\n然後就搭京急去旅館睡覺了，氣溫雖然不到 15 度，但因為濕度很低，所以感覺不冷，隊友直接只穿一件 T-shirt＋超薄外套。\nDAY2（測機日） 本來這天下午應該要在台灣考演算法概論上機考，有兩個選項，一個是期末算兩倍，另一個是在日本考。我們選擇在日本的 7:00-11:00 考，當作練手感。毫無意外地，小爆炸了一下。\n中午在橫濱市區吃 KFC，日本的 KFC 超好吃的！\n然後準時的抵達賽場，教練似乎跟日本人很熟，我們報到完他就去外交了。台大 wa\u0026hellip;123 坐在我們背後兩組，他們NPSC坐在我們左邊，真是有緣啊！\n他們的系統教學示範超生動的，讓我們好想再去日本比一次。\n桌子的佈局是兩張長桌，放成L型。\n然後就是測機了，全部都是考古題，有幾題上飛機前看過。有一題是暴力枚舉，但我隊友不會寫遞迴枚舉，於是我只好去摸鍵盤了（鍵盤手感不錯）。\n之後是自我介紹時間，事前會叫你交一頁投影片，另外還會給一本印有各隊介紹的本本，很多好玩的ascii圖。清大比我們早了幾天到日本，他們先去寶可夢樂園血拼，於是就全套寶可夢上去介紹。\n牆上有先放隔天的氣球，於是知道總共有11題。有提供點心區和餐盒，於是我很認真的研究了隔天要吃什麼點心。（我們是離點心最近的位置）\n晚上，教練請我們吃燒肉，牛橫膈超好吃的！然後去車站逛了超市。\nDAY3（比賽日） 我雷我抱歉，我鬧鐘又設到晚上了，幸好教練發現我沒出現，就直接 morning call，不然就慘了。然後匆匆忙忙的吃了早餐，隊友也一副沒睡飽的樣子。\n我們即時抵達賽場，教練忙台北站忙到快掛了，就先回去旅館休息。進去後，桌面佈局維持我們前一天調好的樣子。\n比賽提早了五分鐘開始，主席倒數的好嗨好可愛。\n開場就按照策略先把該抄的東西抄好，雖然他們本身很貼心的有提供一些快速編譯的指令。\n然後因為日本有確定 pApB 一定是最水的，於是我們 pB 在 00:23 先AC，pA 有點卡，於是 00:32 才 AC。\n然後 pH 是括號匹配，搭上刪除操作，因為我們把他想成可以用 map 或線段樹之類的弄，想的有點複雜，但感覺做得掉，就交給學弟先寫。\npG 看起來有機會，是我以前打北市賽遇過的類似題，但我真的想不太到，就果決的先丟一旁。\n這時我和雙曲線有想到 pE，用一些條件判斷哪些不能放同一堆，可以建出圖然後做 bicoloring，然後背包 dp 一下，三個人合力寫掉（雖然學弟始終不知道題目），2:36 一次 AC。\n這時我和雙曲線已經把所有題目了解。我們排名在前半段，跟台大清大題數一樣，我們 penalty 不高，贏過清大。\n估計了一下時間大概再開兩題左右，打算瞄準 pG 和 pH。\n學弟發現我們之前的想法不太可行，於是我突然想到有些東西應該用 stack 的結構維護，然後做二分搜，配上線段樹做修改之類的。\n於是他就繼續寫下去，我們到了剩一個半鐘頭時，覺得不太妙，就三個人一起開始debug，先是發現線段樹抄爛，然後還有一些 bug，最後就邊想 pG 邊 debug，終於在 4:42(+4 penalty) 把 pH 解掉，理論上應該會贏清大，於是還滿爽的。\n4:30 就封版了，但清大之後就沒有上傳了\u0026hellip;\n我們用一些暴力的寫法去弄 pG，當作垂死掙扎，奮戰到最後一秒。\n賽中，我因為身體不舒服，一直在嗑巧克力\u0026hellip;（點心和飲料可以帶到座位，超棒的）\n贏了清大，所以我們競程二及格了。\n因為太興奮，不小心放飛了一顆氣球，賽區主席看到後，馬上吩咐人幫我們用竿子拉下來，真的是太感謝了。因為封板解出 pH，我們決定把一顆氣球藏在外套裡，給教練驚喜。但一看到教練，又不小心讓氣球飛掉了，嗚嗚～\n賽後是題解，我覺得還可以，大半都聽得懂，這部分很棒。\n開獎機很棒，我們最終拿了 27 名，符合預期，算正常發揮範圍內，除了 pH 的 penalty。\n然後是晚宴，頒了一堆企業贊助獎，我們拿了兩個「有女生的隊伍第一名」，清大拿了「4, 14, 40」的40名獎，台大最後上台拿了「沒被頒到獎的最高名次」 回去後，其中一個是印著行動電源的紙＋漂亮資料夾，另一個是 ¥10000 的日本 Amazon 禮卷，人品敗光光！\n因為顧著拿企業攤位的贈品，於是我們晚宴幾乎都沒吃東西。\n之後，我們就和教練分開，拖著行李箱跑去東京了。\n選擇住在南千住實在不是個好選擇，交通沒有想象中方便。\nDAY4 和隊友分開行動，雖然前一天累到快死掉，但還是早早起床。\n但我真的不會日文，原本是想從三之輪站到北千住換千代田線，但最後變成「三之輪-北千住-押上-住吉-新宿三目町-明治神宮前」，換了這麼多次車，上班時間的電車爆擠，又比預期多花了超過半小時。\n然後就到「明治神宮」了，原本出門時在下雨，到這裡已經變大太陽了。剛好碰上菊花展，且 11 月剛好是七五三節左右，在每個神社都有看到相關的活動公告。\n走過了一排排神木，很難想像東京這種大都市竟然有一大片森林，超棒的！酒桶牆看起來很壯觀，滿喜歡的！\n雖然是平日，但還是不少遊客。有隨手買了一本朱印帳做紀念。\n然後因為很想賞楓，於是就近去了「代代木公園」，好像稍微去晚了一個禮拜，葉子掉的差不多了QQ但見到了超多超多的烏鴉，也算是有收穫吧？\n中午就去原宿逛「竹下通」，只買了一些小東西，但還是好重。\n吃了日本的可麗餅當午餐，不像台灣的是脆脆的，他們是軟軟的，我點的是草莓配上一球冰淇淋，感覺還行。\n順便路過了一下「原宿車站」，回去才知道他即將拆掉，賺到了XD\n然後去逛了「東鄉神社」，算是很喜歡的一個，雖然外型不太出眾，但牆上一些關於歷史故事的畫作卻讓我忍不住多花了一點時間停留，順便祈求了一下隔週台北站的勝利！\n然後就準備前往新宿御園，但因為去了東鄉神社，然後迷了點小路，加上日本的公車很複雜又沒有里程價，算一算快天黑了，腳也走到破皮了，就決定去新宿逛點街，然後再去都廳看夜景。\n最後剛好走錯出口，去逛了「花園神社」。\n然後逛了一家文具店「世界堂」，七層樓逛起來很棒，順便買些禮物給閨蜜，我承認我好沒逛街效率\u0026hellip;\n然後去「東京都廳」45 樓北展望室 (202m) 看夜景，大約排了半小時的隊，搭電梯前需要先通過簡單的安檢，人數管控的還行，只是玻璃上反光較嚴重。可以看到同時看到東京鐵塔、晴空塔，還是免費的，真的很推！\n接著就搭丸之內線到「東京車站」找隊友會合，一起吃了義式料理當晚餐，去百貨公司逛了超市。\n回去旅館時小小迷了點路。\nDAY5 因為傍晚就要搭飛機回去了，於是今天就全隊一起行動。天氣濛濛的，我們去了淺草寺，然後到隅田川旁時天空放晴，看到了晴空塔。隊友太喜歡 KFC 了，於是又去買了 XD\n之後主要都是隊友的伴手禮任務，我們在淺草橋吃完好吃的牛丼，才 ¥600，真是太棒了。隊友點多肉 ¥1150，滿滿的肉看起來超棒的！\n然後去了上野，分頭行動一小時，我去了上野公園。然後就搭京成去機場了，然後我被隊友慫恿，於是買了不少伴手禮，然後才想起來自己沒朋友 QAQ\n心得 第一次出國，很多不懂的事都有隊友 carry，真的超愛他們的！隔週去完台北站之後，覺得日本的比賽品質真的很棒，很開心人生的第一場 ICPC 是去日本。不過沒有逛到橫濱有點可惜，那邊感覺也很棒。\n原本出國前被功課搞到崩潰，出國散散心的感覺很棒，超不想回國的！這次留了一天的時間各自行動，確實是個好選擇！一個人在街上逛的感覺真的很好。\n日本的題目真的好硬，幸好我們有練了幾套考古，不然真的會打到哭。\n台大最強隊來日本也炸了，要來日本拿票真的不容易。\n","date":"2020-01-12T16:13:01+08:00","image":"https://luke2336.github.io/p/icpc-yokohama/16_hua0ebc91307f0a5d1904735782a86fd4d_3463151_120x120_fill_q75_box_smart1.JPG","permalink":"https://luke2336.github.io/p/icpc-yokohama/","title":"2019 ICPC Yokohama Regional"},{"content":"NCTU_Pusheen的第一場ICPC賽制比賽。 （角色：我、隊友H、隊友U） 好像有點太早到了，9:30開始，我們8:05就全到了。 然後就開始討論選課的事，還有推廣了「貼圖大戰」。 似乎三個人還是有點緊張，隊友U算是最淡定的一個，於是就讓他坐電腦前了。只有九隊而已，真的很怕墊底。（明明前一天的新生賽才拿第一，但就是莫名沒自信QQ）\n解題 M很水，於是隊友H就用接近首殺的速度把M殺了。然後我發現K很水，然後就讓隊友U把他殺了，然後過程中順便想出了K的構造題 Ｉ，原本差點就傳了，但剛好發現範圍到10^32，於是改用python寫掉，於是K和Ｉ都拿到首殺，這時大致過了半小時。\n然後，我發現F似乎是簡單的DP建表，於是就丟給隊友U寫。 因為G明顯是我不擅長的幾何題，於是丟給隊友H，隊友H就想出了一個假解，因為我懶得驗證正確性，也不覺得有其他簡單的作法，於是就丟上去讓他WA了。\nE是一題矩陣題，賽中我覺得高斯消去能解，但隊友U阻止了我，提醒我高斯做出來不一定是整數。賽後這題似乎是能用高斯加一些處理弄過。\n因為ABC的題序一樣，然後都沒靈感，於是就先擺著。J看得出來是DP，但以為沒這麼簡單，就擺一邊了，事後證明是個錯誤決定。\n此時沒有人解出其他題目，於是就決定去開D和L。\nD一開始以為是Dijkstra，後來WA了之後，證出等號成立時轉移會出事，於是我就想出了一個二分搜解，但因為複雜度卡卡的，於是繼續在Dijkstra上繞圈圈。然後在最後三十分鐘，隊友U想出了一個具體的二分搜＋BFS作法，但因為搜的東西不對，無法剪枝，於是常數太大，吃了TLE。\nL大概是解出來最爽的一題，花了超過一小時。隊友H先推出大致的規律，然後我用了類似前綴和的東西，把空間和時間壓到lgN，然後交給隊友H和U寫。但賽後證實我們賽中想過本機跑分塊的作法也能喇過。\nA後來有兩隊解出來，於是也稍微想了一下，猜是要建圖，但真的想不出來。\n嗯，看到最後會發現我好像沒碰過鍵盤呢！！\nL的題解 題目是將L到R(0~1e9)的二進位字串接起來，然後求這個字串的1和0共有幾段。例如1~5，表示成11011100101，答案為7。\n隨手寫了一篇題解：2019交大年度賽pL非官方題解\n","date":"2019-09-04T11:13:48+08:00","image":"https://luke2336.github.io/p/nctu_annual_contest_2019/standing_hubf2963efbed711d1f57345cd941c0639_69122_120x120_fill_q75_box_smart1.jpg","permalink":"https://luke2336.github.io/p/nctu_annual_contest_2019/","title":"交大 2019 年度賽"},{"content":"此篇是從舊 Blog 搬過來。\nZerojudge a813 - 4. 城市觀測 題目敘述 有 N 棟房子。對於任意 AB 兩棟房子，只要 AB 中間沒有房子的高度超過 A 或 B，則 A 可看見 B。求 1 ~ N 每棟房子可看見的房子總數。\n測資一，0 \u0026lt; N ≤ 300，0 \u0026lt; H[i] ≤ 1e5，3/17分 測資二，0 \u0026lt; N ≤ 5000，0 \u0026lt; H[i] ≤ 1e5，3/17分 測資三，0 \u0026lt; N ≤ 1e6，0 \u0026lt; H[i] ≤ 1e9，11/17分 範例測資 N = 2，H = {1,1}，ans = 1+1 = 2 N = 3，H = {1,2,3}，ans = 1+2+1 = 4 N = 5，H = {5,2,3,4,4}，ans = 4+2+3+3+2 = 14 參考解法 「A 可看見 B」和「B 可看見 A」等價，因此只要計算一半就好了，也就是可以將問題簡化成，計算每棟房子往左看的sum x 2。\n最直接的做法就是直接 O(N²) 掃過，但第三筆測資顯然需要 O(NlgN) 才有可能 AC。\n因為先寫了 TIOJ 1176 Cows 這題，所以就想到用 stack 去維護遞減性，但因為 stack 無法很計算等號成立的部分，所以 google 了一下，恍然大悟，直接用 array 模擬 stack 解決了，還可以搭配 binary search 達到 O(NlgN) 的時間複雜度。\nTIOJ 那題的複雜度是 O(N)，因為每個元素最多進出 stack 一次，超類似單調隊列！\n為什麼要維護單調性？ 假設我們是由左而右計算，每棟大樓都只能往左看，那只要某數右方有大於它的數，那它就不可能被更右方的數看到。 所以我們就是要維護一個左高右低的梯形/三角形。\n每加入一個數，檢察它左邊的數，如果比他低，就不可能被更後面的數看見，也就可以 pop 掉，之後也不需要檢查。\n而在 stack 裡的數，可以保證單調遞減，也就是中間不會有更高的數，所以只要比你低，一定能被看見，於是 pop 前，將 ans++。\n檢查到一樣高的數時\u0026hellip;\u0026hellip; 麻煩的地方就在這，你不知道在他之前有幾個數和他一樣，但一個一個 pop 再 push 進去實在很浪費時間，例如全部都一樣高的 case，效率會變 O(N²)。於是改成用array來操作，雖然不用 pop 再 push，但查找時一樣是 O(N²)。\n二分搜優化 要徹底解決 O(N²)，還是需要二分搜啦！直接二分搜 stack 最後一個大於等於他的位置就可以加減出答案。\n有單調性的東西就給他二分搜下去吧～\nCode 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4#define maxn 1000005 5int a[maxn], st[maxn]; 6int main() { 7 int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); 8 for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 9 ll ans = 0; 10 int top = 0; 11 for (int i = 1; i \u0026lt;= n; i++) { 12 if (top) { 13 //binary_search 14 int k = 0, left = 1, right = top; 15 while (left \u0026lt;= right) { 16 int mid = (left + right) \u0026gt;\u0026gt; 1; 17 if (st[mid] \u0026gt;= a[i]) 18 k = max(mid, k), left = mid + 1; 19 else right = mid - 1; 20 } 21 ans += top - k; 22 top = k; 23 } 24 if (top) { 25 int k = 0, left = 1, right = top; 26 while (left \u0026lt;= right) { 27 int mid = (left + right) \u0026gt;\u0026gt; 1; 28 if (st[mid] \u0026gt; a[i]) 29 k = max(mid, k), left = mid + 1; 30 else right = mid - 1; 31 } 32 ans += top - k; 33 if (k) ans++; 34 } 35 st[++top] = a[i]; 36 } 37 printf(\u0026#34;%lld\\n\u0026#34;, ans * 2); 38 return 0; 39} ","date":"2018-08-07T09:52:33+08:00","permalink":"https://luke2336.github.io/p/zj_a813/","title":"Zerojudge a813 - 城市觀測"},{"content":"UVA 106 - Fermat vs. Pythagoras 題目敘述 輸入 N (1 ≤ N ≤ 1000000)，求X² + Y² = Z²（0 \u0026lt; X \u0026lt; Y \u0026lt; Z ≤ N）的解中\n三數互質 gcd(X, Y, Z) = 1 的解有幾組 １ ~ Ｎ 中有幾個正整數沒被任何一組解包含 解法 原本想枚舉 Y 和 Z，但時間上會是 10¹¹ 等級，顯然不是一個好方法。\n這時，突然想到了「畢式三元數」(Pythagorean triple)，畢竟每次數學培訓上數論都會講到，前幾天翻數學競賽的書也剛好看到，不過似乎只針對「互質畢式三元數」討論而已。\n「互質畢式三元數」性質如下：\nX, Y, Z ∈ 𝚴，X² + Y² ＝ Z² 且 gcd(X, Y, Z) = 1，則可表示為\nX = m² - n² Y = 2mn Z = m² + n² 其中 m \u0026gt; n，gcd(m, n) = 1，m, n 為一奇一偶。\n這題的範圍不僅僅限於 gcd(X, Y, Z) = 1， 但只要將每組「畢式三元數」除以 gcd(X, Y, Z)，就都能變成「互質畢式三元數」了。換句話說，「畢式三元數」一定是由某一組「互質畢式三元數」乘ｋ倍而來。 表示為 X = k (m² - n²)，Y = 2kmn，Z = k (m² + n²)。\n考慮 m, n 的範圍，1000000 ≥ N ≥ Z ＝ m² + n²，得 1000 ≥ √N ≥ m \u0026gt; n ≥ 1。 枚舉 m, n的時間為 10⁶ 等級，明顯能快很多。\n我的方法是跑一層 for 枚舉 m，裡面再跑一層 for 枚舉 n，if(gcd(m, n) == 1)，則跑一層 k。\n寫完後，丟到 UVA 上排名 21，時間 0.050。 （第一名 0.008，我超好奇怎麼辦到？） 天啊！這真的怪爆了，我到底哪裡比別人快啊？於是 google 了別人的解法。\n看到大部分的人都是對每筆輸入 N 跑一次 for m in range(1,sqrt(N))，這方法我沒想到\u0026hellip;\u0026hellip;因為我寫 DP 寫中毒了，於是動不動就想直接給他一次找完，也就是直接「建表」。\n這題的數論難關解決後，建表的過程確實有點卡，於是就來記一下重點部分。\n大部分人是直接開個 bool 紀錄數字出現過了沒，還有開個變數紀錄有幾組互質的。\n首先，來談互質的組數 p。用 DP 的角度切入，p[i] 和 p[i-1] 有關嗎？\np[i] = p[i - 1] ＋ (z == i 的互質組數)。 所以就開個 cnt 陣列紀錄，每找到一組互質畢式三元數，cnt[Z]++。p[N]就是cnt[N]的前綴和，O(N)一次做完即可。\n接著，是算有幾個沒用過的數。1 ~ i + 1 會比 1 ~ i 多一個數能用，而 1 ~ i 用過的數 1 ~ i + 1 也同樣被用過。num[i + 1] ＝ num[i] + 1 - (有幾個數在 Z == i + 1 時才出現)。所以重點是計算有幾個數在 Z = i + 1 時第一次出現，也就是紀錄每個數搭配的 Z 的最小值，最後在掃過一遍就行了。\n因為都是由互質三元數去找其他三元數，所以不會找到重複的，所以效率佳。寫這篇時發現自己沒有應用到一奇一偶的性質，改成 n += 2 後，丟到UVA上排名 13，時間 0.040。\nCode 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3#define MAX 1000001 4int f[MAX], num[MAX], p[MAX], ans[MAX] = {0, 1}; 5inline bool coprime(int x, int y, int z) { 6 return __gcd(__gcd(x, y), z) == 1; 7} 8int main() { 9 fill(f, f + MAX, MAX); 10 for (int m = 2; m \u0026lt; 1000; m++) 11 for (int n = (m \u0026amp; 1) + 1; n \u0026lt; m; n += 2) { 12 if (__gcd(m, n) != 1) continue; 13 int x = m * m - n * n, y = 2 * m * n, z = m * m + n * n; 14 if (z \u0026gt;= MAX) break; 15 if (coprime(x, y, z)) { 16 p[z]++; 17 for(int k = MAX / z; k \u0026gt;= 1; k--) { 18 int xx = x * k, yy = y * k, zz = z * k; 19 f[xx] = min(f[xx], zz); 20 f[yy] = min(f[yy], zz); 21 f[zz] = zz; 22 } 23 } 24 } 25 for(int i = 1; i \u0026lt;= MAX; i++) 26 p[i] += p[i - 1], num[f[i]]++; 27 for (int i = 2; i \u0026lt;= MAX; i++) 28 ans[i] = ans[i - 1] + 1 - num[i]; 29 int N; 30 while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;N) == 1) printf(\u0026#34;%d %d\\n\u0026#34;, p[N], ans[N]); 31 return 0; 32} ","date":"2018-07-04T10:13:53+08:00","permalink":"https://luke2336.github.io/p/uva_106/","title":"UVA 106 - Fermat vs. Pythagoras"},{"content":"為什麼會去資芽？ 會知道這個好活動真心感謝學校的老師和學姊宣傳XD\n第一次參加台大的資芽是在高一下時，那時是參加 python 語法班，原本也有想報名算法班，但是報名門檻有要寫題目，我好像離門檻還差半題的分數。但說真的，語法班的二階就已經讓忙碌的小高一吃不消了\u0026hellip;\u0026hellip;\n高二沒去資芽則是因為入芽考的時間剛好撞到社團寒訓。\n高三想說學測考得沒有很糟糕，六日也沒什麼事，就把握最後的機會報名了。\n資芽的內容 建議直接去 google 課程網比較清楚。\n課程形式 先在家看影片預習（1 ~ 1.5 hr），上課時討論及補充細節及更深的技巧，回家寫手寫作業（1 ~ 2 hr）和上機作業（3 ~ 5 題 + 1 ~ 2 題加分題，2 ~ 3 hr）。總之，每週在家至少要花4小時，但花到8小時也不是不可能。\n課程內容 大致上分成兩階段，第一階段其實不算太困難，有基本的資料結構（stack、queue、linked list、heap）、複雜度、圖論（tree、DFS、BFS）、Greedy、Binary search、Divide \u0026amp; Conquer、DP。 第二階段，每年的內容都不太一樣，固定會有的主題是 DP，其他主題有線段樹、字串匹配（KMP、Trie、Hash、Z-value\u0026hellip;\u0026hellip;）、shortest path。大部分都是我有聽過但不太敢碰的主題，但既然都花時間來了，就硬著頭皮學吧！反正總有一天要面對。個人是認為難度真的比一階難很多（其實一階結束就已經有 1/3 的人退了）。\n手寫作業 我覺得內容很廣泛，但大多是課程相關和一些常用到的知識，例如 hash、disjoint-set、NP-complete，有很大一部分都是證明題，需要一些數學或是強大的構造靈感，我到後面好像有點混，都在亂寫，一階時也是靠平安的幫忙。\n上機作業 每週 3 ~ 5 題，另外還有 1 ~ 2 題的加分題。有一半會是講過的範例，但還是有點難度。不會寫就去用FB私訊講師，他們人都不錯，而且提示都給得剛剛好，不會破壞你想題目的機會。\n課堂討論 這是我最喜歡資芽的原因，討論的過程可以讓你練習把自己的想法講得讓別人聽得懂，過程中和別人互相確認想法發現彼此的 bug，確認自己有真的聽懂，也能聽到很多不錯的想法。但我覺得大家好像都不太會主動找不熟的人討論，算是美中不足之處。\n兩次認證考 都是 3 小時 5 題，我覺得和上課教的東西相關性高但難度卻很高，建議盡量多拿部份分，我自己是兩次都拿不到 100 分（滿分500），但我認為拿 250 分左右是有機會的。\n歡樂團體賽 三個人一組，我跟裘莉和哆啦一組。7 題裡面，我們寫了 5 題。題目跟課程內容不太相關，我覺得裘莉很可憐，丟給他的題目都是不太好寫的題目。哆啦更可憐，她寫出來卻一直無法 AC，因為測試的程式出包\u0026hellip;\u0026hellip;我算是有貢獻吧，雖然其中一題其實是矇到，整個是錯的剛好沒被卡掉。歡樂的點可能是我們拿第二名吧！\n推資芽 雖然高三還是有不少書要讀，但還是覺得來資芽很值得，也因此認識了幾個好朋友。 很難的東西，第一次碰一定覺得它超恐怖，但多寫幾次就沒這麼恐怖了～ 來資芽一定要認真寫作業，不然來幹嘛！ 講師都很親切，但聽不懂請直接跟他們說，不然大神們其實不一定了解凡人的問題。 據說很多國手都是從這裡出產的，真的可以試著認識一下身邊的人。\n入芽考 我覺得有點小難度，因為我考學測的那段時間太少寫程式，手感不好。但認真覺得基本分拿一拿應該 150 分是不難的。\n其他 感謝 carry 的平安、哆啦、裘莉，還有講師們。 我好想上被我請掉的 3 堂課啊！！\n","date":"2018-07-02T11:33:59+08:00","permalink":"https://luke2336.github.io/p/sprout-2018/","title":"2018 資訊之芽 算法班 心得"},{"content":"寫這篇文其實是害怕自己某天忘了這段日子的美好回憶，那時很認真的每天寫日記，不過因為太累了，所以好像漏記了不少，就順便補上吧！\nDAY 1 四點半在師大本部報到，應該是前十個到的，發現自己看起來超與眾不同。\n穿著北一體育服：對！我很乖，請了公假還一早拖著行李箱上學，三點半才離開學校。南部來的早上翹課挺合理，但建中生表示他們已經請了好幾週公假了！！\n唯二的女生：我比較早到，所以剛開始就放下行李，去認識一群聊得挺嗨的男生。 Yunn 到的時候，互相打量了好一會，於是我決定主動去認識她，這選擇真的太對了，她其實不太怕生 XD\n沒帶大鍵盤：哇！大家除了筆電外都帶著大鍵盤耶！其實我入營考測機時就被某人的鍵盤聲弄到快崩潰，所以看到一堆鍵盤真的好可怕！！\n行李箱好迷你：我有第二小的行李箱，除了某遲到的人只背著書包外？\n報到完，就去吃飯了～我和Yunn選了一個大桌坐。男生似乎都想離我們遠遠的，但訂的位子有限，晚來的只好跟我們坐囉！等餐等超久的，於是我這個傻瓜就開始想認識別人了，印象中，同桌的有復旦、南一中、延平*２，我對他們的評價是一群不喜歡說話的人\u0026hellip;\u0026hellip;一吃飽他們就急著問輔導員可不可以先回房間。隔壁桌則比較歡樂，開心的打程式，應該是老朋友了！\n回房間後，我猜我是最早睡的，九點多就先睡了～（Yunn 認真讀化學）\nDAY 2 習慣性的早起，好像不到五點半吧！！\n睡不著就開始打理自己，想說寫個幾題熱身，於是就抱著書和筆電出去了！這時已經開始過敏，一定是因為被窩不夠暖 QQ不知為何我居然在寫 TIOJ！逆序數對怎麼樣都寫不出來（之後資芽有這題，原來要分治！）\n七點四十搭專車到分部，享用了早餐，每天都是三明治和漢堡交替，星期日吃飯糰，Yunn 真的超討厭早餐店的茶，於是之後晚點名的鋁箔包成了她的救星。\n這天的課表是「Graph basics」，早上是 flow，下午上 matching，我一整天都在流鼻水，雖然大致聽得懂，但實作上我真的有點障礙，心情一整個blue。\n中午到學七餐廳吃，有了北市賽的經驗，我馬上捨棄了自助餐這個選項，去吃豬排咖哩飯，90 元的餐卷真棒！！（據說從前只有 80 元，但因為去年那家店的價格是 89，釀成民怨，於是就加碼了！！但似乎有人吃自助餐吃到一百四？）\n傍晚時，有人來看我\u0026hellip;\u0026hellip;（略）安慰了我很受傷的心。\n晚上，自主練習\u0026hellip;\u0026hellip;八點半就放我們離開分部了。（累倒）\nDAY 3 是邦一的課，開心的一天！！\n早上在師大會館就遇到邦一了，Yunn 似乎早就認識他了～\n早上是 greedy，下午表定是 Interval，其實參雜了不少 DP。\n作業有 8 題，好像是開到星期天\u0026hellip;\u0026hellip;\n先寫了一題 FCFS 排程（Greedy），然後試著寫帶權LIS，但真的寫不出來 QQ\n晚上終於發了 I2A，今年特別高級，是硬殼版的！！\nDAY 4 早上是自主練習，於是我就多次請教背後的 map 大神 wLIS，他救了我，超感激！還讓我認識了 map 的很多用法。其他人似乎忙著打 JOI，但我還是繼續嘗試邦一的題目，AC 了 independent tree（tree DP）、interval domination、給一堆線性函數求和的最大值（二分搜），總算跟上大部分人的進度了。\n表定下午和晚上是 MST 和 Shortest Path，但香港人教授似乎聽說我們很強，於是上很快，拓樸排序、SSSP、MST、APSP，似乎上了兩小時他就走了。晚上只好變成自主練習，但我真的好累，於是就和男生們去玩拉密了（開啟耍廢狀態），但至少稍微和周柏宇和陳冠宇他們熟了一點點～\nDAY 5 早上同樣是自主練習，我繼續寫邦一的題目，AC 了一題 Domination Tree。 下午和晚上就是一個奇怪的教授（他看到雄中手上的初音娃娃超開心，他立馬詢問來源，跟著買了一隻）， Interval tree、BIT、Independent set、flow、min-cut、vertex cover、\u0026hellip;\u0026hellip;、高斯整數取mod（真的不知怎麼用）。簡單來說，感想是「好累喔～」\nDAY 6 下午就是一模了，大家似乎都進入備戰狀態！Yunn 讀完了她的有機化學，是的，今天也是化奧，所以我只好孤單的被電爆\u0026hellip;\u0026hellip;\n中午早早就去吃午飯了，大家瘋狂去搶購巧克力備戰，我沒進入狀況（呆瓜） 「一模」終於來了！！\n我隨隨便便的掃過題目，覺得 pA 看起來不難就先下手了，但我就是數學渣，沒想到Greedy，所以花了一個鐘頭還是宣告放棄，事後聽學長們講解，其實 Greedy 有 50 分。pB 明顯是 Interval 問題，因為寫了不少邦一練習題，所以就有信心能在這題拿到分數（沒猜錯，這題確實他出的），排序後做 LIS，就拿到 26 分了，這時還沒去想兩座塔的情況，但覺得 pD 最近點對問題似乎拿得到分，於是就轉移目標了，pD 暴力或許真的能拿到分，但我是白痴，看著紙本的輸出規定，但事實上他有改掉這部分，於是一整個 WA＋RE，超浪費時間。但四個小時真的很長，我放棄 pD，去寫 pC，但 pC 事後看邪惡表格真的是最難的一題，前序走訪二元搜尋樹，對啦，很多人誤解這題題意，於是\u0026hellip;\u0026hellip;我當然也各種 WA ，時間到了！\n賽後，講題目給 Yunn 聽，pB我才剛講完就想到正解了，早知道就不要跳開它，我的名次和分數應該就能好看一點了。宗哲老師重新開系統給我們練習後，好像沒加幾行 pB 就 AC 了QQ\n晚餐不是餐卷，是牛腩飯和紅茶，配著淒慘的邪惡表格。晚點名拿到遲來的綠乖乖。\nDAY 7 早上和下午同樣是自主練習，經歷昨天的打擊，於是就開始刷水題，寫幾題資芽作業和 ZJ 上的 dfs 和 greedy。\n下午又是 DAY5 那個教授，講了一些 coloring 之類的雜七雜八，他的投影片做到三四百頁，真令人佩服\u0026hellip;\u0026hellip;\nDAY 8 今天早上和下午是上 Data Structure 和 Sorting，就是在講 stack、queue、linked list、heap，大部分是配著劉汝加那本的例題講，對我來說有點無趣，好像不該出現在選訓營\u0026hellip;\u0026hellip;至少應該放第一天吧！下午的 sorting 也沒什麼難度，反正他應該就是把 I2A 裡的東西整理出來講\u0026hellip;\u0026hellip;\n大神們早上為教授簡單介紹了 treap 的各種優點和功能，聽著我也想學了 XD\nDAY 9 早上是教 DFS 和 SCC，我大致聽得懂理論，不過有實作障礙。\n下午又是 Vertex coloring，我覺得有一半的教授都會提到 coloring\u0026hellip;\u0026hellip;\n晚上是邦一的課，原本是排 DP，但他被追加任務，要講解一模，早上其實宗哲老師就把 Judge 重新打開了，剛好幾個前國手揪團來玩(晚上還一起回宿舍)，於是就變他們來講囉！第一題是 Greedy+折半枚舉，第二題 LIS+LDS，第三題我沒聽懂，第四題是 Divide \u0026amp; Conquer，但據說有些假解也能過？\nDAY 10 早上是邦一的 DP 課，這次他出的功課比上次難，我之後試了幾題，真的不太會寫QQ 下午是所謂的「輔導課」，反正就是發蠟筆和白紙畫圖，我認為 Yunn 是我們中最有美術天分的人，其他人都是畫各種 tree 來亂。對了，在畫樹之前，還有分組玩「每個人輪流畫一筆」，我和 Yunn、YP、冠宇一組，最後應該是我們這組合作的最好，沒有搞破壞，畫出一隻打領結、頭上長棒棒糖的貓咪^ ^之後算是聽到了 YP 勵志的 Coding 之路，還有和 YP 和冠宇稍微變熟了～我應該是在這天知道「皮卡丘打排球」很好玩，真符合電神的風格啊！\n晚上沒課，回到宿舍後和班上同學用手機聊天，打聽一下各種學校近況，果然脫離現實太久，不知不覺就聊一個小時！！\nDAY 11 神奇的課表，早上是輔導課，聽一個馬來西亞人講故事\u0026hellip;\u0026hellip;下午和晚上都是自主練習，因為邦一的 DP 題都寫不出來，所以就耍廢去 ZJ 上刷基本的 DP，然後重新振作，學線段樹，半夜就試著寫 2D 的 RMQ，刻了一個線段樹套線段樹，但 bug 一堆就先去睡了。\nDAY 12 早晨把 2D RMQ 的 bug 解決～\n表定一整天都是離散數學，但實際上只有早上在上離散，下午教授就開始講我有點聽不懂的東西，FSA、TM、Regular Expression、CFG、PDA\u0026hellip;\u0026hellip;但畢竟隔天是模考，所以傍晚他就直接開練習題，一些 BFS 之類的。\n晚上約了在師大的學姐一起吃晚餐，當作模考前消除壓力？之後我的 BFS 整個爆爛，我超崩潰 QQ\n回到宿舍後，繼我晚點名走錯房間之糗事後，我開啟了走廊的小圈圈聊天，真的很開心到了最後一晚居然這麼多人願意一起耍廢聊天，感謝 YP 滿足我的好奇心，還聽到了不少電神故事，但聊到有點睏了，我還是溜回房間睡覺了XD\nDAY 13 早上寫了 TIOJ 1011 感謝後面的大神指導，快中午時練了一下 LIS。\n中午前各種薄片賭博及巧克力備戰，然後就是二模了！\n只能帶乖乖入場，所以看到某人拿著建達巧克力跟教授坳很久\u0026hellip;\u0026hellip;\npA，有點像中國郵差問題，我只拿了11分～\npB，應該難度頗高，1～n 的長度，組出 p 個長度 q，我只過了 p=2，撿 18 分\npC，最短路徑，以為是 dfs，但其實應該寫 bfs，所以只拿了 48 分QQ\npD，據說是 1D1D 的 DP，我當然不會寫，亂 Greedy，拿 9 分～\n結論是應該多花點時間在 pC，也許 100 分是拿得到的～很意外的沒墊底\u0026gt;\u0026lt; 晚上，是 pizza 時間！ 先等宗謀教授來頒證書，和冠宇聊了一下～ pizza 和炸雞冷掉不好吃，還有布丁和泡芙之類的東西。 之後，其實就是幾家歡樂幾家愁，大概懂「邪惡表格」這個名稱的意含了，和 Yunn 似乎要很久才能再見了，幸好她有想起來要拍照，真是感傷的夜晚～\n離開時其實很希望能再來一次，真的很捨不得離開，但原因我也說不出來，大概是希望自己變強一點再來，能融入大家的世界吧？\n行李比來的時候多超多，例如：I2A 和晚點名發的餅乾，幸好有人載\u0026hellip;\u0026hellip; 晚上回到家就開始忙只剩兩天的個人申請，於是拖文超久\u0026hellip;\u0026hellip;\n小記 「皮卡丘打排球」挺好玩的 好可惜我沒吃過薄片 「電神」「裝弱」是詞頻最高的名詞 各科電神隨地檢，化奧、數奧、物奧充斥 聽到有人全國賽對食物放電的故事 聽到某人怕蝴蝶的故事 據說燒壞房間電鈴是傳統 據說今年很正經，沒拿投影幕播動漫 大家晚點名超愛排隊（和在學校晚自習排點心如出一轍） 玩拉密我好像只贏過第一場，大家進入狀況後我只有被電的份 電神無時無刻都在聊題目，包含吃飯、睡覺 鍵盤聲太吵會引起民怨 大家早上一天比一天晚起 早餐漢堡和三明治交替，有點膩 午餐和晚餐，覺得自助餐不好吃，於是拉麵和豬排飯交替 輔導員總是催我們下去吃飯，但似乎成效不佳 每天念著想吃冰，但懶得走到7-11 師大會館房間挺不錯，但洗衣機和烘衣機只有6台，於是洗加烘需要摸到半夜一點 假日記得在宿舍裝好水，不然分部飲水機都是關的 大家都愛熬夜到兩三點，打CF和水題大賽，但我沒打過\u0026hellip;\u0026hellip; 我和Yunn很好奇對面的生物實驗室 教室前門很難開 感想 覺得做這個選擇真的很值得，感謝各種運氣和緣分，讓自己能進選訓營一階。其實知道自己入選時真的有點緊張和害怕，畢竟沒有想過進選訓營真的會發生在我身上，再加上申請入學的結果還沒出來，不確定需不需要考指考，請兩個禮拜的假會不會跟不上進度，被當掉之類的\u0026hellip;\u0026hellip;但寒假就下定決心「不考指考，進選訓營」，所以備審做了 70%，加上填了清大資工應該穩上，因此比較不擔心沒大學念。學校的話，撞一週段考，所以等於只少上了一週新進度，然後感謝數學老師告知我可以申請免考，不然我原本在考慮補考（不過拿畢業考的成績補一段成績真的很lucky，因為畢業考有點放水成績相對高，我拿到了有史以來最高的班排和類排）反正，就拋下現實，去體驗「國手生活」?????\n這兩週其實也有點小邊緣，但覺得沒差，反正至少認識了 Yunn。邊緣的原因，可能是因為實力落差太大，所以跟不上他們的談話。也可能是他們以前就很熟了，畢竟發現幾個高一的也有點邊，不然就是因為我都不熬夜打CF，所以沒話題。\n說有沒有變強，我想多多少少有吧！但收穫最多的，應該是能生活在一個大家都熱愛寫程式的世界，而且每天都可以沉浸在程式的世界，然後也深受 YP 的精神感動。除此之外，也聽到了奇怪的技巧和各式各樣的資料結構。\n一開始有點恐懼充滿鍵盤聲的生活，但其實兩天就習慣了，也能理解這群男生的用詞了，不然第一天真的好像遇到一群火星人。\n對我來說，真的很享受能進入一個隨時都有人可以討論程式的世界 ^_^\n","date":"2018-06-22T11:17:06+08:00","permalink":"https://luke2336.github.io/p/toi-2018/","title":"TOI 2018 選訓營一階 心得"},{"content":"新山夢湖 沿著汐萬路往五指山方向開去，會看到一條岔路通往新山夢湖。新山夢湖雖為私人所有，但也算是當地小有名氣的觀光勝地，有一些小攤販會在停車場旁販售茶葉蛋和飲料等等，也有一些新人會在湖邊拍婚紗照。\n湖邊有一些登山步道，環湖一周大約一小時，可以通往電塔旁邊看夕陽，因此午後去是個不錯的選擇。晚上可以沿著汐萬路開往五指山，會有不少重機騎士停在路邊看夜景。\n照片 ","date":"2018-02-18T16:58:39+08:00","image":"https://luke2336.github.io/p/xinshan-dream-lake/scene12_hub7fd9a1cd3dfa8e169dfd3d94f2cf731_317181_120x120_fill_q75_box_smart1.JPG","permalink":"https://luke2336.github.io/p/xinshan-dream-lake/","title":"汐止 - 新山夢湖"}]