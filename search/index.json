[{"content":"因為 pA 卡住，所以慘慘的 QAQ\n掉了 31 分到 1685。\nAtCoder Regular Contest 111 A. Simple Math 2 題意 $$1 \\leq n \\leq 10^{18}, 1 \\leq m \\leq 10^4, \\text{find }\\lfloor \\frac{10^n}{m}\\rfloor \\mod m.$$\n解法  求 (10 ** n) % (m * m) // m。 紀錄餘數的循環節。 卡題原因：  忘記循環不一定從一開始。 用了 unordered_map 判斷餘數是否出現過導致 TLE，換成 array 就變很快了。    Code 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4#define pb push_back 5int s[100000008]; 6int main() { 7 ll n, m, mm; 8 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 9 mm = m * m; 10 ll r, d = 1; 11 vector\u0026lt;int\u0026gt; v; // 紀錄餘數 12 for (int i = 0; i \u0026lt;= n; i++) { 13 r = d % mm; 14 if (s[r] || (i \u0026amp;\u0026amp; r == v[0])) break; 15 s[r] = i; 16 v.pb(r); 17 d = r * 10; 18 } 19 if (n \u0026lt; v.size()) { 20 cout \u0026lt;\u0026lt; v[n] / m \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 21 return 0; 22 } 23 int t = s[r]; // 循環節起點 24 int id = t + (n - t) % (v.size() - t); 25 cout \u0026lt;\u0026lt; v[id] / m \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 26 return 0; 27}  B. Reversible Cards 題意 給定 N 張卡（≤2e5），每張卡上正反面各有一個數字（1~4e5），讓你每張牌只能選擇一面，問最多有幾個相異數字？\n解法 建立一個 Source，給每張牌 cap = 1 的邊，然後每張牌建立到正反兩面的數字 cap = 1 到邊，每個數字建立到 Sink cap = 1 的邊，之後求最大流 max-flow 即為答案\n因為是二分圖，所以用 Dinic 複雜度約為 O(sqrt(V)E) ~ 2e8。\nCode 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define pb push_back 6#define inf 1e9 7#define maxn 200000 8#define maxk 400000 9class Dinic { 10 private: 11 struct edge { int d, r; ll c; }; 12 vector\u0026lt;vector\u0026lt;edge\u0026gt;\u0026gt; adj; vector\u0026lt;int\u0026gt; lv, ve; int n; 13 bool mklv(int s, int d) { 14 lv.assign(n, -1); lv[s] = 0; queue\u0026lt;int\u0026gt; q({s}); 15 while (!q.empty()) { 16 int v = q.front(); q.pop(); 17 for (auto\u0026amp; e : adj[v]) { 18 if (e.c == 0 || lv[e.d] != -1) continue; 19 lv[e.d] = lv[v] + 1, q.push(e.d); 20 } 21 } 22 return lv[d] \u0026gt; 0; 23 } 24 ll aug(int v, ll f, int d) { 25 if (v == d) return f; 26 for (; ve[v] \u0026lt; adj[v].size(); ve[v]++) { 27 auto\u0026amp; e = adj[v][ve[v]]; 28 if (lv[e.d] != lv[v] + 1 || !e.c) continue; 29 ll sent = aug(e.d, min(f, e.c), d); 30 if (sent \u0026gt; 0) { 31 e.c -= sent, adj[e.d][e.r].c += sent; 32 return sent; 33 } 34 } 35 return 0; 36 } 37 public: 38 Dinic(int n) : n(n + 1) { clear(); } 39 void clear() { adj.assign(n, {}); } 40 void add_edge(int src, int dst, ll cap) { 41 edge ss{dst, (int)adj[dst].size(), cap}; 42 edge dd{src, (int)adj[src].size(), 0}; 43 adj[src].push_back(ss), adj[dst].push_back(dd); 44 } 45 ll max_flow(int s, int d) { 46 ll ret = 0; 47 while (mklv(s, d)) { 48 ve.assign(n, 0); 49 while (ll f = aug(s, inf, d)) ret += f; 50 } 51 return ret; 52 } 53}; 54int main() { 55 ios::sync_with_stdio(0), cin.tie(0); 56 int n; cin \u0026gt;\u0026gt; n; 57 Dinic D(maxn + maxk + 2); 58 int dst = maxn + maxk + 1; 59 for (int i = 1; i \u0026lt;= n; i++) { 60 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 61 D.add_edge(0, i, 1); 62 D.add_edge(i, maxn + a, 1); 63 D.add_edge(i, maxn + b, 1); 64 } 65 for (int i = 1; i \u0026lt;= maxk; i++) 66 D.add_edge(maxn + i, dst, 1); 67 cout \u0026lt;\u0026lt; D.max_flow(0, dst) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 68 return 0; 69}  ","date":"2021-01-09T22:03:11+08:00","permalink":"https://Luke2336.github.io/p/atcoder_arc111/","title":"AtCoder Regular Contest 111"},{"content":"昨天 11 點前就睡了，但還是睡到 10 點半左右，因為真的很冷。隊友們都去幫忙監考某考試了。\n早餐吃了麵包，然後今天看了好幾集卡通「烘焙王」。\n重新算了電路學 CH11 的作業，為期末考做準備。\n下午吃了麥當勞，今天的薯條超鹹，然後又被找下去吃了蛋捲冰淇淋。\n晚上打了 AtCoder 的 ARC 111，但還是覺得今天太廢了，肯定是上週作業壓力太大，連續趕了三份 OS 作業，所以今天就放鬆到開始耍廢。\nAtCoder Regular Contest 111 打得慘慘的，掉了 31 分！\n","date":"2021-01-09T22:02:20+08:00","permalink":"https://Luke2336.github.io/p/20210109/","title":"2021/01/09 日記"},{"content":"早上難得的吃了早餐，去提款機提錢，順便在旁邊買三明治吃，泡了柚子茶喝。\n用 Virtualbox 的設定，多掛載了 1GB 的記憶體給 Ubuntu VM，於是多出了一個 /dev/sdb 可以切。然後早上就順利把 HW3 做完了。\n中午吃了麥當勞，點了玉米湯，在宿舍泡伯爵茶一直冷掉。\n房間的濕度約為 65%，溫度則為 15 度左右。但外面似乎已經到 8 度了，超級冷的。穿了羽絨衣跟襪子，但還是手腳冰冷。\n開始複習電路學期末，下午讀了第 15 和 16 章，有關 Laplace 的部分，也自己導了 Initial/Final-Value Theorem。\n看到 Slack 有人說 CSES 增加題目了，於是想起自己還剩一堆沒刷，就開了一題恢復手感。\n借了 HW2 的 Code 給雙曲線參考，順便讓他幫我跑一下，不然我一直無法解決找不到 /dev/os 的問題，沒想到晚上他告訴我，在他那邊跑是對的，真是太好了！\n晚上吃了麻油雞麵，暖暖身體。飯後看了電影「爺爺與貓」。\nCSES - 2189 - Point Location Test 基礎的幾何題。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;ll, ll\u0026gt; point; 5#define x first 6#define y second 7ll check(point p[]) { 8 ll dx = p[1].x - p[0].x, dy = p[1].y - p[0].y; 9 return (p[2].y - p[1].y) * dx + (p[1].x - p[2].x) * dy; 10} 11int main () { 12 ios::sync_with_stdio(0), cin.tie(0); 13 int t; cin \u0026gt;\u0026gt; t; 14 while (t--) { 15 point p[3]; 16 for (int i = 0; i \u0026lt; 3; i++) 17 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 18 ll c = check(p); 19 if (c \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#34;LEFT\\n\u0026#34;; 20 else if (c \u0026lt; 0) cout \u0026lt;\u0026lt; \u0026#34;RIGHT\\n\u0026#34;; 21 else cout \u0026lt;\u0026lt; \u0026#34;TOUCH\\n\u0026#34;; 22 } 23 return 0; 24}  爺爺與貓（ねことじいちゃん） 因為九月時媽媽傳了連結給我，於是今晚有空就決定來看這部了。\n導演是岩合光昭，他在 NHK 有電視節目岩合光昭的貓步走世界（岩合光昭の世界ネコ歩き），好想看！！\n故事是描述在小島上面的老爺爺老奶奶們和貓咪的故事，主角是小玉和阿吉爺爺。查了一下是由漫畫改編。\n","date":"2021-01-08T14:39:43+08:00","permalink":"https://Luke2336.github.io/p/20210108/","title":"2021/01/08 日記"},{"content":"中午還是懶得去跟電資一起在校門口拍照，我想系羽消失後，我對電資的歸屬感就也一起消散了。\n下午擔任了「傳說中的助教」，幫忙老師 demo 三個 Lab。\n上了電路學，覺得很冷很想睡，最後上了一點要用到線代解微方的東西，覺得要好好研究一下，不然考試會卡住。\n寄信給 OS TA，結果還是解決不了沒有 /dev/os 的問題，他建議把 ubuntu 重裝。\n晚上吃了 pizza，點了瑪格麗特，還有一個奇怪的大蒜口味，吃起來非常的蒜 QAQ\n然後開始寫 OS HW3，因為我 /dev/sda 的空間沒辦法再切割記憶體，所以用了很久還是解決不了。\n","date":"2021-01-07T11:01:51+08:00","permalink":"https://Luke2336.github.io/p/20210107/","title":"2021/01/07 日記"},{"content":"昨天下腹不舒服，花了一段時間才入睡。早上躺到十點才起床，中間醒來了兩次。\n醒來後就開始寫作業，有了進度後就去買了雞腿便當吃，然後把韓劇「我的女友是九尾狐」看完，雖然國小時已經看過一遍，但最近突然想重溫一下。\n之後把 HW2 的 PartI-1 寫完，主要是把函式的參數做修正，使兩隻程式的 shmget 回傳的 id 是一樣的。午睡起床後寫了 PartII。\n晚餐吃了壽司，肚子略略不舒服，吃了阿德比之後就好了。\nOS HW2  學會用 shmget() 和 shmat() 使兩個 processes 共享記憶體。  shmget() 的參數要注意，兩個程式的 key 值要是一樣的正整數。而 shmflg 的值則是建立記憶體的那隻程式設為 IPC_CREAT|0666，另一隻設 0。   PartII 是要把兩個 pointer 的 page table 指向同一個 physical address。重點是用 cr3 和 virtual_address 取得 page_table_address。  ","date":"2021-01-06T10:28:28+08:00","permalink":"https://Luke2336.github.io/p/20210106/","title":"2021/01/06 日記"},{"content":"早上很想睡，但還是去上了電路學。今天是教如何在 s-domain 下用 Laplace Transform 解電路，比較需要注意的就是 Initial Condition 的部分。\n下午為了寫 OS 作業，所以裝了 TA 提供的 Ubuntu VM。這是我第一次裝 Linux，平常只有比賽的時候會使用 Linux。\n晚餐前注意到含羞草開花了。\n晚上去上了電路學的助教課，結果只有我一個人去，有個女生十幾分鐘就說身體不舒服離開了。結束時和助教隨口聊了一下天，才知道他大學是讀清大。\n在 VirtualBox 裝 Ubuntu  在官網下載 VirtualBox-6.1.16-140961-OSX.dmg。  點擊 VirtualBox.pkg 安裝。 下載 TA 提供的 Ubuntu-18.04 VM 使用 VB 匯入 Ubuntu-VM.ovf。  啟動 VM，將需要用到的 Terminal 和 gedit 拉到左邊。   含羞草開花 不知道是不是因為最近太冷了，加上給的水少，所以就長出花苞了。有一個好像已經謝了，看了一下網路上的文章，他開花到凋謝的時間大概五六小時，希望有機會能看到花。\n","date":"2021-01-05T13:35:28+08:00","permalink":"https://Luke2336.github.io/p/20210105/","title":"2021/01/05 日記"},{"content":"AtCoder Educational DP Contest  [於 Feb, 2020 完成]\n這套從簡到難的 DP 題組，有不少經典題，很適合照順序刷。 開始刷了之後，才發現自己實力的不足，有幾題想了很久還是想不出來，只好去翻別人的解答。刷完發現 code 都不長，狀態也不難列，但轉移式都要想很久。\n A. Frog 1 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); 5 int dp[2] = {}, a[2] = {}; 6 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[1], \u0026amp;a[0]); 7 dp[0] = abs(a[1] - a[0]); 8 for (int i = 3; i \u0026lt;= N; i++) { 9 int x; scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); 10 dp[i % 2] = min(dp[i % 2] + abs(x - a[i % 2]), 11 dp[(i + 1) % 2] + abs(x - a[(i + 1) % 2])); 12 a[i % 2] = x; 13 } 14 printf(\u0026#34;%d\\n\u0026#34;, dp[N % 2]); 15 return 0; 16}  B. Frog 2 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 100005 4int main() { 5 int n, k; 6 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); 7 int a[maxn], dp[maxn]; 8 for (int i = 1; i \u0026lt;= n; i++) 9 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 10 for (int i = 1; i \u0026lt;= n; i++) { 11 if (i \u0026lt;= k) dp[i] = abs(a[i] - a[1]); 12 else { 13 dp[i] = dp[i - 1] + abs(a[i] - a[i - 1]); 14 for (int j = 2; j \u0026lt;= k; j++) 15 dp[i] = min(dp[i], 16 dp[i - j] + abs(a[i] - a[i - j])); 17 } 18 } 19 printf(\u0026#34;%d\\n\u0026#34;, dp[n]); 20 return 0; 21}  C. Vacation 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 5 int dp[2][3] = {}; 6 for (int i = 1; i \u0026lt;= n; i++) 7 for (int j = 0; j \u0026lt; 3; j++) { 8 int x; scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); 9 dp[i % 2][j] = x + max(dp[(i + 1) % 2][(j + 1) % 3], 10 dp[(i + 1) % 2][(j + 2) % 3]); 11 } 12 printf(\u0026#34;%d\\n\u0026#34;, max(dp[n % 2][0], 13 max(dp[n % 2][1], dp[n % 2][2]))); 14 return 0; 15}  D. Knapsack 1 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxW 100005 4int main() { 5 int n, W; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;W); 6 long long dp[maxW] = {}; 7 for(int i = 0; i \u0026lt; n; i++) { 8 int w, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); 9 for(int j = W; j \u0026gt;= w; j--) 10 dp[j] = max(dp[j], dp[j - w] + v); 11 } 12 printf(\u0026#34;%lld\\n\u0026#34;, dp[W]); 13 return 0; 14}  E. Knapsack 2 dp[j] 為價值為 j 需要的物品最低重量。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 int n, W; 5 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;W); 6 int dp[100005] = {}; 7 for (int i = 1; i \u0026lt; 100005; i++) 8 dp[i] = 1000000005; 9 for (int i = 0; i \u0026lt; n; i++) { 10 int v, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); 11 for(int j = 100000; j \u0026gt;= v; j--) 12 dp[j] = min(dp[j], dp[j-v] + w); 13 } 14 for (int i = 100000; i \u0026gt;= 0; i--) 15 if (dp[i] \u0026lt;= W) { 16 printf(\u0026#34;%d\\n\u0026#34;, i); 17 break; 18 } 19 return 0; 20}  F. LCS 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int dp[3005][3005]; 4int p[3005][3005]; 5int main() { 6 ios_base::sync_with_stdio(0), cin.tie(0); 7 string s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; 8 int lens = s.length(), lent = t.length(); 9 for (int i = 1; i \u0026lt;= lens; i++) { 10 for (int j = 1; j \u0026lt;= lent; j++) { 11 if (s[i - 1] == t[j - 1]) { 12 dp[i][j] = dp[i - 1][j - 1] + 1; 13 p[i][j] = 1; 14 } else if (dp[i][j - 1] \u0026gt; dp[i - 1][j]) { 15 dp[i][j] = dp[i][j - 1]; 16 p[i][j] = 2; 17 } else { 18 dp[i][j] = dp[i - 1][j]; 19 p[i][j] = 3; 20 } 21 } 22 } 23 string ans = \u0026#34;\u0026#34;; 24 int ni = lens, nj = lent; 25 while (ni \u0026amp;\u0026amp; nj) { 26 if (p[ni][nj] == 1) { 27 ans = s[ni - 1] + ans; 28 ni--, nj--; 29 } else if (p[ni][nj] == 2) nj--; 30 else ni--; 31 } 32 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 33 return 0; 34}  G. Longest Path 類似拓樸排序的方式在 DAG（有向無環圖）上做 dp。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 100005 4int main() { 5 int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); 6 int in[maxn] = {}, dp[maxn] = {}; 7 vector\u0026lt;int\u0026gt; e[maxn]; 8 for (int i = 0; i \u0026lt; m; i++) { 9 int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); 10 e[a].push_back(b); 11 in[b]++; 12 } 13 queue\u0026lt;int\u0026gt; q; 14 for (int i = 1; i \u0026lt;= n; i++) 15 if (!in[i]) q.push(i); 16 while (!q.empty()) { 17 int u = q.front(); q.pop(); 18 for (int uu: e[u]) { 19 in[uu]--; 20 dp[uu] = max(dp[uu], dp[u] + 1); 21 if (!in[uu]) q.push(uu); 22 } 23 } 24 int ans = 0; 25 for (int i = 1; i \u0026lt;= n; i++) 26 ans = max(ans, dp[i]); 27 printf(\u0026#34;%d\\n\u0026#34;, ans); 28 return 0; 29}  H. Grid 1 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define mod 1000000007 4int main() { 5 int h, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;h, \u0026amp;w); 6 int dp[1005] = {}; 7 char c[1005]; 8 for (int i = 1; i \u0026lt;= h; i++) { 9 scanf(\u0026#34;%s\u0026#34;, c + 1); 10 for (int j = 1; j \u0026lt;= w; j++) 11 if (c[j] == \u0026#39;#\u0026#39;) dp[j] = 0; 12 else if (i == 1 \u0026amp;\u0026amp; j == 1) dp[j] = 1; 13 else dp[j] = (dp[j] + dp[j - 1]) % mod; 14 } 15 printf(\u0026#34;%d\\n\u0026#34;, dp[w]); 16 return 0; 17}  I. Coins 機率的 dp，所以難得用到 double。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 3000 4int main() { 5 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 6 double dp[maxn] = {1.0}; 7 for (int i = 1; i \u0026lt;= n; i++) { 8 double p; scanf(\u0026#34;%lf\u0026#34;, \u0026amp;p); 9 for (int j = min(i, n / 2); j \u0026gt; 0; j--) 10 dp[j] = dp[j] * (1 - p) + dp[j - 1] * p; 11 dp[0] = dp[0] * (1 - p); 12 } 13 double ans = 1; 14 for(int i = 0; i \u0026lt;= n / 2; i++) 15 ans -= dp[i]; 16 printf(\u0026#34;%.9f\\n\u0026#34;, ans); 17 return 0; 18}  J. Sushi i 為剩 3 個，j 為剩 2 個，k 為剩 1 個的盤子數量。\n$$DP_{i,j,k} = 1 + \\frac{(n-i-j-k) DP_{i,j,k} + i DP_{i-1,j+1,k} + j DP_{i,j-1,k+1} + k DP_{i,j,k-1}}{n}$$\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 305 4double dp[maxn][maxn][maxn]; 5inline double dfs(int i, int j, int k, int n) { 6 if(i \u0026lt; 0 || j \u0026lt; 0 || k \u0026lt; 0) return 0; 7 if (dp[i][j][k] \u0026gt; -1) return dp[i][j][k]; 8 return dp[i][j][k] = (i * dfs(i - 1, j + 1, k, n) + 9 j * dfs(i, j - 1, k + 1, n) + 10 k * dfs(i, j, k - 1, n) + 11 n) / (i + j + k); 12} 13int main() { 14 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 15 int cnt[4] = {}; 16 for (int i = 0; i \u0026lt; n; i++) { 17 int x; cin \u0026gt;\u0026gt; x; 18 cnt[x]++; 19 } 20 for (int i = 0; i \u0026lt;= n; i++) 21 for (int j = 0; j \u0026lt;= n; j++) 22 for (int k = 0; k \u0026lt;= n; k++) 23 dp[i][j][k] = -10; 24 dp[0][0][0] = 0; 25 printf(\u0026#34;%.9f\\n\u0026#34;, dfs(cnt[3], cnt[2], cnt[1], n)); 26 return 0; 27}  K. Stones 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 105 4#define maxk 100005 5int main() { 6 int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); 7 int a[maxn]; 8 bool dp[maxk] = {0}; 9 for (int i = 0; i \u0026lt; n; i++) 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 11 for (int i = 0; i \u0026lt;= k; i++) 12 if(!dp[i]) 13 for (int j = 0; j \u0026lt; n; j++) 14 if(i + a[j] \u0026lt;= k) 15 dp[i + a[j]] = true; 16 if (dp[k]) printf(\u0026#34;First\\n\u0026#34;); 17 else printf(\u0026#34;Second\\n\u0026#34;); 18 return 0; 19}  L. Deque 第一次遇到這題是在 2019NCPC，當時思考了很久能不能 Greedy，後來才想到是 0-sum game。於是用了 minimax 的概念，設計出狀態。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long LL; 4int main() { 5 ios_base::sync_with_stdio(0), cin.tie(0); 6 int n; cin \u0026gt;\u0026gt; n; 7 vector\u0026lt;LL\u0026gt; v(n+2); 8 for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; v[i]; 9 vector\u0026lt;vector\u0026lt;LL\u0026gt; \u0026gt; dp(n + 2, vector\u0026lt;LL\u0026gt;(n + 2,0)); 10 for (int len = 1; len \u0026lt;= n; len++) 11 for (int i = 1, j = len; j \u0026lt;= n; i++, j++) 12 if(len % 2 == n % 2) 13 dp[i][j] = max(dp[i + 1][j] + v[i], 14 dp[i][j - 1] + v[j]); 15 else 16 dp[i][j] = min(dp[i + 1][j] - v[i], 17 dp[i][j - 1] - v[j]); 18 cout \u0026lt;\u0026lt; dp[1][n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 19 return 0; 20}  M. Candies dp[i][j] 發到第 i 人剩下 j 顆糖的方法數，用滾動優化空間複雜度。\ndp[i][j] = dp[i-1][j] + \u0026hellip; + dp[i-1][j+a[i]]。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxk 100005 4#define maxn 105 5#define mod 1000000007 6int main() { 7 int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); 8 int a[maxn], dp[2][maxk]; 9 for (int i = 1; i \u0026lt;= n; i++) 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 11 dp[0][k] = 1; 12 for(int i = 1; i \u0026lt;= n; i++) { 13 int sum = 0; 14 for(int j = k; j \u0026gt;= 0; j--) { 15 sum = (sum + dp[(i + 1) \u0026amp; 1][j]) % mod; 16 if(j + a[i] + 1 \u0026lt;= k) 17 sum = (sum + mod 18 - dp[(i + 1) \u0026amp; 1][j + a[i] + 1]) % mod; 19 dp[i \u0026amp; 1][j] = sum; 20 } 21 } 22 printf(\u0026#34;%d\\n\u0026#34;, dp[n \u0026amp; 1][0]); 23 return 0; 24}  N. Slimes dp[i][j] 為合併史萊姆 i ~ j 所需的最小 cost。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 405 4#define INF 100000000000000 5typedef long long LL; 6int main() { 7 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 8 int a[maxn]; 9 for (int i = 1; i \u0026lt;= n; i++) 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 11 LL sum[maxn] = {}; 12 LL dp[maxn][maxn] = {}; 13 for (int i = 1; i \u0026lt;= n; i++) 14 sum[i] = sum[i - 1] + a[i]; 15 for (int len = 2; len \u0026lt;= n ; len++) 16 for(int i = 1, j = i + len - 1; j \u0026lt;= n; i++, j++) { 17 dp[i][j] = INF; 18 for (int k = i; k \u0026lt; j; k++) 19 dp[i][j] = min(dp[i][j], 20 dp[i][k] + dp[k + 1][j] + sum[j] - sum[i - 1]); 21 } 22 printf(\u0026#34;%lld\\n\u0026#34;, dp[1][n]); 23 return 0; 24}  O. Matching 位元 dp。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 23 4#define maxm (1\u0026lt;\u0026lt;21)+5 5#define mod 1000000007 6int dp[maxm] = {1}; 7int main() { 8 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 9 int a[maxn][maxn]; 10 for (int i = 0; i \u0026lt; n; i++) 11 for (int j = 0; j \u0026lt; n; j++) 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); 13 int M = (1 \u0026lt;\u0026lt; n) - 1; 14 for (int j = 0; j \u0026lt;= M; j++) { 15 int i = __builtin_popcount(j) - 1; 16 for (int k = 0; k \u0026lt; n; k++) 17 if (j \u0026amp; (1 \u0026lt;\u0026lt; k) \u0026amp;\u0026amp; a[i][k]) 18 dp[j] = (dp[j] + dp[j - (1 \u0026lt;\u0026lt; k)]) % mod; 19 } 20 printf(\u0026#34;%d\\n\u0026#34;, dp[M]); 21 return 0; 22}  P. Independent Set 經典樹 dp。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 100005 4#define mod 1000000007 5vector\u0026lt;int\u0026gt; e[maxn]; 6long long dp[maxn][2] = {}; 7void dfs(int v, int p) { 8 dp[v][0] = dp[v][1] = 1; 9 for (int u : e[v]) { 10 if (u == p) continue; 11 dfs(u, v); 12 dp[v][0] = dp[v][0] * (dp[u][0] + dp[u][1]) % mod; 13 dp[v][1] = dp[v][1] * dp[u][0] % mod; 14 } 15} 16int main() { 17 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 18 for (int i = 1; i \u0026lt; n; i++) { 19 int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); 20 e[a].push_back(b), e[b].push_back(a); 21 } 22 dfs(1, 0); 23 printf(\u0026#34;%lld\\n\u0026#34;, (dp[1][1] + dp[1][0]) % mod); 24 return 0; 25}  Q. Flowers 帶權最長遞增子序列（Weighted Longest Increasing Subsequence）。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 200005 4typedef long long LL; 5int main() { 6 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 int h[maxn], a[maxn]; 8 for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;h[i]); 9 for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 10 map\u0026lt;int, LL\u0026gt; m; m[0] = 0; 11 for(int i = 0; i\u0026lt;n; i++) { 12 map\u0026lt;int,LL\u0026gt;::iterator iter, iter_tmp; 13 iter = m.lower_bound(h[i]); 14 iter--; 15 LL val = iter-\u0026gt;second + a[i]; 16 iter++; 17 while(iter != m.end() \u0026amp;\u0026amp; iter-\u0026gt;second \u0026lt;= val) { 18 iter_tmp = iter; 19 iter_tmp++; 20 m.erase(iter); 21 iter = iter_tmp; 22 } 23 m[h[i]] = val; 24 } 25 printf(\u0026#34;%lld\\n\u0026#34;, m.rbegin()-\u0026gt;second); 26 return 0; 27}  R. Walk 矩陣快速冪。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 55 4#define mod 1000000007 5typedef long long LL; 6struct matrix { 7 int sz; 8 int m[maxn][maxn]; 9 matrix(){} 10 matrix(int n) : sz(n) { memset(m, 0, sizeof(m)); } 11 void operator = (const matrix \u0026amp;A) { 12 for (int i = 0; i \u0026lt; sz; i++) 13 for (int j = 0; j \u0026lt; sz; j++) 14 m[i][j] = A.m[i][j]; 15 } 16 matrix operator*(const matrix \u0026amp;A) { 17 matrix B(sz); 18 for (int i = 0; i \u0026lt; sz; i++) 19 for (int j = 0; j \u0026lt; sz; j++) { 20 B.m[i][j] = 0; 21 for (int k = 0; k \u0026lt; sz; k++) 22 B.m[i][j] = ((LL)m[i][k] * A.m[k][j] % mod 23 + B.m[i][j]) % mod; 24 } 25 return B; 26 } 27}; 28matrix pow(matrix A, LL k) { 29 matrix ans(A.sz); 30 for (int i = 0; i \u0026lt; A.sz; i++) 31 ans.m[i][i] = 1; 32 while (k) { 33 if (k \u0026amp; 1) ans = ans * A; 34 k \u0026gt;\u0026gt;= 1; 35 A = A * A; 36 } 37 return ans; 38} 39int main() { 40 int n; 41 LL k; 42 scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;k); 43 matrix A(n); 44 for (int i = 0; i \u0026lt; n; i++) 45 for (int j = 0; j \u0026lt; n; j++) 46 scanf(\u0026#34;%d\u0026#34;, \u0026amp;A.m[i][j]); 47 matrix ans = pow(A, k); 48 int cnt = 0; 49 for (int i = 0; i \u0026lt; n; i++) 50 for (int j = 0; j \u0026lt; n; j++) 51 cnt = (cnt + ans.m[i][j]) % mod; 52 printf(\u0026#34;%d\\n\u0026#34;, cnt); 53 return 0; 54}  S. Digit Sum dp[i][j][k]：到第 i 個字母，同餘 j 的方法數，k 代表前 i 位是否和 input 的前 i 位一致。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define mod 1000000007 4int dp[2][102][2] = {}; 5inline void add(int \u0026amp;a, int b) { 6 a = (a + b % mod) % mod; 7} 8int main() { 9 ios_base::sync_with_stdio(0); 10 cin.tie(0); 11 string s; int d; 12 cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; d; 13 int len = s.length(); 14 dp[1][0][1] = 1; 15 for (int i = 0; i \u0026lt; len; i++) { 16 memset(dp[i \u0026amp; 1], 0, sizeof(dp[i \u0026amp; 1])); 17 for (int j = 0; j \u0026lt; d; j++) 18 for (int k = 0; k \u0026lt;= 9; k++) 19 if(k \u0026lt; s[i]-\u0026#39;0\u0026#39;) 20 add(dp[i \u0026amp; 1][(j + k) % d][0], 21 dp[!(i \u0026amp; 1)][j][0]), 22 add(dp[i \u0026amp; 1][(j + k) % d][0], 23 dp[!(i \u0026amp; 1)][j][1]); 24 else if (k == s[i] - \u0026#39;0\u0026#39;) 25 add(dp[i \u0026amp; 1][(j + k) % d][0], 26 dp[!(i \u0026amp; 1)][j][0]), 27 add(dp[i \u0026amp; 1][(j + k) % d][1], 28 dp[!(i \u0026amp; 1)][j][1]); 29 else 30 add(dp[i \u0026amp; 1][(j + k) % d][0], 31 dp[!(i \u0026amp; 1)][j][0]); 32 } 33 cout \u0026lt;\u0026lt; (dp[!(len \u0026amp; 1)][0][0] + 34 dp[!(len \u0026amp; 1)][0][1] - 1 + mod) % mod \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 35 return 0; 36}  T. Permutation dp[i][j] 定義為前 i + 1 個數字結尾為 j 的組合數為多少（1 ≤ j ≤ i + 1）。 前綴和加速到 O(n²)。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3const int mod = 1000000007; 4int main() { 5 ios_base::sync_with_stdio(0),cin.tie(0); 6 int n; 7 string s; 8 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; 9 vector\u0026lt;int\u0026gt; dp(n + 1, 0), sum(n + 1, 1); 10 dp[1] = 1, sum[0] = 0; 11 for (int i = 1; i \u0026lt; n; i++) { 12 for (int j = 1; j \u0026lt;= i + 1; j++) { 13 if (s[i - 1] == \u0026#39;\u0026gt;\u0026#39;) 14 dp[j] = (sum[i] - sum[j - 1] + mod) % mod; 15 else 16 dp[j] = sum[j - 1]; 17 } 18 for (int j = 1; j \u0026lt;= n; j++) 19 sum[j] = (sum[j - 1] + dp[j]) % mod; 20 } 21 cout \u0026lt;\u0026lt; sum[n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 22 return 0; 23}  U. Grouping 學會枚舉子集的辦法了！！\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4int main() { 5 ios_base::sync_with_stdio(0), cin.tie(0); 6 int n; cin \u0026gt;\u0026gt; n; 7 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a(n, vector\u0026lt;int\u0026gt;(n)); 8 for (int i = 0; i \u0026lt; n; i++) 9 for (int j = 0; j \u0026lt; n; j++) 10 cin \u0026gt;\u0026gt; a[i][j]; 11 int m = (1 \u0026lt;\u0026lt; n); 12 vector\u0026lt;ll\u0026gt; cnt(m), dp(m); 13 for (int s = 0; s \u0026lt; m; s++) 14 for (int i = 0; i \u0026lt; n; i++) 15 if (s \u0026amp; (1 \u0026lt;\u0026lt; i)) 16 for (int j = i; j \u0026lt; n; j++) 17 if (s \u0026amp; (1 \u0026lt;\u0026lt; j)) 18 cnt[s] += a[i][j]; 19 for (int s = 0; s \u0026lt; m; s++) 20 for (int sub = s; sub \u0026gt; 0; sub = (sub - 1) \u0026amp; s) 21 dp[s] = max(dp[s], dp[s - sub] + cnt[sub]); 22 cout \u0026lt;\u0026lt; dp[m - 1] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 23 return 0; 24}  V. Subtree 參考 codeforces 這篇討論 才寫出來。\n解法：（有根樹）。\n up/down[node] 是 node 以上/下的點塗黑的方法數。 down 的不難算，直接 dfs 做樹 dp 就行了。 up 需要用到 down 的結果，算如果取 parent，其他子樹 down 的方法數。 +1 代表不取 parent。 最後各點的結果為 up * down。 算其他子樹的方法和，因為需要取 mod 且模數不為質數，故需要維護其前/後綴積。  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4#define maxn 100005 5#define pb push_back 6int mod; 7vector\u0026lt;int\u0026gt; e[maxn]; 8vector\u0026lt;ll\u0026gt; pre[maxn], suf[maxn]; 9ll up[maxn], down[maxn]; 10void dfs1(int u, int p) { 11 for (int uu : e[u]) 12 if (uu != p) dfs1(uu, u); 13 for (int i = 0; i \u0026lt; e[u].size(); i++) { 14 int uu = e[u][i]; 15 pre[u][i] = i ? pre[u][i-1] : 1; 16 if(uu != p) 17 pre[u][i] = pre[u][i] * (1 + down[uu]) % mod; 18 } 19 for (int i = e[u].size() - 1; i \u0026gt;= 0; i--) { 20 int uu = e[u][i]; 21 suf[u][i] = (i \u0026lt; e[u].size() - 1) ? suf[u][i + 1] : 1; 22 if(uu != p) 23 suf[u][i] = suf[u][i] * (1 + down[uu]) % mod; 24 } 25 down[u] = suf[u][0]; 26} 27void dfs2(int u, int p) { 28 for (int i = 0; i \u0026lt; e[u].size(); i++) { 29 int uu = e[u][i]; 30 if (uu == p) continue; 31 ll cnt = up[u]; 32 if(i) 33 cnt = cnt * pre[u][i - 1] % mod; 34 if(i + 1 \u0026lt; e[u].size()) 35 cnt = cnt * suf[u][i + 1] % mod; 36 up[uu] = cnt + 1; // 1是不取par 37 dfs2(uu, u); 38 } 39} 40int main() { 41 ios_base::sync_with_stdio(0); 42 cin.tie(0); 43 int n; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; mod; 44 for (int i = 1; i \u0026lt; n; i++) { 45 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 46 e[a].pb(b), e[b].pb(a); 47 } 48 e[1].pb(0), up[1] = 1; 49 for (int i = 1; i \u0026lt;= n; i++) { 50 pre[i].resize(e[i].size()); 51 suf[i].resize(e[i].size()); 52 } 53 dfs1(1, 0), dfs2(1, 0); 54 for (int i = 1; i \u0026lt;= n; i++) 55 cout \u0026lt;\u0026lt; down[i] * up[i] % mod \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 56 return 0; 57}  W. Intervals  題意： 給定 M (1 ≤ M ≤ 200000) 組 (l[i], r[i]) (1 ≤ l[i] ≤ r[i] ≤ N ≤ 200000) 和 a[i] (|a[i]| ≤ 1000000000)。 當 l[i] ~ r[i] 至少有一個 1 的 a[i] 分，問構造出長度 N 的 01 字串最高得幾分。 解法：  轉移式：dp[i] = max{ dp[j] + sum{a[k]} }, j \u0026lt; l[k] ≤ i ≤ r[k] 優化：區間加值線段樹維護最大值。    1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, ll\u0026gt; pil; 5#define ls i \u0026lt;\u0026lt; 1 6#define rs i \u0026lt;\u0026lt; 1 | 1 7class RangeUpdateSegmentTree { 8 private: 9 struct node { 10 int l, r; 11 ll x = 0, adt = 0; 12 }; 13 vector\u0026lt;node\u0026gt; a; 14 void push(int i) { 15 if (a[i].adt) { 16 a[ls].adt += a[i].adt, a[rs].adt += a[i].adt; 17 a[ls].x += a[i].adt, a[rs].x += a[i].adt; 18 a[i].adt = 0; 19 } 20 } 21 void pull(int i) { 22 a[i].x = max(a[ls].x, a[rs].x); 23 } 24 void build(int l, int r, int i) { 25 a[i].l = l, a[i].r = r; 26 if (l == r) return; 27 int mid = (l + r) \u0026gt;\u0026gt; 1; 28 build(l, mid, ls), build(mid + 1, r, rs); 29 } 30 public: 31 RangeUpdateSegmentTree(int n) : a(n \u0026lt;\u0026lt; 2) { 32 build(0, n, 1); 33 } 34 void add(int l, int r, ll val, int i = 1) { 35 if (a[i].l \u0026gt;= l \u0026amp;\u0026amp; a[i].r \u0026lt;= r) { 36 a[i].x += val; 37 a[i].adt += val; 38 return; 39 } 40 push(i); 41 int mid = (a[i].l + a[i].r) \u0026gt;\u0026gt; 1; 42 if (l \u0026lt;= mid) add(l, r, val, ls); 43 if (r \u0026gt; mid) add(l, r, val, rs); 44 pull(i); 45 } 46 ll maxx(int l, int r, int i = 1) { 47 if (l \u0026lt;= a[i].l \u0026amp;\u0026amp; a[i].r \u0026lt;= r) return a[i].x; 48 push(i); 49 ll ret = -9e18; 50 int mid = (a[i].l + a[i].r) \u0026gt;\u0026gt; 1; 51 if (l \u0026lt;= mid) ret = max(ret, maxx(l, r, ls)); 52 if (r \u0026gt; mid) ret = max(ret, maxx(l, r, rs)); 53 pull(i); 54 return ret; 55 } 56}; 57int main() { 58 ios_base::sync_with_stdio(0); 59 cin.tie(0); 60 int n, m; 61 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 62 vector\u0026lt;ll\u0026gt; add(n + 1); 63 vector\u0026lt;vector\u0026lt;pil\u0026gt;\u0026gt; del(n + 1); 64 for (int i = 0; i \u0026lt; m; i++) { 65 int l, r; ll a; 66 cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; a; 67 add[l] += a; 68 del[r].push_back(pil(l, a)); 69 } 70 RangeUpdateSegmentTree ST(n + 1); 71 ll ans = 0; 72 for (int i = 1; i \u0026lt;= n; i++) { 73 ST.add(0, i - 1, add[i]); 74 ll tmp = ST.maxx(0, i - 1); 75 ans = max(ans, tmp); 76 ST.add(i, i, tmp); 77 for (pil p : del[i]) 78 ST.add(0, p.first - 1, -p.second); 79 } 80 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 81 return 0; 82}  X. Tower 將 solidness 排序後，再做 dp。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long LL; 4typedef pair\u0026lt;int,int\u0026gt; pii; 5typedef pair\u0026lt;int,pii\u0026gt; box; 6#define s first 7#define w second.first 8#define v second.second 9#define maxn 1005 10#define maxs 20005 11int main() { 12 int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); 13 box b[maxn]; 14 for(int i=0; i\u0026lt;n; i++){ 15 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;b[i].w, \u0026amp;b[i].s, \u0026amp;b[i].v); 16 b[i].s += b[i].w; 17 } 18 sort(b, b + n); 19 LL dp[maxs] = {}; 20 LL ans = 0; 21 for (int i = 0; i \u0026lt; n; i++) { 22 for (int j = b[i].s; j \u0026gt;= b[i].w; j--) { 23 dp[j] = max(dp[j], dp[j - b[i].w] + b[i].v); 24 ans = max(ans, dp[j]); 25 } 26 } 27 printf(\u0026#34;%lld\\n\u0026#34;, ans); 28 return 0; 29}  Y. Grid 2 如果沒有障礙物，答案會是 C(h - 1 + w - 1, h - 1)。 有障礙物，就將障礙物那格的答案扣掉 C(x[i] - x[j] + y[i] - y[j], x[i] - x[j]) 次。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4typedef long long ll; 5#define x first 6#define y second 7#define mod 1000000007 8#define LEN 200005 9ll frc[LEN], inv[LEN]; 10ll modinv(ll a, ll p = mod) { 11 if (p == 1) return 0; 12 ll pp = p, y = 0, x = 1; 13 while (a \u0026gt; 1) { 14 ll q = a / p, t = p; 15 p = a % p, a = t, t = y, y = x - q * y, x = t; 16 } 17 if (x \u0026lt; 0) x += pp; 18 return x; 19} 20void init() { 21 frc[0] = frc[1] = inv[0] = inv[1] = 1; 22 for (int i = 2; i \u0026lt; LEN; i++) { 23 frc[i] = frc[i - 1] * i % mod; 24 inv[i] = modinv(frc[i]); 25 } 26} 27inline ll C(int a, int b) { 28 return frc[a + b] * inv[a] % mod * inv[b] % mod; 29} 30inline void sub(ll \u0026amp;a, ll b) { 31 a = (a - b % mod + mod) % mod; 32} 33int main() { 34 ios_base::sync_with_stdio(0); 35 cin.tie(0); 36 init(); 37 int h, w, n; 38 cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w \u0026gt;\u0026gt; n; 39 vector\u0026lt;pii\u0026gt; p(n); 40 for (int i = 0; i \u0026lt; n; i++) 41 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 42 sort(p.begin(), p.end()); 43 p.push_back(pii(h, w)); 44 vector\u0026lt;ll\u0026gt; dp(n + 1, 0); 45 for (int i = 0; i \u0026lt;= n; i++) { 46 dp[i] = C(p[i].x - 1, p[i].y - 1); 47 for (int j = 0; j \u0026lt; i; j++) 48 if (p[i].y \u0026gt;= p[j].y) 49 sub(dp[i], dp[j] * C(p[i].x - p[j].x, p[i].y - p[j].y)); 50 } 51 cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 52 return 0; 53}  Z. Grid 3 h[i] 為遞增，故可斜率優化，總複雜度 O(N)。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4int main() { 5 ios_base::sync_with_stdio(0), cin.tie(0); 6 int n; ll C; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; C; 7 vector\u0026lt;ll\u0026gt; h(n + 1); 8 for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; h[i]; 9 vector\u0026lt;ll\u0026gt; dp(n + 1); 10 deque\u0026lt;int\u0026gt; dq(1, 1); 11 auto X = [\u0026amp;](int i) { 12 return -2 * h[i]; 13 }; 14 auto Y = [\u0026amp;](int i) { 15 return h[i] * h[i] + dp[i]; 16 }; 17 auto F = [\u0026amp;](int i, int j) { 18 return h[i] * X(j) + Y(j) + C + h[i] * h[i]; 19 }; 20 auto cross = [](ll x1, ll y1, ll x2, ll y2) { 21 return x1 * y2 - x2 * y1; 22 }; 23 for (int i = 2; i \u0026lt;= n; i++) { 24 while (dq.size() \u0026gt;= 2) { 25 if (F(i, dq[0]) \u0026gt;= F(i, dq[1])) 26 dq.pop_front(); 27 else break; 28 } 29 dp[i] = F(i, dq[0]); 30 while (dq.size() \u0026gt;= 2) { 31 int j = dq.back(), k = dq[dq.size()-2]; 32 if (cross(X(j)-X(k), Y(j)-Y(k), X(i)-X(j), Y(i)-Y(j)) \u0026gt;= 0) 33 dq.pop_back(); 34 else break; 35 } 36 dq.push_back(i); 37 } 38 cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 39 return 0; 40}  ","date":"2021-01-04T11:59:31+08:00","permalink":"https://Luke2336.github.io/p/atcoder_education_dp/","title":"AtCoder Educational DP Contest"},{"content":"為了寫 OS 功課，下午去計中想試著裝 Ubuntu，但因為記憶體只有 1GB，所以根本不可能。最後想了一下，應該只需要用 Linux 就可以完成功課了，但是用工作站的 Linux 卻抓不到 Kernel Header。心累～\n很開心 nini 學妹下午從台北回來時，買了蛋糕給我吃。\n洗完澡後，吃了吐司抹果醬當晚餐。\n","date":"2021-01-04T11:58:39+08:00","permalink":"https://Luke2336.github.io/p/20210104/","title":"2021/01/04 日記"},{"content":"早上起床時覺得很累，先跳繩 200 下，然後整理了房間，買了麥當勞當午餐。\n中午之後就一直在忙 OS 的 HW1，跟 Steven 借了 Code 參考了一下該用哪些 module 和 function，然後就自己寫的更簡短，大約 70 行左右，算一算總共花了 7.5 小時在這份作業。\n晚餐吃了自助餐，因為心情不好，所以就吃了雞腿。\n下週五要交 HW2，週日要交 HW3，覺得有點趕。看了一下 HW2 比較麻煩，要寫 Page Table，雖然只要填空其中一小部分。HW3 和 HW4 似乎都只要下 cmd。\nHW4 可能會放到電路學考完後再處理，好擔心電路學期末爆掉，也很擔心期末專題的事，不想當雷組員。\n","date":"2021-01-03T21:21:24+08:00","permalink":"https://Luke2336.github.io/p/20210103/","title":"2021/01/03 日記"},{"content":"今天滿滿的都是分手的痛，身心都痛，吃不下飯。很難過，但卻沒有人陪。\n下午試著寫了 OS 的 HW1，但還是一團糟。於是就洗個澡，洗衣服，完成了交換的申請文件。\n晚上被隊友約去吃宵夜，遇到了威達，他們聊了很多 SA 的事，我一個人有點孤單，但還是很開心他們把我約出去。\n","date":"2021-01-02T14:29:12+08:00","permalink":"https://Luke2336.github.io/p/20210102/","title":"2021/01/02 日記"},{"content":"吃完漢堡王後，去山上，過敏有點嚴重，晚餐吃了燒肉。\n飯後，ㄠㄨ傳訊息問我問題，聊了幾句之後，決定分手。\n","date":"2021-01-02T14:22:35+08:00","permalink":"https://Luke2336.github.io/p/20210101/","title":"2021/01/01 日記"},{"content":"白天去看了醫生，把電路作業寫完了。\n晚上去牛排店體驗了豬排，然後去清大跨年。\n","date":"2020-12-31T16:54:08+08:00","permalink":"https://Luke2336.github.io/p/20201231/","title":"2020/12/31 日記"},{"content":"CH14 這章用 Frequency Domain 來討論電路學，主要的重點有以下幾個：\n Frequency \u0026amp; Magnitude Responce Bode Plots Resonance, Half-Power Freq., Quality Factor Filter: Lowpass, Highpass, Bandpass, Bandstop Magnitude \u0026amp; Frequency Scaling  ","date":"2020-12-30T15:29:08+08:00","permalink":"https://Luke2336.github.io/p/circuit_ch14/","title":"電路學第 14 章"},{"content":"氣溫驟降，雖然室內有 19 度左右，室外卻只有 11 度，很冷。\n早上考了兩科期末考。中午看到認識語言的總成績已經出來了，94分，比預想的高，原本以為大約 92 分，可能有微微調分吧？\n下午讀了電路學的第 14 章，量有點大。卦長告訴我他看不懂 OS 作業，所以幫不上忙 QAQ 讓我壓力有點大，畢竟現在還有交換申請的自傳還沒寫完，以及電路學的考試和作業，另外還有電路 Final Project 還沒開始弄。\n晚餐吃了狗尾草雞湯，想到很久沒去八分寮吃了～飯後就直接睡了，從八點睡到快十二點，之後心情不太好，到三點多才又開始睡。\n期末考 德文期末考 沒看到公告說 8:15 才開始，結果太早到。\n考試內容不難，都是考文法居多，動詞變化、受格、所有格、冠詞，有點吃虧，我花了不少時間被單字，反而陰陽性沒有記得很熟，但感覺應該是可以有 70 以上。\nOS 期末考 在綜一考試，共 10 題，每題都 10 分，覺得這種配分有點糟，因為有些題是選擇題，選錯就爆了，不像問答題會有部份分。\n考完試不小心把筆袋掉在教室 QAQ\n","date":"2020-12-30T11:01:35+08:00","permalink":"https://Luke2336.github.io/p/20201230/","title":"2020/12/30 日記"},{"content":"早上自己讀了一下 OS 的第五章，中午去寄了信，然後卦長幫我複習了一下第九章之後的內容。\n晚上跟卡車、宗達、彥彤去巨城吃飯，欠了彥彤 $175。\n晚餐後讀了德文，然後喝了一小杯梅酒氣泡水才睡。\n晚上一直做惡夢，有夢到自己被隊友嫌棄，還有一些偏向災難片的夢，醒了三次以上。\n","date":"2020-12-30T11:01:29+08:00","permalink":"https://Luke2336.github.io/p/20201229/","title":"2020/12/29 日記"},{"content":"CH5 - Process Synchronization The Critical-Section Problem 有些資源只能同時被一個 process 使用。\ndo { entry_section(); // critical section  exit_section(); // remainder section while (true);  Mutual Excusion Progress (Freedom from Deadlock) Bounded Wait (Freedom from Starvation)   preemptive: 資源被使用時可以被打斷 non-preemptive  Peterson\u0026rsquo;s Solution class PetersonLock { // shared var.  bool flag[2]; int victim; public: void lock() { int i = ThreadID.get(); int j = 1 - i; flag[i] = true; victim = i; while (flag[j] \u0026amp;\u0026amp; victim == i); } void unlock() { int i = ThreadID.get(); flag[i] = false; } }; do { lock(); // critical section  unlock(); // remainder section while (true); Test \u0026amp; Set // atomic bool test_and_set (bool *target) { bool ret = *target; *taget = true; return ret; } do { wait[i] = true; while (wait[i] \u0026amp;\u0026amp; test_and_set(\u0026amp;lock) ); wait[i] = false; // critical section  j = (i + 1) % n; while ( (j != i) \u0026amp;\u0026amp; !waiting[j] ) j = (j + 1) % n; if (j == i) lock = flase; else wait[j] = false; } while (true); Compare \u0026amp; Swap int compare_and_swap (int * val, int expected, int new_val) { int tmp = *val; if (*val == expected) *val = new_value; return tmp; } do { while (compare_and_swap(\u0026amp;lock, 0, 1) ); // critical section  lock = 0; // remainder section } while (true); Mutex acqueire() and release() are atomic.\nacquire() { while (!available) ; available = false; } release () { available = true; } do { acquire(); // critical section  release(); // remainder section } while (true); Semaphore  counting/binary semaphore semaphore S : integer wait() and signal() are atomic  wait(S) { while (S \u0026lt;= 0) yeild(); S--; } signal(S) { S++; } Implementation (Blocking) struct sempaphore { int cnt; queue q; } void wait(semaphore *S) { S-\u0026gt;cnt--; if (S-\u0026gt;cnt \u0026lt; 0) { S-\u0026gt;q.push(process); block(); } } void signal(semaphore *S) { S-\u0026gt;cnt++; if (S-\u0026gt;cnt \u0026gt;= 0) { P = S-\u0026gt;q.pop(); wakeup(P); } } Examples 1. Bounded-Buffer Problem init Semaphores: mutex-\u0026gt;cnt = 1; full-\u0026gt;cnt = 0; empty-\u0026gt;cnt = N; // producer do { // produce an item  wait(empty); wait(mutex); // add the item to buffer;  buffer[in] = product; in = (in + 1) % N; signal(mutex); signal(full); } while (true); // consumer do { // produce an item  wait(full); wait(mutex); // add the item to buffer;  product = buffer[out]; out = (out + 1) % N; signal(mutex); signal(empty); } while (true); 2. Readers-Writers Problem 3. Dining-Philosophers Problem ","date":"2020-12-28T14:40:40+08:00","permalink":"https://Luke2336.github.io/p/os_ch5/","title":"OS CH5 複習"},{"content":"今天將認識語言的報告寫完，中午就交出去了，傍晚便收到評語，得到了 94 分，覺得很開心，因為有幾個問題被認為提得不錯，主要是對於演化的部分。\n下午又整理了一下德文筆記，讀了一點點 OS，然後晚餐吃了漢堡。頭有點痛，偶而也會暈，這幾天都很早起來，算是輕微失眠。\n","date":"2020-12-28T11:59:10+08:00","permalink":"https://Luke2336.github.io/p/20201228/","title":"2020/12/28 日記"},{"content":"方向 / 方位    中文 German     上 über   下 unter   左 links   右 rechts       中文 German     東 der Osten   西 der Westen   南 der Süden   北 der Norden     Berlin liegt im Osten von Deutschland. in die Mitte  數字用法    Zahlen German Zahlen German Zahlen German     0 null 10 zehn 20 zwanzig   1 eins 11 elf 21 einundzwanzig   2 zwei 12 zwölf     3 drei 13 dreizehn     4 vier 14 vierzehn     5 fünf 15 fünfzehn     6 sechs 16 sechzehn     7 sieben 17 siebzehn     8 acht 18 achtzehn     9 neun 19 neunzehn         Zahlen German     20 zwanzig   30 dreißig   40 vierzig   50 fünfzig   60 sechzig   70 siebzig   100 (ein)hundert   101 hunderteins   1.000 (ein)tausend   10.000 zehntausend   100.000 hunderttausend   1.000.000 eine Million   1.000.000.000 eine Billion    價格 Preis  小數點 (,) 千分位 (.) 100 Cent = 1 Eruo 9,99 € = 9 Euro 99 9,99 € = 50 Cent  WH 疑問句    German English     Was What   Wer Who   Wie How   Wo Where   Woher From where    動詞變化    中文 人稱 規則 machen leben wohnen arbeiten haben sprechen sein     我 ich e mache lebe wohne arbeite habe spreche bin   你 du st machst lebst wohnst arbeitest hast sprichst bist   他/她 er/sie t macht lebt wohnt arbeitet hat spricht ist   我們 wir - machen leben wohnen arbeiten haben sprechen sind   你們 ihr t macht lebt wohnt arbeitet habt spricht seid   他們/您(們) sie/Sie - machen leben wohnen arbeiten haben sprechen sind    自我介紹 Name 姓名  Wie heißen Sie / heißt du? Wer sind Sie / bist du? Ich bin/heiße ___. Mein Name ist ___.  Herkunft 籍貫  Woher kommen Sie / kommst du? Ich komme aus Taiwan.  Wohnort 居住地  Wo wohnen Sie / wohnst du? Ich wohne in ___.  Alter 年齡  Wie alt sind Sie / bist du? Ich bin 20 Jahre alt  Beruf 職業  Was sind Sie / bist du von Beruf? Was machen Sie / machst du beruflich? Ich bin / arbeite als ___ bei ___.  Famienstand  Ich habe ein Kind / zwei, keine Kinder. Ich bin verheirater（結婚） / geschieden（離婚） / Single. Ich leben (nicht) zusammen.（同居）  問候語 打招呼  Hallo. Guten Morgen. Guten Tag. Guten Abend. Gute Nacht.  How are you?  Wie gets es Ihnen? / Wie geht\u0026rsquo;s?  Sehr gut. Gut, danke. Es geht. Nicht so gut.   Gut, danke. Und Ihnen?  Auch gut.    Googbye  Auf Wiedersehen. Tschüs.  Burufe    中文 男生 女生     工程師 der Ingenieur    機械師 der Mechatroniker    演員 der Schauspieler    大學生 der Student die Studentin   記者 der Journalist die Journalistin   髮型師  die Friseurin   建築師  die Architektin   秘書  die Sekretärin   醫生 der Arzt die Ärztin   教師 der Lehrer    小販 der Verkäufer    服務生  die Kellnerin    Mann / Frau    男生 女生     Kollege Kollegin   Freund Freundin   Partner Partnerin    Familie    中文 English German     父親 Father der Vater   母親 Mother die Mutter   父母 Parent die Eltern   兒子 Son der Sohn   女兒 Daughter die Tochter   兄弟 Brother der Bruder   姐妹 Sister die Schwester   兄弟姊妹 Sibling die Geschwister   祖父 Grandpa der Großvater / Opa   祖母 Grandma die Großmutter / Oma   祖父母 Grandparent die Großeltern   孫女 Granddaughter die Enkelin   孫子 Grandson der Enkel   先生 Husband der Ehemann   太太 Wife die Ehefrau    所有格    主格 der / das die     ich mein meine   du dein deine   er/es sein seine   sie ihr ihre   wir unser unsere   Sie Ihr Ihre    所有格 Akkusativ nach haben, brauchen, suchen, \u0026hellip;     definiter Artikel indefiniter Artikel Netativ-Artikel      Sie hat den einen keinen Laptop.    das ein kein Formula.    die eine keine Briefmarke.    die - keine Stifte.    Sprachen  Welche Sprachen sprechen Sie / sprichst du? Ich spreche sehr gut / gut / ein bisschen \u0026hellip;     der Land Sprachen     das Deutschland Deutsch   das Frankreich Französisch   die USA    die Niederlande Niederländisch   England Englisch   das Mexiko    das Spanien Spanisch   die Türkei    das Polen Polnisch   das Tschechien Tschechisch   das Russsland Russisch   das Österreich     Möbel 家具    English German Plural     bed das Bett Betten   picture das Bild Bilder   armchair der Sessel Sessel   lamp die Lampe Lampen   chair der Stuhl Stühle   sofa das Sofa Sofas   couch die Couch Couchen   table der Tisch Tische   closet（抽屜） der Schrank Schränke   carpet（地毯） der Teppich Teppiche    Gegenstände    English German Plural     pencil der Bleistift Bleistifte   glasses die Brille Brillen   book das Buch Bucher   bottle die Flasche Flaschen   lighter das Feuerzeug Feuerzeuge   camera der Fotoapparat Fotoapparate   chain die Kette Ketten   pen der Kugelschreiber Kugelschreiber   key der Schlüssel Schlüssel   bag die Tasche Taschen    Im Büro    English German Plural     laptop der Laptop Laptops   e-mail die E-Mail E-Mails   cell phone das Handy Handys   SMS die SMS    bill die Rechnung Rechnungen   phone das Telefon Telefone   form das Formular Formulare   printer der Drucker Drucker   mouse die Maus Mauß   computer der Computer Computer   pen der Stift Stifte   notebook das Notizbuch Notizbucher   calender der Kalender Kalender   screen der Bildschirm Bildschirme    Personalpronomen    maskulin neutral feminin     der das die   er es sie    Beratungsgespräche    German English     Brauchen Sie Hilfe Do you need help   Ja, bitte.      Wie viel / Was kostet (denn) die Lampe? Die Lampe kostet 119 Euro. Das ist ein Sonderangebot（特價）.    Das ist (sehr / zu / aber) teuer / günstig / billig. Der Tisch ist zu groß / zu klein. Ich finde die Lampe (wirklich) sehr schön. Das finde ich auch. 我同意 / Das finde ich night. 我不同意 Finden Sie? / Findest du? 你同意嗎？    teuer 昂貴 günstig / billig 便宜 groß 大 klein 小 schön 漂亮  Materialien 材質  Die Brille ist aus ___.     中文 German     木頭 Holz   金屬 Metall   紙 Papier   塑膠 Kunststoff / Plastik   玻璃 Glas    Farben 顏色    中文 German     紅色 röte / rot   綠色 grün   橘色 orange   黑色 schwarz   棕色 braun   藍色 blau   黃色 gelb   白色 weiß    Formen 形狀    中文 German     方形 eckig   圓形 rund    nach Wörtern fragen  A: Entschuldigung, wie heißt das auf Deutsch? B: Das ist eine Uhr. A: We bitte? Noch einmal, bitte. B: Das ist eine Uhr. A: We schreibt man Uhr? B: U - H - R. A: Danke. B: Bitten schön. Kein Problem.  Internet bestellen 網購  Anrede: Frau / Herr Vorname Falmiliename Geburtsdatum: Tag / Monat / Jahr （生日） Postleitzahl (PLZ) （郵遞區號）  ","date":"2020-12-28T10:19:18+08:00","permalink":"https://Luke2336.github.io/p/german1/","title":"德文（一）筆記"},{"content":"「認識語言」期末報告 以下介紹五個我在「認識語言」下半學期學到的重點。\n1. Chomsky 和行為主義 (Behaviorism) 的對立 語言的學習是後天的 (nurutre)，還是天生就有的 (nuture) 學習能力？\n行為主義興起的背景，要從佛洛伊德的時代開始談起，當時心理學是立足於潛意識等無法觀測的東西，因此很多科學家無法認同心理學屬於科學的一支。\n在 Parlov、Skinner 和 Waston 等人的努力下，產生了行為主義學派。他們透過設計實驗來研究人或動物的行為模式，像是古典制約的實驗中，Parlov 的狗被制約，每次接收到搖鈴刺激 (stimulus)，就會不由自主的流口水。而 Skinner 進一步提出了操作制約，透過食物來讓老鼠自己學會按開關。\n行為主義者宣稱，他們可透過制約，也就是給予 positive/negative reforcement，使人類學習，這屬於 stimulus-response learning。他們認為母語的學習也可以透過同樣的管道。\n對此，Chomsky 有不同的看法，他認為語言的習得無法僅僅透過後天的經驗，先天的能力是必須的，因此他提出了 Universal Grammar。\u0026ldquo;What you know exceeds what you were taught.\u0026quot;，舉例來說，小孩子會犯一些大人不會犯的錯誤，像是 \u0026ldquo;holded\u0026rdquo;，這是他們無法透過模仿習得，可以推論出他們先天具備一些學習語言的能力，像是統計、歸納等等。\nChomsky 說明了在語言的學習上，本能和經驗都是重要的。我認為他的想法是重要且具有突破性的，因為他不只影響了語言學的發展，更對心理學造成了重大的影響，他證明了行為主義是無法解釋所有現象的，讓心理學研究慢慢走出行為主義的框架。\n2. Universal Grammar (UG) Universal Grammar 是 Chomsky 的理論，為了描述所有語言的共同點。Universal Grammar 是由 principles 和 parameters 共同組成。\n由於孩童學習語言的時間是有限的，且他們能得到的資訊量也是有限的，但他們能表達的語句，卻是無限的。可見，這些語句不僅僅是藉由經驗而習得，而需要藉由人類天生就有的 Universal Grammar，將得到的句子提取出一些共通的 principles。像是人們能判斷句子中的代名詞或是反身代名詞是在指誰，都是我們在學習時無法直接解釋的，這些天生就具備的能力，就是屬於 Universal Grammar。\n但這些 principles 卻只能解釋語言具有共通性，而無法解釋語言的差異性，因此他在理論中加入了 parameters 的想法。\n在英語中，是先表達動詞，然後才是受詞。然而，在日語中，兩者卻是相反的。又或是在英文中，我們會將 Where/Who 等疑問詞放在句子開頭，而在中文中，我們卻會任意擺放哪裡/誰/何時在句子的其他位置。這些現象無法被 principles 概括，因此我們有了 parameters。parameters 提供了孩童在學習時，能藉由聽到的資訊，將母語中沒有的 parameters 捨棄，讓他們能專注於學習母語中有的文法或發音。\n我認為 UG 重要的原因在於它解釋了大部分的語言學習現象，但其發展卻極具挑戰，畢竟這個理論需要符合世界上的所有語言，所以每當科學家舉出一個反例時，這個理論就必須做出修改，因此這個理論勢必逐漸簡化成現今的模樣。\nUG 到底是如何演化出來的，我認為這是一個滿有趣的問題。人腦中的 Universal Grammar 到底是愈來愈複雜，又或是愈來愈簡化呢？如果按照我對 Universal Grammar 的認識，有了 parameters 的幫助，或許 principles 是可以發展成愈來愈多的？\n3. 嬰兒的語言發展階段 嬰兒的母語發展有幾個重要的階段：\n 在懷孕的最後幾週，嬰兒的聽力系統已接近發育完全，因此他們就會開始聆聽外界聲音，剛出生的嬰兒就對母語有偏好。 3 個月：larynx lowerling，嬰兒的喉頭會下降，他們能發出更多的聲音。 6 ~ 10 個月：phoneme comprehension，嬰兒開始失去辨識母語以外的音的能力，不再能分辨所有語言中的音，這讓他們能更專注於學習母語。 6 ~ 12 個月：他們透過 Babbling 來學會發音。 1 歲多時他們能一些單詞 (1-word)。快 2 歲時，他們會說兩個詞的句子 (2-words)。 2 ~ 2.5 歲時，telegraphic stage，他們的單字量迅速擴增，並且能組合成完整的句子，儘管文法不一定正確。 2.5 歲後：他們開始發展像成人的語句，並且已習得大多數文法規則，但他們會出現 over-generalization 的狀況，也就是有了像 \u0026ldquo;goed\u0026rdquo; 或是 \u0026ldquo;holded\u0026rdquo; 等成人不會犯錯誤。  科學家是如何針對不會說話的嬰兒進行研究呢？他們有幾種有趣的研究方式，例如：\n Pacifier experiment：他們利用嬰兒吸食奶嘴的速度來研究嬰兒對事物的興趣，例如他們在聽到的聲音從 /ba/ 變成 /pa/ 時，他們會改變吸食速度。 Head-turn Experiment：科學家可能藉由讓嬰兒學會某些規則，例如聽到 ABA 時，玩偶會出現在左方，反之，聽到 AAB ，則會出現在右方。之後，在透過紀錄嬰兒轉頭的方向，來實驗嬰兒是否能學會規則。  這幾個發展的階段，有解釋到幾個我以前無法理解的疑問。首先，我了解到我們長大後學習語言，為什麼無法達到學母語一樣的成果。接著，我也理解到人類演化出喉頭下降是非常重要的，像是我們的近親 - 猿類，就沒有這個演化結果，這讓他們有些音是發不出來的（例如：/i/、/a/、/u/）。而這個演化其實是對人類高風險的，因為這會干擾消化道和呼吸道分離。但他卻出現在三個月大時，以適者生存的角度來看，語言對於人類的生存是非常重要的。\n非常有趣的一點是，全世界的嬰兒都是用相近的時程來發展，顯然這些都是演化的結果。在上課中有提過，猿類對語言的學習至多是線性的結構，無法像人類一樣有階層狀/洋蔥狀的結構，也無法創造太長的句子。有些好奇有沒有研究能知道這樣的大腦發展的演化和人類發音器官構造的演化，究竟是誰先誰後？還有是否有其他生物一樣有 phoneme comprehension 的現象？\n4. 雙母語嬰兒的認知能力 在討論雙母語和單母語嬰兒的認知差異前，我們需要先定義認知能力是什麼？\nExecutive functions (EF) 是認知心理學中，對於人類一些認知能力的統稱，包含了管理工作記憶、控制衝動、能處理多項工作（能快速轉換）的能力。這些能力主要是由前額葉所控制。\n根據研究，雙母語和單母語嬰兒習得母語的所需時間是相近的。這是由於雙母語的學習會刺激認知能力的發展，而發展較好的認知能力也有助於雙母語的學習。\n嬰兒在雙母語環境下，他的大腦需要處理兩種語言，因此需要前額葉的幫助，使得嬰兒能快速在兩種語言中切換。根據 Kovács \u0026amp; Mehler 對 7 個月大的研究，當同時有兩個規則時，單母語環境的嬰兒只能學會較簡單的那種，而雙母語嬰兒能學會兩種，得到了雙母語嬰兒有較佳 EF 的結論。\n很重要的一點是，根據科學家的研究，EF 的發展最快速的時期是在 6 歲前，因此父母在 6 歲前給予嬰兒適當的刺激有助於發展他們的 EF，像是唸外語故事書就是很好的方式。而對於雙語的人，就算他們長時間只使用單一語言，但他們的前額葉仍需要去抑制另外一種語言，因此研究也指出雙語的人比單語的人得到老年癡呆的平均年齡晚 4 年。\n我很好奇的一點是，人類嬰兒學習語言的能力和其認知能力是相輔相成的，那他們最多能學習多少種語言才會達到認知能力的極限？\n5. Finite State Grammars (FSGs) Finite State Grammar 是 Chomsky 提出的概念。我們都知道，句子是由 finite 的字詞組成而成，但其組成方法是無限的。對於一個有限長度的句子，我們可以透過一種特殊的 finite state machine 生成，這種 finite state machine 運用了 transition probability (TP) 的概念，藉由 TP 來定義一種 Markov chain。\n然而，這種想法是無法實際運用在生成自然語言，他遠遠不足以表達人類的文法。由於 FSGs 只能藉由上一個狀態去決定下一個狀態，故在定義狀態時，只會是線性的，無法表達出階層的概念，也無法透過機率去生成合乎文法的句子，像是不同時態的 is/was，出現在某個名詞後面的機率會是相近的。因此，最後有了 Phrase Sturcture Grammars (PSGs)，讓句子能嵌入進句子中，有了階層狀的結構，而能表達出字詞間的關聯性，不在侷限於相鄰的字間。\nFSGs 的重要性在於，他提供了一種簡單的運算方式，讓電腦能生成語句。且他將一些遞迴的想法，透過 state diagram 中的 cycle / loop 來達成。\n句子的組成無法用 Finite State Machine 來表達，但英文的構詞是否能用 Finte State Machine 來找到一些規則？\nFeedback 因為提出的問題不錯，所以得到 94 分。\n 有些好奇有沒有研究能知道這樣的大腦發展的演化和人類發⾳器官構造的演化，究竟是誰先誰後?   應該是發音器官的演化比較早，因為喉頭下降的生理現象雖然黑猩猩與猿類沒有，但是在其他的生物上有歐！例如鹿類就有，但是在其他生物上演化出此生理特徵不是了語言，而是為了增加吼叫聲的威嚇力，讓敵人感覺你的體積龐大，由於有這個另外的演化動力，所以學者的假說是發聲器官的改變早於大腦演化。\n  是否有其他⽣生物一樣有 phoneme comprehension 的現象?   其他的生物也會有phoneme comprehension的categorical perception的現象！\n ","date":"2020-12-28T10:09:29+08:00","permalink":"https://Luke2336.github.io/p/understanding_language_final_report/","title":"認識語言 期末報告"},{"content":"中午和ㄠㄨ一起吃了麥當勞，然後在系計中唸了 OS，晚餐吃了女二樓下的丼飯。他送了我一盒巧克力，當作其中一樣聖誕禮物。晚上他回去上競程，我洗完澡後，在宿舍裡寫認識語言的期末報告。\nToggl 用了這個軟體一週，發現用功的時間似乎有增加。發現自己雖然平常課不多，但假日還是相對會想強迫自己用功。這幾天身體相對疲憊，所以週間做的事略少。\n","date":"2020-12-27T10:21:14+08:00","permalink":"https://Luke2336.github.io/p/20201227/","title":"2020/12/27 日記"},{"content":"早上去看醫生，中午吃了蝦仁炒飯＋牛雜湯。\n下午因為天氣不錯，就去走了走，看看白鷺鷥。\n傍晚很累，睡了一個半小時午覺後，就去全家買了晚餐，然後就準備了家教的東西。\n不小心上太快，只好現場打點 code 補時間。結束時聊了一下，感覺因為疫情的緣故，對方不想到美加地區，於是就沒有補習的需求，我快失業了 QAQ 但下學期還要當助教，所以沒有特別有想要接案的念頭，看看暑假實習的面試狀況再決定吧。\n晚上梳洗完後，吃了橘子，一點前睡著。\n","date":"2020-12-27T00:33:15+08:00","permalink":"https://Luke2336.github.io/p/20201226/","title":"2020/12/26 日記"},{"content":"下午去找導師簽交換的文件，然後就開始做家教的投影片。傍晚悅庭來找我玩，送了我瑪露連。晚餐去吃了火鍋，生理期身體不太舒服。飯後複習了德文，然後才休息。\n晚上看了怡芬老師的貼文，被感動到，加上很想念北一女，所以就哭了。\n","date":"2020-12-25T10:08:59+08:00","permalink":"https://Luke2336.github.io/p/20201225/","title":"2020/12/25 日記"},{"content":"早上維持了昨夜的疲倦感，很不想做事。\n上完電路學後，複習了德文。今天電路學教 Laplace Transform。晚上跑去市區吃飯，吃了前幾天吃湯圓時看到的肉。\n109-2 課表 今天早上看了選課結果，不甚滿意，沒選上密碼學，也沒選上素描課，考慮再選一門 EDA 湊 15 學分。\n","date":"2020-12-24T14:10:19+08:00","permalink":"https://Luke2336.github.io/p/20201224/","title":"2020/12/24 日記"},{"content":"儀式感 身邊很多男性友人的生活都充滿儀式感，從日常生活到過節都是。例如睡前一定要打電動，或是早上一定要喝一杯咖啡。\n之前會覺得這種生活很僵硬，有時候男友就算出去約會，也不願放棄他的儀式。但現在的我，對於儀式會有種不同的想法，就是生活中的「錨點」，讓生活不至於太過散亂。\n從每週的運動習慣，吃飯睡覺的時間，或是喝杯茶，洗澡，這些固定的動作都有助於維持生活。雖然會是一種制約，但卻可以訓練成做某些事的時候，心裡能特別興奮，有助於維持健康。\n選課 這是期望的課表，但人社院那門素描只有 15 個名額，目前大約 60% 的機率，感覺不好選到。而密碼學則只有 50% 的機率抽到，不知道這種數學課為什麼那麼熱門。難解問題被正規擋修了，有點難過。資工系好像沒什麼想選的課了，希望至少選到三門主科。我不想再申請低修啊！！\n 主科：密碼學(3)、正規語言(3)、計算方法之實務應用(3) 外文：德文二(2)、進階英文(2) 通識：教育學概論(2) 其他選修：生活中的素描(3)  最後一堂羽球課 考完了期末考，很開心能被稱讚米字步跑得很好！和大家打了單打，今天比上週好，因為不像之前那樣緊張。老師說下學期的期中是高遠球，期末是切球上網連續 8 次。\nPCCA 準備了巧克力和卡片送給隊友。\n今天是個人練習，我前面還算順，但後面就體力不支，放棄後回宿舍休息。\n","date":"2020-12-23T10:18:18+08:00","permalink":"https://Luke2336.github.io/p/20201223/","title":"2020/12/23 日記"},{"content":"有點煩悶，犬齒附近又咬到發炎了。很疲倦，不想做任何事。\n晚上上完電路後，去吃了海洋牛排。\n","date":"2020-12-22T14:38:56+08:00","permalink":"https://Luke2336.github.io/p/20201222/","title":"2020/12/22 日記"},{"content":"Christmas Card 畫了聖誕卡片，想要送給隊友。\n認識語言 今天是最後一堂課，教了 Finate State Grammars，下週要交期末報告。\n冬至 吃了紅豆湯圓。\n","date":"2020-12-21T10:53:26+08:00","permalink":"https://Luke2336.github.io/p/20201221/","title":"2020/12/21 日記"},{"content":"昨晚很冷睡得不太好，期末快到了壓力有點大。下午跟男友把腳踏車擦乾淨，並幫輪胎打氣。之後主要的時間是寫電路學作業，然後吃了漢堡王當晚餐。之後寫了兩成的認識語言期末報告。\n晚上去打了羽球，覺得手很痠痛。心情不太好，於是提早收工，在麥當勞買了雞翅和玉米湯後，回宿舍休息。覺得很失望，原本預期雞翅要有兩隻，結果得到的是一隻拆成兩節。\n期末 Deadlines    Work Deadline     電路 HW12 12/22（二）   家教 12/26（六）   語言 Report 12/28（一）   OS Exam 12/30（三）   德文 Exam 12/30（三）   OS HW1 01/03（日）   OS HW2 01/03（日）   OS HW3 01/03（日）   電路 HW13 01/05（二）   交換 自傳 01/08（五）   家教 01/09（六）   電路 Exam 01/12（二）   電路 Project 01/19（二）    Week Todo List  電路 HW12 家教 投影片 認識語言 期末報告 準備 OS 期末考  一天讀兩章   準備 德文 考試  背單字 讀文法   跑簽核單：導師 \u0026amp; 系辦  Toggl 今天開始重新尋找計時工具，發現了這款可在裝置間同步的 APP。\n","date":"2020-12-20T10:43:32+08:00","permalink":"https://Luke2336.github.io/p/20201220/","title":"2020/12/20 日記"},{"content":"AtCoder Beginning Contest 186 pE 讓我卡了一下，於是就掉分了。pF 想到了一個假解，浪費了不少時間。可能是因為剛打完 CF，所以狀態不好。\nA. Brick 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 int n, w; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; w; 5 cout \u0026lt;\u0026lt; n / w \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 6 return 0; 7}  B. Blocks on Grid 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 ios_base::sync_with_stdio(0); cin.tie(0); 5 int h, w; cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w; 6 int sum = 0, m = 105; 7 for (int i = 0; i \u0026lt; h; i++) { 8 for (int j = 0; j \u0026lt; w; j++) { 9 int x; cin \u0026gt;\u0026gt; x; 10 sum += x; 11 m = min(m, x); 12 } 13 } 14 cout \u0026lt;\u0026lt; sum - m * h * w \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 15 return 0; 16}  C. Unlucky 7 求 1 ~ n 中，有多少個數的十進位和八進位都沒有 7。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3bool check(int n, int k) { 4 while (n) { 5 if (n % k == 7) return false; 6 n /= k; 7 } return true; 8} 9int main() { 10 int n; cin \u0026gt;\u0026gt; n; 11 int cnt = 0; 12 for (int i = 1; i \u0026lt;= n; i++) 13 cnt += check(i, 10) \u0026amp; check(i, 8); 14 cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 15 return 0; 16}  D. Sum of difference 求 |ai - aj|, i \u0026lt; j 的總和。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4int main() { 5 ios_base::sync_with_stdio(0); cin.tie(0); 6 int n; cin \u0026gt;\u0026gt; n; 7 vector\u0026lt;ll\u0026gt; a(n); 8 for (int i = 0; i \u0026lt; n; i++) 9 cin \u0026gt;\u0026gt; a[i]; 10 sort(a.begin(), a.end()); 11 vector\u0026lt;ll\u0026gt; sum(n + 1); 12 for (int i = n - 1; i \u0026gt;= 0; i--) 13 sum[i] = sum[i + 1] + a[i]; 14 ll ans = 0; 15 for (int i = 0; i \u0026lt; n; i++) 16 ans += sum[i + 1] - a[i] * (n - i - 1); 17 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 18 return 0; 19}  E. Throne 先用 extgcd(k, n) 求 xk + bn = gcd(k, n)，再求 xk % n = s 的最小整數解。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;ll, ll\u0026gt; pii; 5ll gcd (int a, int b) { 6 return b ? gcd(b, a % b) : a; 7} 8pii extgcd(ll a, ll b) { 9 if (!b) return {1, 0}; 10 ll k = a / b; 11 pii p = extgcd(b, a - k * b); 12 return {p.second, p.first - k * p.second}; 13} 14int main() { 15 ios_base::sync_with_stdio(0); cin.tie(0); 16 int T; cin \u0026gt;\u0026gt; T; 17 while (T--) { 18 ll n, s, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; 19 ll g = gcd(n, k); 20 if (s % g) { 21 cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; continue; 22 } 23 ll ans = -extgcd(k, n).first * s / g; 24 ans %= n / g; 25 if (ans \u0026lt;= 0) ans += n / g; 26 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 27 } 28 return 0; 29}  F. Rook on Grid 給定一個 H x W 的棋盤，以及 M 個障礙物。 (H, W, M ≤ 2e5)\n求從 (1, 1) 出發 Rook 能在兩步內到達的格子有幾個？\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define x first 6#define y second 7#define maxn 200005 8class RangeUpdateBIT { 9 private: 10 ll d[maxn], dd[maxn]; 11 ll sum(int i) { 12 ll s = 0, ss = 0; 13 int c = i + 1; 14 while (i \u0026gt; 0) s += d[i], ss += dd[i], i -= i \u0026amp; -i; 15 return c * s - ss; 16 } 17 void add(int i, ll v) { 18 int c = i; 19 while (i \u0026lt; maxn) 20 d[i] += v, dd[i] += c * v, i += i \u0026amp; -i; 21 } 22 public: 23 RangeUpdateBIT() { 24 memset(d, 0, sizeof(d)); 25 memset(dd, 0, sizeof(dd)); 26 } 27 ll sum(int l, int r) { return sum(r) - sum(l - 1); } 28 void add(int l, int r, ll v) { 29 add(l, v), add(r + 1, -v); 30 } 31}; 32int main() { 33 ios::sync_with_stdio(0); cin.tie(0); 34 int h, w, m; cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w \u0026gt;\u0026gt; m; 35 vector\u0026lt;pii\u0026gt; p(m); 36 vector\u0026lt;int\u0026gt; col(w + 1, h + 1), row(h + 1, w + 1); 37 for (int i = 0; i \u0026lt; m; i++) { 38 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 39 col[p[i].y] = min(col[p[i].y], p[i].x); 40 row[p[i].x] = min(row[p[i].x], p[i].y); 41 } 42 sort(p.begin(), p.end()); 43 ll ans = 0; 44 for (int i = 1; i \u0026lt;= w \u0026amp;\u0026amp; col[i] \u0026gt; 1; i++) 45 ans += col[i] - 1; 46 RangeUpdateBIT T; 47 T.add(row[1], w + 1, 1); 48 for (int j = 2, pi = 0; j \u0026lt;= h \u0026amp;\u0026amp; row[j] \u0026gt; 1; j++) { 49 while (pi \u0026lt; m \u0026amp;\u0026amp; p[pi].x \u0026lt; j) pi++; 50 int R = (pi \u0026lt; m \u0026amp;\u0026amp; p[pi].x == j) ? p[pi].y : w + 1; 51 ans += T.sum(1, R - 1); 52 while (pi \u0026lt; m \u0026amp;\u0026amp; p[pi].x ==j) { 53 if (!T.sum(p[pi].y, p[pi].y)) 54 T.add(p[pi].y, p[pi].y, 1); 55 pi++; 56 } 57 } 58 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 59 return 0; 60}  ","date":"2020-12-19T22:03:36+08:00","permalink":"https://Luke2336.github.io/p/atcoder_abc186/","title":"AtCoder Beginning Contest 186"},{"content":"Codeforces Round #691 (Div. 2) 因為 pC 找不到 bug，就一直亂丟，於是打得超爛。Rating 加了 43 到 1695。\npA. Red-Blue Shuffle 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define pb push_back 6int main() { 7 ios_base::sync_with_stdio(0); cin.tie(0); 8 int T; cin \u0026gt;\u0026gt; T; 9 while (T--) { 10 int n; cin \u0026gt;\u0026gt; n; 11 string R, B; 12 cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; B; 13 int r = 0, b = 0; 14 for (int i = 0; i \u0026lt; n; i++) 15 if (R[i] \u0026gt; B[i]) r++; 16 else if (R[i] \u0026lt; B[i]) b++; 17 if (r \u0026gt; b) cout \u0026lt;\u0026lt; \u0026#34;RED\\n\u0026#34;; 18 else if (r \u0026lt; b) cout \u0026lt;\u0026lt; \u0026#34;BLUE\\n\u0026#34;; 19 else cout \u0026lt;\u0026lt; \u0026#34;EQUAL\\n\u0026#34;; 20 } 21 return 0; 22}  pB. Move and Turn 總共走 n 步，每走一步要從東西向換成左右向，問總共有幾種不同的終點？\n首先，計算兩種各自需要走幾步，假設一種為 a 和 b 步，則各自有 a 和 b 種線性組合 (x - y = a)，接下來考慮第一步為東西或南北，若 a 和 b 不同，則答案為 a * b * 2，否則為 a * b。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define pb push_back 6int main() { 7 ios_base::sync_with_stdio(0); cin.tie(0); 8 int n; cin \u0026gt;\u0026gt; n; 9 int a = n / 2, b = n - n / 2; 10 int ans = (a + 1) * (b + 1); 11 if (a != b) ans *= 2; 12 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 return 0; 14}  pC. Row GCD 給定 1 ≤ n, m ≤ 2e5，給定 a1 ~ an, b1 ~ bm，回答 a1 + bj ~ an + aj 的最大公因數 GCDj。\n輾轉相除法是用相減，所以直接用數列差的 GCD 去和 a1 + bj 取 GCD 即可。\n需要小心 n = 1 的狀況，不小心踩到坑了 QAQ\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define pb push_back 6int main() { 7 ios_base::sync_with_stdio(0); cin.tie(0); 8 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 9 vector\u0026lt;ll\u0026gt; a(n); 10 for (int i = 0; i \u0026lt; n; i++) 11 cin \u0026gt;\u0026gt; a[i]; 12 sort(a.begin(), a.end()); 13 ll g = n \u0026gt; 1 ? a[1] - a[0] : 0; 14 for (int i = 2; i \u0026lt; n; i++) 15 g = __gcd(g, a[i] - a[0]); 16 for (int j = 0; j \u0026lt; m; j++) { 17 ll b; cin \u0026gt;\u0026gt; b; 18 cout \u0026lt;\u0026lt; __gcd(g, a[0] + b) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 19 } 20 return 0; 21}  ","date":"2020-12-19T19:07:58+08:00","permalink":"https://Luke2336.github.io/p/cf_contest_1459/","title":"Codeforces Round 691 Div. 2"},{"content":"半夜很餓，難得的去全家買了義大利麵當宵夜。\n北一女校慶擺攤事件  倫子老師的貼文 身為北一女校友以及一個女性，覺得台灣媒體及網民的素質極低。以陪聊天賺錢究竟是不是物化女性呢？若是反過來難道會變成物化男性嗎？顯然這完全是網友們本身對女性帶有著性別偏見。  Code  Codeforces Round #691 (Div. 2) AtCoder Beginning Contest 186  ","date":"2020-12-19T10:38:44+08:00","permalink":"https://Luke2336.github.io/p/20201219/","title":"2020/12/19 日記"},{"content":"下午上了 OS，覺得真的有點無聊，不確定下學期還要不要選他的課。晚餐吃了香菇雞湯，覺得還不錯吃。\n學生證不見？ 一回宿舍就發現找不到學生證，似乎從小包包裡掉出來了，後來有找到。順便研究了學校的掛失系統，覺得一張 $200 會很想哭，加上裡面還剩 $500 以上。雖然掛失後會把 48 Hr 後的餘額退還，但還是很緊張。發現如果 12:00 前申請補發，當天下午就能拿到，比想像中方便。沒有學生證，就不能打球了！！\n語言學演講 中午去聽語言學的演講，學到了一些 L1 / L2 English 的差異。\n Topic: Boundaries, Contrast and Differentiation in Continuous Speech Talker: Chiu-yu Tseng  CSES - 1146 - Counting Bits 問 1 ~ n 的二進制表示法中，共有多少個 1-bit？\n   十進位 $$2^2$$ $$2^1$$ $$2^0$$     0 0 0 0   1 0 0 1   2 0 1 0   3 0 1 1   4 1 0 0   5 1 0 1   6 1 1 0   7 1 1 1    觀察 0/1 交替的方式，最末位是每隔 1 個，接下來是每隔 2 個，接下來是每隔 4 個\u0026hellip;\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4int main() { 5 ll n, ans = 0; 6 cin \u0026gt;\u0026gt; n; n++; 7 for (ll i = 1; i \u0026lt;= n; i \u0026lt;\u0026lt;= 1) { 8 ll c = n / i; 9 if (c \u0026amp; 1) ans += c / 2 * i + n % i; 10 else ans += c / 2 * i; 11 } 12 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 return 0; 14}  CSES - 11677 - Network Breakdown 題目是問給一張圖，每次刪除一條邊後，回答所剩的聯通塊數目。\n用 Union Find Tree 維護聯通塊，離線倒著回答詢問，也就是一條一條加回去。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4#define x first 5#define y second 6vector\u0026lt;pii\u0026gt; remove(vector\u0026lt;pii\u0026gt; e, vector\u0026lt;pii\u0026gt; q) { 7 sort(q.begin(), q.end()); 8 vector\u0026lt;pii\u0026gt; ret; 9 for (pii p : e) { 10 auto iter = lower_bound(q.begin(), q.end(), p); 11 if (iter == q.end() || *iter != p) 12 ret.push_back(p); 13 } 14 return ret; 15} 16struct UF { 17 int cnt; 18 vector\u0026lt;int\u0026gt; p, r; 19 UF(int n): cnt(n) { 20 p.resize(n + 1), r.resize(n + 1); 21 for (int i = 1; i \u0026lt;= n; i++) p[i] = i; 22 } 23 int par(int x) { 24 return p[x] = ((p[x] == x) ? x : par(p[x])); 25 } 26 void uni(int a, int b) { 27 a = par(a), b = par(b); 28 if (a == b) return; 29 if (r[a] \u0026lt; r[b]) {int t = a; a = b; b = t;} 30 p[b] = a, r[a] += (r[a] == r[b]), cnt--; 31 } 32}; 33int main() { 34 ios::sync_with_stdio(0); cin.tie(0); 35 int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; 36 UF T(n); 37 vector\u0026lt;pii\u0026gt; e(m), q(k); 38 for (int i = 0; i \u0026lt; m; i++) { 39 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 40 e[i] = pii(min(a, b), max(a, b)); 41 } 42 for (int i = 0; i \u0026lt; k; i++) { 43 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 44 q[i] = pii(min(a, b), max(a ,b)); 45 } 46 e = remove(e, q); 47 for (pii p : e) 48 T.uni(p.x, p.y); 49 vector\u0026lt;int\u0026gt; ans; 50 reverse(q.begin(), q.end()); 51 for (pii p : q) { 52 ans.push_back(T.cnt); 53 T.uni(p.x, p.y); 54 } 55 for(int i = k - 1; i \u0026gt;= 0 ; i--) 56 cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 57 return 0; 58}  氣泡梅酒 晚上朋友調了一杯梅酒加氣泡水給我喝，我才喝一杯就想睡了。應該是第二次喝酒，感覺很新奇，甜甜的很喜歡。上次喝酒是和振華學長跨年。\n","date":"2020-12-18T11:45:29+08:00","permalink":"https://Luke2336.github.io/p/20201218/","title":"2020/12/18 日記"},{"content":"晚餐吃了烤雞。\n資工系停修事件 學校某些重要的條文或會議記錄沒有被公開清楚，（畢竟學生會的貼文本身不具任何效益），產生各種模糊地帶，再加上行政人員不見得全在狀況內。\n自己期中退選時，被課務組拿他們的價值觀來跟我說教，也覺得超不合理的。\n因為分數不好看而停修確實不合理，但大學部的學分費是吃到飽，所以大家很容易選超過可負擔的量。\n電路學 CH13 Self Inductance $$L = N \\frac{d \\phi}{di}$$\nMutual Inductance $$M = M_{12} = M_{21}$$\n$$v_2 = N_2 \\frac{d \\phi_{12}}{dt} = M_{21}\\frac{di_1}{dt}, \\ M_{21} = N_2 \\frac{d \\phi_{12}}{di_1}$$\nCoupled Circuit $$v_1 = L_1 \\frac{di_1}{dt} + M \\frac{di_2}{dt}$$\n$$\\mathbb{V}_1 = j \\omega L_1 \\mathbb{I}_1 + j \\omega M \\mathbb{I}_2$$\nEnergy $$w = \\frac{1}{2} L_1 I_1^2 + \\frac{1}{2} L_2 I_2^2 \\pm M I_1 I_2$$\nCoupling Coefficient $$k = \\frac{M}{\\sqrt{L_1 L_2}} = \\frac{\\phi_{12}}{\\phi_{11} + \\phi_{12}} = \\frac{\\phi_{21}}{\\phi_{21} + \\phi_{22}} \\in [0, 1]$$\nPerfect Coupling $$k = 1 \\iff \\phi_{11} = \\phi_{22} = 0$$\nLinear Transformers $$\\begin{aligned} \\mathbb{Z}_{in} \u0026amp;= \\mathbb{Z}_P + \\mathbb{Z}_R \\\\ \u0026amp;= (R_1 + j \\omega L_1) + \\frac{\\omega^2 M^2}{R_2 + j \\omega L_2 + \\mathbb{Z}_L}\\\\ \\mathbb{Z}_P \u0026amp;:\\text{primary impedance}\\\\ \\mathbb{Z}_R \u0026amp;:\\text{reflected impedance} \\end{aligned}$$\nIdeal Transformers  $$\\begin{cases} L_1, L_2, M \\to \\infty\\\\ k = 1 \\iff M = \\sqrt{L_1 L_2} \\\\ R_1 = R_2 = 0 \\end{cases}$$ $$\\mathbb{V}_2 = \\sqrt{\\frac{L_2}{L_1}} \\mathbb{V}_1 = n \\mathbb{V}_1$$ Turn Ratio $$n = \\frac{\\mathbb{V}_2}{\\mathbb{V}_1} = \\frac{\\mathbb{I}_1}{\\mathbb{I}_2} = \\frac{N_2}{N_1} = \\sqrt{\\frac{\\mathbb{Z}_L}{\\mathbb{Z}_{in}}}$$ Make Ideal !! $$\\omega L_2 \\gg |\\mathbb{Z}_L|$$  ","date":"2020-12-17T10:16:18+08:00","permalink":"https://Luke2336.github.io/p/20201217/","title":"2020/12/17 日記"},{"content":"早上上完德文課，又翹了 OS，吃完了蛋糕，讀了電路學，然後上了羽球課，洗個澡就去練習了。中午參考這篇文章，把 Google Analytics 加到 Blog。\n羽球課 下週要考期末考，但練了一下腳步，覺得很不熟練，甚至還是不會後場的換腳，前場左邊比較跑不到點，然後回中時換另一個方向略略不順。\n之後分組打單打比賽，打了 3 場 7 分，輸了一場，其他幾場都以不錯的比數取勝，普遍看到大家發球不夠高或遠，很容易就變成平球戰。我則是後場接球能力不好，沒辦法很快跑位打回到後場。結束後和學姊單挑了一場 21 分，後面體力不支，就沒有贏了。\nCPTC 001    Problem Coder Topic     A Hyperbola Binary Search   B Kelly Greedy, Sort   C Hyperbola Enumerate, Prefix Sum   D Hyperbola 互動題, DP   E Kelly 數位 DP    今天難得全都 1AC。讀完題後也有迅速抓出水題，兩題都在正常速度開完。pD 被曲線通靈出來，他邊寫我邊聽 LinLee 講題目。我決定把 pE 拿去做，pC 則留給他們想。pE 算是定義好狀態就很好寫的題目，之前常在 AtCoder 看到類似的題目。\npB 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4int main() { 5 int n, m; 6 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n ,\u0026amp;m); 7 vector\u0026lt;int\u0026gt; deg(n); 8 for (int i = 0; i \u0026lt; m; i++) { 9 int a, b; 10 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); 11 deg[a-1]++, deg[b-1]++; 12 } 13 vector\u0026lt;int\u0026gt; h(n); 14 for (int i = 0; i \u0026lt; n; i++) 15 scanf(\u0026#34;%d\u0026#34;, \u0026amp;h[i]); 16 sort(h.begin(), h.end()); 17 sort(deg.begin(), deg.end()); 18 ll ans = 0; 19 for (int i = 0; i \u0026lt; n; i++) 20 ans += ll(h[i]) * ll(deg[n - i - 1]); 21 printf(\u0026#34;%lld\\n\u0026#34;, ans); 22 return 0; 23}  pE  一開始會想用 cal(R) - cal(L - 1)，但後來想到 L 會是 0，且減一其實有點小麻煩，所以就用 cal(R) - cal(L - 1)，如果 L 是 rainbow number 就再把答案加一。 另外也有把前綴是 0 的 case 獨立算出來，讓狀態定義的比官解簡潔。  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 105 4typedef long long ll; 5const ll mod = 1000000007; 6inline int d (char c) {return c - \u0026#39;0\u0026#39;;} 7int check(string s) { 8 for (int i = 1; s[i]; i++) 9 if (s[i - 1] == s[i]) return 0; 10 return 1; 11} 12ll cal(string s) { 13 int len = s.length(); 14 ll ans = 0, tmp = 1; 15 for (int i = 1; i \u0026lt; len; i++) { //長度小於 len 的數量 16 tmp = tmp * 9 % mod; 17 ans = (ans + tmp) % mod; 18 } 19 s = \u0026#39;0\u0026#39; + s; 20 ll dp[maxn][10][2] = {}; 21 dp[0][0][1] = 1; 22 for (int i = 1; i \u0026lt;= len; i++) { //長度等於 len 的數量 23 if (s[i] != s[i - 1]) // dp[i][j][1] 代表前 i 位和 s 一樣 24 dp[i][d(s[i])][1] = dp[i - 1][d(s[i - 1])][1]; 25 for (int j = 0; j \u0026lt;= 9; j++) { 26 for (int k = 0; k \u0026lt;= 9; k++) 27 if (k != j) dp[i][j][0] += dp[i - 1][k][0]; 28 if (d(s[i - 1]) != j \u0026amp;\u0026amp; d(s[i]) \u0026gt; j) 29 dp[i][j][0] += dp[i - 1][d(s[i - 1])][1]; 30 d[i][j][0] %= mod; 31 } 32 } 33 for (int i = 0; i \u0026lt;= 9; i++) 34 ans = (ans + dp[len][i][0] + dp[len][i][1]) % mod; 35 return ans; 36} 37int main () { 38 int T; cin \u0026gt;\u0026gt; T; 39 while (T--) { 40 string L, R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; 41 cout \u0026lt;\u0026lt; (cal(R) - cal(L) + check(L) + mod) % mod \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 42 } 43 return 0; 44}  電路學 因為不太能理解這兩個式子是怎麼推導的，所以就 Line 了老師。得到的結論是，可以透過改變兩個電流的大小，把有平方的那一項變 0，之後我們就可以推出第二個式子。\n","date":"2020-12-16T10:20:38+08:00","permalink":"https://Luke2336.github.io/p/20201216/","title":"2020/12/16 日記"},{"content":"早上寫了投 Google 2021 Summer Intern, SWE 的履歷，然後去上電路學，期中補考勉勉強強有了 60 分，中午去科一印成績單和在學證明，因為中正堂施工不開放，但也去了郵局辦事。\n下午去找了 TTYeh 老師，聊了一下近況，以及助教的工作。下午寫了交換申請資料中的研修計畫，寫了兩頁半，感覺應該差不多了，主要都在花時間看課程表。\n晚餐吃了自助餐，配了卡通「新神偷卡門」，然後去工五看了電路學考卷，和蘇于討論了期末專題。然後收了包裹，整理了衣櫃，收到了兩隻折傘。\n整理衣服時，發現衣櫃後面藏進了一隻蟑螂，之後我就覺得好焦慮。\n交換申請資料 \u0026mdash; 研修計畫＆簡歷表 ","date":"2020-12-15T08:17:24+08:00","permalink":"https://Luke2336.github.io/p/20201215/","title":"2020/12/15 日記"},{"content":"早上搭車回新竹，雨很大，上車後到台北就沒雨了。從馬偕下車，然後搭小紅巴回學校。之後剪了香蜂草的枯枝病葉，還除了蟲，然後洗了衣服，吃了昨晚買的巧克力拿破崙配伯爵茶。\npJ. Inverse Factorial  給定一個長度不超過 1e6 的字串，代表 n!，求 n 是多少？ 答案的範圍不超過 1e6，所以可以直接 mod 一個夠大的質數  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define mod 1000000007 4typedef long long ll; 5int main () { 6 ios_base::sync_with_stdio(0); cin.tie(0); 7 string s; cin \u0026gt;\u0026gt; s; 8 ll sum = 0; 9 for (int i = 0; s[i]; i++) 10 sum = (sum * 10 + s[i] - \u0026#39;0\u0026#39;) % mod; 11 for (ll i = 1, frac = 1; ; i++) { 12 frac = (frac * i) % mod; 13 if (frac == sum) { 14 cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; 15 } 16 } 17 return 0; 18}  CSES - 1202 - Investigation  最短路徑水題 Dijkstra  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3const int mod = 1000000007; 4typedef long long ll; 5typedef pair\u0026lt;ll, int\u0026gt; pii; 6#define pb push_back 7int main () { 8 ios_base::sync_with_stdio(0); cin.tie(0); 9 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 10 vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n + 1); 11 for (int i = 0; i \u0026lt; m; i++) { 12 int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; 13 G[a].pb(pii(c, b)); 14 } 15 vector\u0026lt;bool\u0026gt; visit(n + 1); 16 vector\u0026lt;ll\u0026gt; dis(n + 1, ll(m) * ll(1e9)); 17 vector\u0026lt;ll\u0026gt; cnt(n + 1, 0), mn(n + 1), mx(n + 1); 18 dis[1] = 0, cnt[1] = 1; 19 priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, greater\u0026lt;pii\u0026gt;\u0026gt; pq; 20 pq.push(pii(0, 1)); 21 while (!pq.empty()) { 22 int u = pq.top().second; pq.pop(); 23 if (visit[u]) continue; 24 visit[u] = true; 25 for (pii e : G[u]) { 26 int uu = e.second; ll w = e.first; 27 if (dis[uu] == dis[u] + w) { 28 cnt[uu] = (cnt[u] + cnt[uu]) % mod; 29 mn[uu] = min(mn[uu], mn[u] + 1); 30 mx[uu] = max(mx[uu], mx[u] + 1); 31 } else if (dis[uu] \u0026gt; dis[u] + w) { 32 dis[uu] = dis[u] + w; 33 cnt[uu] = cnt[u] % mod; 34 mn[uu] = mn[u] + 1; 35 mx[uu] = mx[u] + 1; 36 pq.push(pii(dis[uu], uu)); 37 } 38 } 39 } 40 cout \u0026lt;\u0026lt; dis[n] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; cnt[n] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; mn[n] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; mx[n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 41 return 0; 42}  認識語言 今天老師突然取消了之後所有考試，直接計算分數。除了 20% 的期末報告外，我拿了 72 分，看起來有機會拿 A+。\n今天的主題是手語，還有猩猩無法學會人類語言。\n","date":"2020-12-14T11:29:37+08:00","permalink":"https://Luke2336.github.io/p/20201214/","title":"2020/12/14 日記"},{"content":"回到家之後很好睡，睡了 12 小時。早上寫完電路學作業，難得的好天氣，下午就被帶去海邊看貓，晚上去礁溪吃甕仔雞和泡溫泉，在那邊遇到奇怪的蘭陽溫泉嘉年華遊行。\n 喜歡被摸屁屁的白貓\n很愛蹭的小黑白，想抱回家。\n以前在石頭屋遇到的小貓已經變媽媽了，生了三隻小花貓，一隻健康有問題被獸醫院收養。\n","date":"2020-12-14T11:16:40+08:00","permalink":"https://Luke2336.github.io/p/20201213/","title":"2020/12/13 日記"},{"content":"一大早就搭別人的車，很早就到北一了，發現憲兵的制服很像警察\u0026hellip;\u0026hellip;\n先去資訊組和芳蘭老師聊天，遇到了湘鈴學姊。\n之後去找怡芬老師，但她還在忙，於是我就先去找貽婷老師了，但只遇到進松，聊了一陣子，還拍了一張照。\n去國文科看展，遇到班導，覺得學妹作品很美，作文比賽的得獎作品，文字青澀，沈重而帶有著青春的憂愁。然後也看了資訊科的展，但覺得學妹的作品不吸引人。\n跟郁芬她們會合後，買了學妹的冰淇淋泡芙，然後去了學珠四樓，還有逛了歷史科的展。\n之後我就跑去找荔枝聊天了。四點多才又見到怡芬老師，還遇到薯餅。但只是匆匆忙忙的聊了幾句，她邀請我寒假再過去她家玩，有空也可以在她下班後找她吃飯。\n  人生的密碼：謙虛、感恩\nby 芳蘭老師\n ","date":"2020-12-14T11:16:34+08:00","permalink":"https://Luke2336.github.io/p/20201212/","title":"2020/12/12 日記"},{"content":"和學長吃飯 吃了清夜的義大利麵，然後去蒙民偉樓四樓吃甜點喝茶，聊了很多最主要是關於感情。\n電路學補考 因為星期六想回去北一參加校慶，所以就問助教能不能提早補考。覺得寫得很順，但這兩週其實並未複習，可見第一次考試太焦慮了而已。\n宵夜 吃了熱熱的紅豆湯，覺得很幸福。\n","date":"2020-12-11T21:12:09+08:00","permalink":"https://Luke2336.github.io/p/20201211/","title":"2020/12/11 日記"},{"content":"早上先去還書，之後去處理報帳，把剩下的人的電話交給助理，之後買了麥當勞吃。接下來開始動工交換要繳交的備審資料，今天下午完成了自傳中想放的簡歷表，刪刪減減後，用不到三十行就把高中大學比較重點的成績呈現出來，比當初申請大學時的簡潔。\n之後去上電路學，今天是教電路間的磁場交互作用，提到了一些竊取晶片信用卡密碼的觀念。下課時，跟老師提了想明晚提早補考，以在週六回去參加期待多年的北一大校慶。\n下課後去圖書館領預約了三個月的電路學課本，剛開學時就推薦採購，幸好在學期末前拿到手了，以後寫電路學功課就方便了。順便借了一本中文的作業系統，希望能把之前的觀念補起來。\n晚上去買了自助餐吃，但好像肉夾太多了，被多收五塊錢。然後看了兩集「雲畫的月光」，算是搞笑劇，應該會當作配飯的韓劇。然後讀了一下電路學。\n電路學 CH11     Units      Complex Power VA $$\\mathbb{S} = P + jQ = \\frac{1}{2} \\mathbb{VI}^* = V _{rms} I _{rms} \\angle (\\theta_v - \\theta_i)$$   Apparent Power VA $$S = \\vert\\mathbb{S}\\vert = V _{rms} I _{rms}$$   Real Power Watt $$P$$   Reactive Power VAR $$Q$$   Power Factor  $$pf = \\frac{P}{S} = \\cos(\\theta_v - \\theta_i)$$     $$\\mathbb{Z} = R + jX = |\\mathbb{Z}|\\angle \\theta,\\ \\theta_v - \\theta_i = \\theta \\in [-90\\degree, 90\\degree]$$\n   Load X     Resistive Load $$X = 0$$   Inductive Load $$X \u0026gt; 0$$   Capacitive Load $$X \u0026lt; 0$$     Power Factor Correction (Parallel) $$C = \\frac{P_1 (\\tan {\\theta _2} - \\tan {\\theta _2})}{\\omega V _{rms} ^2}$$ $$L = \\frac{\\omega P_1 (\\tan {\\theta _2} - \\tan {\\theta _2})}{V _{rms} ^2}$$\n","date":"2020-12-10T20:09:00+08:00","permalink":"https://Luke2336.github.io/p/20201210/","title":"2020/12/10 日記"},{"content":"早上心情很不好，所以上完德文後，又把 OS 睡掉了。中午買了個牛腩丼飯，然後去上了羽球課。和卡車吃了蛋捲冰淇淋，剛好店員不小心裝太大隻，所以吃得很滿足。洗完澡後就去練習，有點遲到。點了牛肉燴飯，但料很少，讓我很失望。\n羽球課 今天是教後場步伐和揮拍，然後讓我們練習兩週後要考的米字步。首先是側身架拍，然後右腳蹲，然後單腳跳腰轉隱拍，之後在揮拍，左腳往前恢復準備姿勢。羽球鞋穿的還不太習慣，畢竟跟慢跑鞋比很有重量，希望能早點習慣。\nPCCA  Kattis 題單  今天是拆成 30 分鐘為單位，交換隊友練習，今天有觀察到的有 LandyLu、CTFang 那對，還有 LinLee 找的吳柏橙，只有 CTFang 我比較喜歡。最近對隊友們的感情也有點冷淡，慢慢觀察到不少他們的缺點，而 CTFang 卻比較像 Ud 一樣沈穩，雖然他的隊友卻沒什麼表現，但我還是傾向於換隊友。\nD. Kattis - ivana  賽局 DP 把環狀的東西，直接複製兩份去建表。 Complexity: $$O(n^2)$$  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define INF 10000 4int main() { 5 ios_base::sync_with_stdio(0); cin.tie(0); 6 int n; cin \u0026gt;\u0026gt; n; 7 int a[205], dp[205][205]; 8 for (int i = 0; i \u0026lt; n; i++) { 9 cin \u0026gt;\u0026gt; a[i]; a[n + i] = a[i]; 10 } 11 for (int i = 0; i \u0026lt; 2 * n; i++) 12 dp[i][i] = a[i] % 2; 13 for (int l = 1; l \u0026lt; n; l++) 14 for (int i = 0, j = l; j \u0026lt; 2 * n; i++, j++) { 15 dp[i][j] = (l % 2) ? INF : -INF; 16 if (l % 2) dp[i][j] = min(dp[i][j], 17 min(dp[i + 1][j] - a[i] % 2, 18 dp[i][j - 1] - a[j] % 2)); 19 else dp[i][j] = max(dp[i][j], 20 max(dp[i + 1][j] + a[i] % 2, 21 dp[i][j - 1] + a[j] % 2)); 22 } 23 int ans = 0; 24 for (int i = 0; i \u0026lt; n; i++) { 25 if (n % 2 == 0) { 26 if (-a[i] % 2 + dp[i + 1][i + n - 1] \u0026lt; 0) ans++; 27 } else { 28 if (a[i] % 2 + dp[i + 1][i + n - 1] \u0026gt; 0) ans++; 29 } 30 } 31 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 32 return 0; 33}  ","date":"2020-12-09T12:34:03+08:00","permalink":"https://Luke2336.github.io/p/20201209/","title":"2020/12/09 日記"},{"content":"起床時就覺得很冷很不舒服，心情很悶，就又睡了一下，然後去上電路學。在宿舍時，跌下了樓梯，幸好只滑了五階左右，沒有受傷，只有腰有點痠，腳踝和膝蓋略略不適。上課時因為想吐的感覺，有點坐立不安，回宿舍後一直睡到快三點。起床後又躺到快四點，什麼東西都沒吃。\n電路學今天比較早教完，老師就用十分鐘聊了一下他對台大前一陣子很多學生自殺的想法，他認為，自殺是愚蠢的，讀書讀不好，可能就只是選錯科系，就像交男女朋友一樣，很難第一次就找到對的人，轉換跑道就好了。我認為他這段話或許是正確的，但自殺不應該被想成這麼簡單的行為。\n傍晚看了中醫，因為反胃，所以一整天都沒吃飯，所以有些暈眩，眼前一片黑，針灸後噁心感消失了。之後去建中路吃了原味燉品屋，點了人參雞，覺得人參滿多的。躺了一下，然後去上電路學的演習課，今天 TA 只有講幾個大概念，所以 20:15 左右就下課了。\n半夜收到 email 通知說電路學要補考，覺得很難過，因為自己覺得重點的觀念都已經學會了，卻還是考得不好。滿挫折的，因為這是自己最近花比較多心力的科目，覺得能做好，卻還是沒有。\n","date":"2020-12-08T16:03:04+08:00","permalink":"https://Luke2336.github.io/p/20201208/","title":"2020/12/08 日記"},{"content":"起床後洗了澡，然後就買了個丼飯吃，邊看「夜叉姬 E8」。之後去上認識語言，今天主要是在講雙語嬰兒的認知能力，然後也講了 Executive Function (EF) 的概念，我認為用它去描述一個人是否聰明是合理的。老師也談了應該在 6 歲前，給予小孩足夠的陪伴，在前額葉發展的黃金期，陪他一起讀外語繪本。下課後，在宿舍泡了杯紅茶，然後讀電路學 Ch11 的投影片。之後寫了兩題電路學，花了 45 分鐘。\n電路學 CH11   Instantaneous Power $$\\displaystyle\\begin{aligned} i(t) \u0026amp;= I_m \\cos (\\omega t + \\theta_i)\\\\ v(t) \u0026amp;= V_m \\cos (\\omega t + \\theta_v)\\\\ p(t) \u0026amp;= \\frac{1}{2} I_m V_m (\\cos(\\theta_v - \\theta_i) + \\cos(2\\omega t + \\theta_v + \\theta_i)) \\end{aligned}$$\n  Average Power $$\\displaystyle\\begin{aligned} P \u0026amp;= \\frac{1}{T} \\int_0^T p(t) dt \\\\ \u0026amp;= \\frac{1}{2} I_m V_m \\cos(\\theta_v - \\theta_i) \\\\ \u0026amp;= \\frac{1}{2} Re[\\mathbb{VI}^*] \\end{aligned}$$\n  Maximum Average Power Transform $$\\displaystyle\\begin{aligned} \\mathbb{Z}_{Th} \u0026amp;= R_{th} + j X_{Th},\\mathbb{Z}_{L} = R_{L} + j X_{L} \\\\ \\mathbb{I} \u0026amp;= \\frac{ \\mathbb{V}_{Th} }{\\mathbb{Z}_{Th} + \\mathbb{Z}_{L}} = \\frac{ \\mathbb{V}_{Th} }{(R_{th} + R_L) + j (X_{Th} + X_L)} \\\\ P \u0026amp;= \\frac{1}{2} Re[\\mathbb{VI} ^ *] = \\frac{1}{2} Re[\\mathbb{Z}_{L} \\mathbb{II} ^ *] = \\frac{1}{2} |\\mathbb{I}| ^ 2 {R}_{L} \\\\ \u0026amp;= \\frac{ | \\mathbb{V}_{Th} | ^ 2 {R}_{L} }{({R}_{th} + {R}_{L}) ^ 2 + ({X}_{Th} + {X}_{L}) ^ 2} \\\\ \\frac{\\partial P}{\\partial X _L} \u0026amp;= 0 \\implies X _ L = - X _ {Th} \\\\ \\frac{\\partial P}{\\partial R _L} \u0026amp;= 0 \\implies R _ L = R _ {Th} \\\\ \\implies \\mathbb{Z}_{L} \u0026amp;= \\mathbb{Z}_{Th} ^ * \\implies P_{max} = \\frac{|\\mathbb{V}_{Th}|^2}{8} \\end{aligned}$$\n  Effective Value / RMS Value\n  $$\\begin{aligned} P_R \u0026amp;= \\frac{1}{T} \\int_0^T i^2 R dt = I_{eff}^2 R \\\\ I_{eff} \u0026amp;= \\sqrt{\\frac{1}{T} \\int_0^T i^2 dt} = I_{rms} \\\\ I_{rms} \u0026amp;= \\sqrt{\\frac{1}{T} \\int_0^T I_m^2 \\cos^2 (\\omega t + \\theta_i)dt} \\\\ \u0026amp;= \\sqrt{\\frac{1}{T} \\int_0^T I_m^2 (1 + \\cos (2\\omega t + 2\\theta_i))dt} \\\\ \u0026amp;= \\frac{I_m}{\\sqrt 2} \\\\ P \u0026amp;= I_{rms}^2 R = \\frac{V_{rms}^2}{R} \\end{aligned}$$\n","date":"2020-12-07T12:30:04+08:00","permalink":"https://Luke2336.github.io/p/20201207/","title":"2020/12/07 日記"},{"content":"因為吃了過敏藥，睡到下午一點才起來，買了麥當勞吃，接下來的時間都在整理衣櫃。晚上吃了蛋包飯，然後去打球。打球前和 Hsu 聊過他女友的事，和他散步到清大操場，打完球在 7-11 遇到明憲學長，他送我走回宿舍。今天第一次穿新球鞋打球，略略有點重量。今天打球算是普通普通，沒有特別的感覺，總共只運動了一小時。回房間後收拾完衣櫃，然後喝了杯牛奶，把「大長今」看完。\n今年刷了很多小時候看的卡通和韓劇。\n 犬夜叉 結界師 同伊 善德女王 擁抱太陽的月亮 大長今  ","date":"2020-12-06T21:34:29+08:00","permalink":"https://Luke2336.github.io/p/20201206/","title":"2020/12/06 日記"},{"content":"CSES - 1197 - Cycle Finding  卡車說可以從一個假點開始做 SSSP，也就是將所有點的距離都先設成 0。 我的寫法複雜度看起來不好，感覺假解了，但想不到該怎麼改，可能會 TLE。 想了一個確定複雜度是 O(VE) 的解，將整張圖做 SCC，形成一個 DAG，從每個 in-degree 為 0 的 SCC 選一個點做 DFS。  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, ll\u0026gt; pii; 5#define pb push_back 6vector\u0026lt;int\u0026gt; ans; 7vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G; 8vector\u0026lt;bool\u0026gt; visit; 9vector\u0026lt;bool\u0026gt; use; 10vector\u0026lt;ll\u0026gt; dis; 11int dfs(int v) { 12 use[v] = visit[v] = true, ans.pb(v); 13 for (pii e : G[v]) { 14 int u = e.first; 15 ll w = e.second; 16 if (dis[u] \u0026lt;= dis[v] + w) continue; 17 dis[u] = dis[v] + w; 18 if (visit[u]) return u; 19 int ret = dfs(u); 20 if (ret) return ret; 21 } 22 visit[v] = false, ans.pop_back(); 23 return 0; 24} 25int solve(int n) { 26 for (int i = 1, ret; i \u0026lt; n; i++) 27 if (!use[i] \u0026amp;\u0026amp; (ret = dfs(i))) return ret; 28 return 0; 29} 30bool SPFA (int n) { 31 queue\u0026lt;int\u0026gt; q; 32 vector\u0026lt;int\u0026gt; cnt(n); 33 vector\u0026lt;bool\u0026gt; inque(n); 34 for (int i = 1; i \u0026lt; n; i++) { 35 if (cnt[i]) continue; 36 inque[i] = 1, q.push(i); 37 while (!q.empty()) { 38 int u = q.front(); q.pop(); 39 inque[u] = false; 40 for (pii p : G[u]) { 41 int uu = p.first; ll w = p.second; 42 if (dis[uu] \u0026gt; dis[u] + w) { 43 dis[uu] = dis[u] + w, cnt[uu]++; 44 if (cnt[uu] \u0026gt; n) return false; 45 if (!inque[uu]) inque[uu] = true, q.push(uu); 46 } 47 } 48 } 49 } return true; 50} 51int main() { 52 ios_base::sync_with_stdio(0); cin.tie(0); 53 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; n++; 54 G.resize(n), visit.resize(n), dis.resize(n), use.resize(n); 55 for (int i = 0; i \u0026lt; m; i++) { 56 int a, b; ll c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; 57 if (a == b \u0026amp;\u0026amp; c \u0026lt; 0) // loop 58 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 59 G[a].pb(pii(b, c)); 60 } 61 if (SPFA(n)) { cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; return 0;} 62 int v = solve(n), flag = 0; 63 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; 64 for (int x : ans) { 65 if (x == v) flag = 1; 66 if (flag) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 67 } 68 cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 69 return 0; 70}  ","date":"2020-12-05T22:36:18+08:00","permalink":"https://Luke2336.github.io/p/negative_cycle/","title":"有向圖找負環 (Negative-Cycle)"},{"content":"今天較嗜睡，睡了快九個小時。起床後買了麥當勞吃，然後做了家教的投影片 - 最近點對。之後練了打字，也開始練了德文輸入法。\n之後讀了認識語言的閱讀作業 \u0026ldquo;Flexible Learning of Multiple Speech Structures in Bilingual Infants\u0026rdquo;，一篇關於單語和雙語環境小孩的語言學習能力，發現雙語環境的小孩對不同結構的詞區別能力較好，這篇同樣用 Eye-tracking 實驗。\n研究了一下選課和交換相關的東西後，就去買自助餐吃，也泡了一杯熱可可。然後上了家教，今天選 Trie 和 Closest Pair 教，下課後她問了我關於 LCS 的東西。晚上 AC 了找負環的題目。\n","date":"2020-12-05T21:34:29+08:00","permalink":"https://Luke2336.github.io/p/20201205/","title":"2020/12/05 日記"},{"content":"餐聚 和振華學長一起吃風雲四樓，點了紅酒燉牛肉飯，之後去水木二樓的咖啡店。聊了很多事，關於他的新女友，關於我和卦長之間的事，也聊了對於競賽的想法，還有聊一些對於之後幾年的規劃。\n他滿認同我選擇轉系，大四下出去交換的選擇。他鼓勵我研究所留在清大念，但我猜有一部分的因素是考慮到感情。\n羽球鞋 晚上去光復路靠近公園一帶找羽球鞋，在 SOSA 逛的時候，有看到兩雙還算能接受的外觀，但價位在 2500 - 3200。然後去對面的宏展，有多了一些羽排鞋的選項，有看上一雙 $1450 藍白色的 ASICS，一開始我是找 26.5 cm，但只有 26 cm，最後用三倍券買了。剛好顏色會和球衣很搭，然後也相對比較中性。\n","date":"2020-12-04T22:52:12+08:00","permalink":"https://Luke2336.github.io/p/20201204/","title":"2020/12/04 日記"},{"content":"CF-GYM100274 pA  問題：2 \u0026lt;= n \u0026lt;= 1e18，2 \u0026lt;= k \u0026lt;= 1e12，求 n! 是 k 的幾次方。 作法：將 k 做質因數分解，然後各自算出次方數後，再取最小值。 時間：$$O(\\log n \\sqrt k)$$  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;ll, int\u0026gt; pli; 5vector\u0026lt;pli\u0026gt; prime_factor (ll k) { 6 vector\u0026lt;pli\u0026gt; ret; 7 for (ll i = 2; i * i \u0026lt;= k; i++) { 8 if (k % i) continue; 9 pli p = pli(i, 0); 10 while (k % i == 0) k /= i, p.second++; 11 ret.push_back(p); 12 } 13 if (k \u0026gt; 1) ret.push_back(pli(k ,1)); 14 return ret; 15} 16int main() { 17 ios_base::sync_with_stdio(0); cin.tie(0); 18 int T; cin \u0026gt;\u0026gt; T; 19 while (T--) { 20 ll n, k, ans = -1; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; 21 vector\u0026lt;pli\u0026gt; fac = prime_factor(k); 22 for (pli p : fac) { 23 ll cnt = 0, m = n; 24 while (m) cnt += (m = m / p.first); 25 cnt /= p.second; 26 if (ans == -1 || cnt \u0026lt; ans) ans = cnt; 27 } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 } return 0; 29}  pB  問題：給定兩個相同長度的字串，問能不能各自找到長度至少一半的子字串，使得字元和字元兩兩的絕對值差不超過 1。例如 \u0026ldquo;aabb\u0026rdquo; 和 \u0026ldquo;bbbb\u0026rdquo; 就是符合的。 作法：平移後，對重疊處做最大連續和。 時間：$$O(n^2)$$  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 ios_base::sync_with_stdio(0); cin.tie(0); 5 int T; cin \u0026gt;\u0026gt; T; 6 while (T--) { 7 int n; cin \u0026gt;\u0026gt; n; 8 string a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 9 int ans = 0; 10 for (int i = 0; i \u0026lt; n; i++) { 11 for (int j = 0, sum = 0; j + i \u0026lt; n; j++) 12 if (abs(a[j] - b[j + i]) \u0026lt;= 1) 13 ans = max(ans, ++sum); 14 else sum = 0; 15 for (int j = 0, sum = 0; j + i \u0026lt; n; j++) 16 if (abs(a[j + i] - b[j]) \u0026lt;= 1) 17 ans = max(ans, ++sum); 18 else sum = 0; 19 } 20 if (ans * 2 \u0026gt;= n) cout \u0026lt;\u0026lt; \u0026#34;POSITIVE\\n\u0026#34;; 21 else cout \u0026lt;\u0026lt; \u0026#34;NEGATIVE\\n\u0026#34;; 22 } 23 return 0; 24}  pC  Topological Sort  pD  暴力枚舉＋剪枝  pE  DP  pF  水題  pG  幾何實作  pH  DP  pI  Flow  pJ  找樹的半徑。  pK  Coloring on Plannar Graph  pL  DP  ","date":"2020-12-03T23:56:03+08:00","permalink":"https://Luke2336.github.io/p/cf_gym_100274/","title":"CF GYM 100274"},{"content":"研究大三下課表 昨晚 Hyperbola 告訴我課表已經出來了，於是早上就先研究了一下。系統看起來跟陽明有一些整合，所以時間表示的方式變得比較像清大。\n學分數 預計體育以外總共 6 ~ 7 門課，或許可以把星期一空出來。也想留點時間做研究和打 ICPC。\n   Type Unit     主科 9 - 12   外文 2 - 4   通識 2   Total 15 - 18    時間表     M T W R F     1        2  密碼學      3  正規語言      4  正規語言      n        5  難解問題 羽球  密碼學   6  難解問題 羽球  密碼學   7  難解問題  正規語言    8         資工課程 還在考慮要幾門主科，預計下限三門，上限四門，要看要帶多少學分上去研究所。\n   Course Time Unit     正規語言概論 T34R7 3   密碼學概論 T2F56 3   難解計算問題專論 T567 3   計算方法之實務應用 Mn56 3   自然語言處理（網路課程） F234 3    外文 預計一門大一英文，再加上一門進階英文或二外。 但還是會想考英檢抵掉額外的四學分，畢竟不算在畢業學分，但多修點英文課也沒什麼不好，只是要擔心延畢？\n   Course Time Unit     大一英文（二） M78, W34, R34, R56 2   德文（二） W34 2   日文(一) M12, W12, W34, R34 2   進階英文寫作 F34, M34 2    通識 應該就是選一門核心通識。歷史課幾乎都撞堂，所以可能會先選一門社會向度，四上再選一門歷史課，目前考慮時間應該會優先選 W34 的心理學 和 R34 的教育學。\n   Course Time Unit 向度     哲學概論 F34 2 人文   心理學概論 M56, W34, F34 2 社會   教育學概論 R34 2 社會   文學經典：台灣文學 M789 3 人文   音樂概論 F56 2 人文   文化人類學概論 F56 2 人文   邏輯與思維 F56 2 人文    大四上規劃 如果四下交換時的學分能算在選修裡，那多出來的學分就可以帶到研究所。\n 專題 2 學分 通識 2 學分 主科 6 學分（研究所課） 外文？  報帳 處理得差不多了，還剩五份有問題，就打算拖到一週後再處理。\n電路學  上課前坐在工五一樓打程式，遇到助教，聽起來我第二次期中應該是剛好及格。 下課時老師講了期末專題的事，12/17 要把 Topic 交出來，覺得有點難，雖然只要是跟電路相關的主題都行，但不確定哪個題目較容易做出東西。本來想研究「Dual Circuit in non-plannar graph」，但似乎已經被研究的差不多了。可能得花點時間去想新的題目，一邊閱讀一些文獻，看有沒有辦法做的更仔細，或是有新的作法。  隊練 因為學弟昨天就被劇透了，所以就沒補昨天的題目了。\n宵夜 練完題後，卡車約我們檢討，並去和味吃宵夜，我點了清粥，他們都點滷肉飯。在那邊的停車場遇到三隻有人餵的貓咪。\n","date":"2020-12-03T12:08:51+08:00","permalink":"https://Luke2336.github.io/p/20201203/","title":"2020/12/03 日記"},{"content":"OS HW1 (Python) 中午研究了一下 OS 的作業一，因為對 Python 還不熟，所以先研究了一些模組和函式的用法。之後再慢慢研究 Multithread、Multiprocessing 和 Coroutine。因為期中考表現的很糟，希望能在作業拚一下，把總成績拉到 A。\nRequests: Website Title  $ pip3 install requests $ pip3 install beautifulsoup4  1import requests 2from bs4 import BeautifulSoup 3url = input() 4r = requests.get(url) 5while r.status_code != requests.codes.ok : # 200 6\tr = requests.get(url) 7soup = BeautifulSoup(r.text, \u0026#39;html.parser\u0026#39;) 8print(soup.find(\u0026#39;title\u0026#39;).text) SHA 記得要先 encode('utf-8')\n1import hashlib # 內建的 2 3def SHA256(s): 4 sha = hashlib.sha256() 5 sha.update(s.encode(\u0026#39;utf-8\u0026#39;)) 6 return sha.hexdigest() #str update() 會拼接之前輸入的字串\n1sha1 = hashlib.sha256() 2sha1.update(b\u0026#39;python\u0026#39;) 3 4sha2 = hashlib.sha156() 5sha2.update(b\u0026#39;py\u0026#39;) 6sha2.update(b\u0026#39;thon\u0026#39;) 7 8sha1.hexdigest() == sha2.hexdigest() #true Coding  CSES - 1197 - Cycle Finding  下午研究了一下輸出負環的寫法。    隊練  Kattis 題單 這次試著隨機挑題，我跟 LinLee 採取 pair rogramming， Hyperbola 單開，看結果差多少。LinLee 打了一個鐘頭後就跟我說他想睡覺，於是後面他就有點廢，但看起來 Hyperbola 的速度明顯有優勢，但基本上兩方都不穩定，應該要試著一次 AC。 pG 發現 LinLee 不會 Union Find Tree 的分析，但其實那題應該要用 BFS。 pE 的複雜度分析花了些時間，最後用 O(EF) 估計。 pG 因為沒開 LongLongInt 或 Double，所以 Overflow。 這次題目整體難度不高，下次會選擇難度更高的題組。 晚餐只吃了雞肉飯，結束後有點冷，所以去吃了人參雞湯。      Kelly, LinLee Hyperbola Diff Type     A 4  1.5    B 27(1) 26 2.8 DP   C 5 3 1.8    D 9(1) 8(1) 2.4    E 62 53(3) 4.2 Flow   F 7 5 2.1    G Give Up 12 4.5 BFS   H (3) 6(2) 3.3    I 10 10(2) 3.4    J 20(1) Give UP 4.4 Math    ","date":"2020-12-02T10:58:23+08:00","permalink":"https://Luke2336.github.io/p/20201202/","title":"2020/12/02 日記"},{"content":"早上是電路學第二次期中考，考得有點糟糕，因為不太會算 Initial Condition。\n下午嘗試補了台北站的 pE，但 WA 了。\n今天是卡車生日。\n12 月是個值得期待，但也很多事要做的月份，有聖誕節、跨年，也有期末考、選課。\n12 月 Todo  交換申請資料 OS  複習期末考 HW1、HW2、HW3   電路學  複習期末考 小考、作業 期末專題   認識語言  期末報告 Paper Reading 小考   德文  複習文法、片語、單字   羽球  米字步   競程  補題：CodeForces、Kattis 刷題：USACO、SPOJ Rank：Codeforces、AtCoder    ","date":"2020-12-01T12:24:22+08:00","permalink":"https://Luke2336.github.io/p/20201201/","title":"2020/12/01 日記"},{"content":"今天精神較好，可能是因為前一晚吃了 B 群，雖然為了報帳早起沒睡飽，但晚上的效率還不錯。下午上完課肚子餓，就先買了麥當勞吃。傍晚洗澡前練了一下揮拍，又跳了繩。晚上原本想吃燒餅蛋，但豆漿店又沒有燒餅了。\nICPC 報帳  因為雙曲線早上要值班，所以就跟他約在系計中，想說要幫他送報帳的報表。但沒想到他收的時候都不檢查，他說是因為他擔心他檢查了，有問題他就要負責。心好累，跟他耗了一小時。我覺得他很不負責任，然後整個過程一直兇我，LinLee 聯絡不到，他也一副不在意。我真的很不開心。 去校計中找謝小姐時，看著東缺西缺的東西，覺得好丟臉，但她還是很有耐心的一份份找 bug。 回去找他時，因為我盯著計中櫃檯的螢幕，又被他兇了。我發現每次他態度愈是堅定時，我對他的話愈是無法接受，就算他是合理的，我覺得他對人的態度還是會讓他沒辦法達到目的。 他每一句感謝，聽在我耳裡，我都覺得好累，大概理解媽媽對外婆的想法了。 一直到下午上課時才整理完資料。  電路學 Midterm 2 複習    Chapter Time (min) #Problem     8 55 6   10 55 7    Ch8  Source-Free Series RLC Circuit  $$\\displaystyle i'' + \\frac{R}{L} i' + \\frac{1}{LC} i = 0$$   Source-Free Parallel RLC Circuit  $$\\displaystyle v'' + \\frac{1}{RC} v' + \\frac{1}{LC} v = 0$$   Solutions of Second Order Differential Equations  Overdamped: $$y(t) = A_1 e^{s_1 t} + A_2 e^{s_2 t}$$ Critically Damped: $$y(t) = (A_1 t + A_2) e^{-\\alpha t}$$ Underdamped: $$y(t) = e^{-\\alpha t} (A_1 \\cos \\omega_\\alpha t + A_2 \\sin \\omega_\\alpha t)$$    Ch9     $$R$$ $$L$$ $$C$$     $$Z$$ $$R$$ $$j \\omega L$$ $$\\frac{1}{j\\omega C}$$    ","date":"2020-11-30T11:59:23+08:00","permalink":"https://Luke2336.github.io/p/20201130/","title":"2020/11/30 日記"},{"content":"早上起床洗了衣服，然後洗了澡，之後架好了部落格，然後就去讀書。\nDate 和 Jacky 吃了買一送一的冰炫風，然後一起去圖書館讀書，晚餐去研三吃漢堡王。從圖書館出來時，看到了漂亮的雲。\n部落格 從星期四努力到現在，終於搞定了。\n之後會拿這個部落格來寫日記，可能也會寫一點練題紀錄，摻雜一點點讀書帳的味道。\n 參考了 bb 的部落格，決定使用 hugo 搭配 github.io。 從 blogger 轉來使用 hugo 的原因，其實是想用 markdown，因為會寫一些數學或是程式碼。 逛了一整晚的 Hugo Theme，最後決定用中國人設計的 hugo-theme-stack，主要是喜歡他簡潔的頁面，還有 categories 的設計。 參考 這篇 來放到 github 上。  電路學 Midterm 2 複習    Chapter Time (min) #Problem     7 40 7   8 40 5    Ch7  $$\\displaystyle y(t) = y(\\infty) + (y(t_0) - y(\\infty)) e^{\\frac{-(t - t_0)}{\\tau}}$$ RC Circuit: $$\\tau = RC$$ RL Circuit: $$\\tau = \\displaystyle \\frac{L}{R}$$  羽球 今天在新館打球，不小心跑到舊館。風很大，只有穿短袖短褲，不小心著涼了。今天前場比較積極，所以被稱讚有進步。有和碩班的學長姐打了兩場，覺得還不錯，之後幾場感覺比較沒力。\n驗題 和 Hyperbola 吵了很久，他的 BIT2D 不是區間更新，而只有單點更新。\n最後想了一下，二維 BIT 的區間更新 $$O(\\log^2 N)$$ 應該做不到，需要 $$O(N\\log N)$$。\n暗自覺得他都不搞清楚原理，對自己在寫的東西沒有概念。也許就像 MT 說的，很多競程選手學東西都求快，不夠扎實。卡車對他的觀察有點道理，他有時候過分自信，不容易發現自己的錯。\n","date":"2020-11-29T02:06:51+08:00","permalink":"https://Luke2336.github.io/p/20201129/","title":"2020/11/29 日記"}]