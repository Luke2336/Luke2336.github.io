[{"content":" 早餐吃了稀飯。 將 Blogger 的幾篇文章搬到這個新的 Blog 上。 將 USACO Section 2.2 完成。 去金山泡溫泉。  金山  去金山鴨肉，發現要戴口罩才能端菜，幸好我有帶一個口罩在身上。 吃了糖葫蘆和冰淇淋，泡了溫泉。 買了 3 張 200 元刮刮樂，刮中 1000 + 1500。 去了水尾漁港看風景，看到有人在停車場放煙火，這大概是這輩子看過最近距離的煙火。走過了觀景橋，到提防散步。  USACO  2.2 Runaround Numbers 2.2 Party Lamps  2.2 Runaround Numbers  題意：給定 M ≤ 2^32，找出一個大於 M 的循環數。循環數的定義為，沒用到 0，且每個位元不重複，從第一個位元 d 開始向右走 d 位，走到最右邊則從最左邊繼續，然後在從此位繼續，走完全部回到第一位且不重複。 解法：DFS 暴搜所有解，不斷更新最小值剪枝。  1/* 2ID: whitech1 3TASK: runround 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8typedef long long ll; 9ll m; 10vector\u0026lt;int\u0026gt; v; 11bool used[10]; 12bool check(ll num, int len) { 13 if (num \u0026lt;= m) return false; 14 vector\u0026lt;int\u0026gt; cnt(len); 15 for (int i = 0, r = 0; i \u0026lt; len; i++) { 16 r = (r + v[r]) % len; 17 cnt[r]++; 18 } 19 for (int i = 0; i \u0026lt; len; i++) 20 if (!cnt[i]) return false; 21 return true; 22} 23ll ans = 987654321LL; 24void solve(ll now, int len) { 25 if (check(now, len)) ans = min(ans, now); 26 if (now \u0026gt;= ans) return; 27 for (int i = 1; i \u0026lt;= 9; i++) { 28 if (used[i]) continue; 29 used[i] = true, v.push_back(i); 30 solve(now * 10 + i, len + 1); 31 used[i] = false, v.pop_back(); 32 } 33} 34int main() { 35 freopen(\u0026#34;runround.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 36 freopen(\u0026#34;runround.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 37 cin \u0026gt;\u0026gt; m; 38 solve(0, 0); 39 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 40 return 0; 41}  2.2 Party Lamps  題意：給定 N ≤ 100 和 C ≤ 10000。一開始有 N 盞燈，及四種按鈕，分別為所有燈、奇數燈、偶數燈、3K + 1 狀態改變。以及給定某些燈的狀態。C 為按下按鈕的總次數，求輸出所有最後可能的狀態。 解法：只需要考慮四種按鈕分別按下的奇偶性，以及和 C 的大小及奇偶是否一致。然後枚舉 16 種狀態去花 O(N) 確認。  1/* 2ID: whitech1 3TASK: lamps 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8void input(vector\u0026lt;int\u0026gt; \u0026amp;v) { 9 int x; 10 while (cin \u0026gt;\u0026gt; x \u0026amp;\u0026amp; x != -1) v.push_back(x); 11} 12int main() { 13 freopen(\u0026#34;lamps.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 14 freopen(\u0026#34;lamps.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 15 int n, c; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c; 16 vector\u0026lt;int\u0026gt; on, off; 17 input(on); input(off); 18 int start[4] = {1, 1, 2, 1}, step[4] = {1, 2, 2, 3}; 19 set\u0026lt;string\u0026gt; s; 20 for (int state = 0; state \u0026lt; 16; state++) { 21 int d = __builtin_popcount(state); 22 if (d \u0026gt; c || (d + c) \u0026amp; 1) continue; 23 vector\u0026lt;bool\u0026gt; lamp(1 + n); 24 for (int r = 0; r \u0026lt; 4; r++) 25 if ((1 \u0026lt;\u0026lt; r) \u0026amp; state) 26 for (int i = start[r]; i \u0026lt;= n; i += step[r]) 27 lamp[i] = !lamp[i]; 28 bool success = true; 29 for (int i : on) 30 if (lamp[i]) success = false; 31 for (int i : off) 32 if (!lamp[i]) success = false; 33 if (!success) continue; 34 string str = \u0026#34;\u0026#34;; 35 for (int i = 1; i \u0026lt;= n; i++) str += \u0026#34;10\u0026#34;[lamp[i]]; 36 s.insert(str); 37 } 38 if (s.empty()) cout \u0026lt;\u0026lt; \u0026#34;IMPOSSIBLE\\n\u0026#34;; 39 else for (string str : s) cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 40 return 0; 41}  ","date":"2021-02-12T11:50:19+08:00","permalink":"https://Luke2336.github.io/p/20210212/","title":"2021/02/12 日記"},{"content":"過年好痛苦。昨晚做了惡夢，夢到 Alice 跟我絕交，覺得很難過。晚上醒來好幾次。好討厭除夕，跟一群一直刺探隱私的人吃飯。\n自己過生日好孤單。\nUSACO  2.2 Preface Numbering 2.2 Subset Sums  2.2 Preface Numbering  題意：給定 N ≤ 3500，計算 1 ~ N 的羅馬字母表示法共用了每種字母個幾個。  1/* 2ID: whitech1 3TASK: preface 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8int d[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; 9string s[13] = {\u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34;}; 10int cnt[13]; 11void solve(int x) { 12 for (int i = 0; i \u0026lt; 13; i++) { 13 cnt[i] += x / d[i]; 14 x %= d[i]; 15 } 16} 17int main() { 18 freopen(\u0026#34;preface.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 19 freopen(\u0026#34;preface.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 20 int n; cin \u0026gt;\u0026gt; n; 21 for (int i = 1; i \u0026lt;= n; i++) solve(i); 22 int ans[7] = {}; 23 char c[8] = \u0026#34;IVXLCDM\u0026#34;; 24 for (int i = 0; i \u0026lt; 13; i++) 25 for (int j = 0; j \u0026lt; 7; j++) 26 for (char ch : s[i]) 27 if (ch == c[j]) ans[j] += cnt[i]; 28 for (int i = 0; i \u0026lt; 7; i++) 29 if (ans[i]) cout \u0026lt;\u0026lt; c[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 30 return 0; 31}  2.2 Subset Sums  題意：給定 N ≤ 39，計算 1 ~ N 有幾種分法能使兩堆一樣多。  1/* 2ID: whitech1 3TASK: subset 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8inline int sum(int x) {return x * (x + 1) \u0026gt;\u0026gt; 1;} 9int main() { 10 freopen(\u0026#34;subset.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 11 freopen(\u0026#34;subset.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 12 int n; cin \u0026gt;\u0026gt; n; 13 int m = sum(n); 14 if (m \u0026amp; 1) { 15 cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; 16 return 0; 17 } 18 m \u0026gt;\u0026gt;= 1; 19 vector\u0026lt;long long\u0026gt; dp(m + 1); 20 dp[0] = 1; 21 for (int i = 1; i \u0026lt;= n; i++) 22 for (int j = min(sum(i), m); j \u0026gt;= i; j--) 23 dp[j] += dp[j - i]; 24 cout \u0026lt;\u0026lt; (dp[m] \u0026gt;\u0026gt; 1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 25 return 0; 26}  ","date":"2021-02-11T09:57:18+08:00","permalink":"https://Luke2336.github.io/p/20210211/","title":"2021/02/11 日記"},{"content":"很混亂的一年，所有的事情都受到疫情影響。\n國內事件    Date News     2020/01/06 蘇花改通車   2020/01/11 蔡英文當選總統   2020/01/24 陳時中擔任 CECC 指揮官   2020/01/31 北捷環狀線通車   2020/02/06 7 天 2 片口罩   2020/03/02 大學延後開學   2020/03/19 限制入境   2020/04/09 14 天 9 片口罩   2002/05/29 通姦除罪化釋憲   2002/05/31 敦南誠品熄燈   2020/06/06 罷免高雄市長韓國瑜、議長跳樓   2020/07/01 5G   2020/07/30 前總統李登輝過世   2020/08/28 宣布萊豬進口   2020/11/07 清大前校長劉炯朗過世   2020/12/12 中天關台   2020/12/12 北一女校慶聊天擺攤事件   2020/12/25 民法下修 18 歲成年三讀通過   2021/01/20 部桃事件   2021/02/01 陽明交大合校   2021/02/06 高雄市議員黃捷罷免案   2021/02/09 趙少康宣布代表國民黨參選總統     交大學聯會於罷韓時的「返鄉專車」具政治立場，我認為不妥。 2020 這波韓流令人感慨台灣新聞媒體的力量，媒體能造神，也能把一個人轟下台，台灣的民意主要還是靠媒體炒作，還有靠網民帶風向。  國外新聞    Date News     2019/12/30 李文亮對華南海鮮市場疫情發出警告   2020/01/08 烏航於伊朗空域解體   2020/01/22 武漢封城   2020/01/31 英國正式脫歐   2020/02/04 公主號停靠橫濱   2020/02/11 WHO 命名 Covid 19   2020/02/20 韓國新天地教會事件   2020/03/24 東京奧運宣布停辦   2020/04/05 英國女王發布演說   2020/04/16 日本發布緊急事態   2020/06/30 香港國安法正式生效   2020/08/04 黎巴嫩港口爆炸   2020/11/03 美國大選，拜登獲勝   2021/01/20 拜登就任   2021/01/27 華爾街 Gamestop 散戶事件   2021/02/01 緬甸政變     香港議題在台灣大選後就被國內媒體淡化。 美中衝突不斷擴大，華為等中國企業被封殺。 美國大選爭議很多。  ","date":"2021-02-10T19:01:18+08:00","permalink":"https://Luke2336.github.io/p/news_2020/","title":"2020 簡記"},{"content":"今天是 20 歲的最後一天！\n晚上吃小火鍋，看到了弟弟的摩托車。\nUSACO 寫完了 Section 2.1。\n 2.1 The Castle 2.1 Ordered Fractions 2.1 Sorting a Three-Valued Sequence 2.1 Healthy Holsteins 2.1 Hamming Codes  2.1 The Castle  \u0026ldquo;Farthest to the west\u0026rdquo; 是指「最西邊」。 題意：給定每個房間的四道牆，問拆一道牆能形成的最大房間大小。 解法：Flood Fill 算出每個房間的大小，再試著拆每道牆。  1/* 2ID: whitech1 3TASK: castle 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8const char D[5] = \u0026#34;WNES\u0026#34;; 9const int dx[4] = {0, -1, 0, 1}; 10const int dy[4] = {-1, 0, 1, 0}; 11int main() { 12 freopen(\u0026#34;castle.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 13 freopen(\u0026#34;castle.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 14 int n, m; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; 15 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; w(n, vector\u0026lt;int\u0026gt;(m)); 16 for (int i = 0; i \u0026lt; n; i++) 17 for (int j = 0; j \u0026lt; m; j++) 18 cin \u0026gt;\u0026gt; w[i][j]; 19 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; G(n, vector\u0026lt;int\u0026gt;(m)); 20 vector\u0026lt;int\u0026gt; sz(1); 21 int mx = 0; 22 for (int i = 0; i \u0026lt; n; i++) { 23 for (int j = 0; j \u0026lt; m; j++) { 24 if (G[i][j]) continue; 25 queue\u0026lt;int\u0026gt; qx, qy; 26 qx.push(i), qy.push(j); 27 G[i][j] = sz.size(); 28 sz.push_back(1); 29 while (!qx.empty()) { 30 int x = qx.front(); qx.pop(); 31 int y = qy.front(); qy.pop(); 32 for (int d = 0; d \u0026lt; 4; d++) { 33 if ((1 \u0026lt;\u0026lt; d) \u0026amp; w[x][y]) continue; 34 int xx = x + dx[d], yy = y + dy[d]; 35 if (G[xx][yy]) continue; 36 G[xx][yy] = G[x][y]; 37 qx.push(xx), qy.push(yy); 38 sz.back()++; 39 } 40 } 41 mx = max(mx, sz.back()); 42 } 43 } 44 cout \u0026lt;\u0026lt; sz.size() - 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 45 mx = 0; 46 int ax, ay; char dir; 47 for (int j = 0; j \u0026lt; m; j++) { 48 for (int i = n - 1; i \u0026gt;= 0; i--) { 49 for (int d = 1; d \u0026lt;= 2; d++) { 50 if ((1 \u0026lt;\u0026lt; d) \u0026amp; w[i][j]) { 51 int ii = i + dx[d], jj = j + dy[d]; 52 if (ii \u0026lt; 0 || jj \u0026gt;= m) continue; 53 if (G[ii][jj] == G[i][j]) continue; 54 if (sz[G[i][j]] + sz[G[ii][jj]] \u0026gt; mx) { 55 mx = sz[G[i][j]] + sz[G[ii][jj]]; 56 ax = i, ay = j, dir = D[d]; 57 } 58 } 59 } 60 } 61 } 62 cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; ax + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ay + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; dir \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 63 return 0; 64}  2.1 Ordered Fractions  題意：枚舉出 0 ~ 1 之間，分母最大為 N ≤ 160 的分數，依照大小印出。 解法：只將分子與分母互質的最簡分數(reduced fraction)放入，再定義大小排序。  1/* 2ID: whitech1 3TASK: frac1 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8typedef pair\u0026lt;int, int\u0026gt; frac; 9#define x first 10#define y second 11bool cmp (const frac \u0026amp;a, const frac \u0026amp;b) { 12 return a.x * b.y \u0026lt; a.y * b.x; 13} 14int main() { 15 freopen(\u0026#34;frac1.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 16 freopen(\u0026#34;frac1.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 17 int n; cin \u0026gt;\u0026gt; n; 18 vector\u0026lt;frac\u0026gt; v; 19 v.push_back(frac(0, 1)); 20 for (int i = 1; i \u0026lt;= n; i++) 21 for (int j = 1; j \u0026lt;= i; j++) 22 if (__gcd(i, j) == 1) 23 v.push_back(frac(j, i)); 24 sort(v.begin(), v.end(), cmp); 25 for (frac f : v) cout \u0026lt;\u0026lt; f.x \u0026lt;\u0026lt; \u0026#39;/\u0026#39; \u0026lt;\u0026lt; f.y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 26 return 0; 27}  2.1 Sorting a Three-Valued Sequence  題意：給定一個長度為 n ≤ 1000 的序列，元素只有 1, 2, 3，操作為將任意兩個位置的元素交換，問最少要幾個操作才能將序列排序？ 解法：Greedy，先將陣列排序，和原陣列比較。若兩兩交換能到對的位置則交換，各消耗 1 次操作。其餘會形成 cycle，cycle 需要 2 次操作。  1/* 2ID: whitech1 3TASK: sort3 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8int main() { 9 freopen(\u0026#34;sort3.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 10 freopen(\u0026#34;sort3.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 11 int n; cin \u0026gt;\u0026gt; n; 12 vector\u0026lt;int\u0026gt; a(n); 13 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 14 vector\u0026lt;int\u0026gt; b(a.begin(), a.end()); 15 sort(b.begin(), b.end()); 16 int c[4][4] = {}; 17 for (int i = 0; i \u0026lt; n; i++) 18 if (a[i] != b[i]) c[a[i]][b[i]]++; 19 int ans = 0; 20 for (int i = 1; i \u0026lt; 3; i++) { 21 for (int j = i + 1; j \u0026lt;= 3; j++) { 22 int d = min(c[i][j], c[j][i]); 23 ans += d, c[i][j] -= d, c[j][i] -= d; 24 } 25 } 26 int tmp = 0; 27 for (int i = 1; i \u0026lt;= 3; i++) 28 for (int j = 1; j \u0026lt;= 3; j++) 29 tmp += c[i][j]; 30 cout \u0026lt;\u0026lt; ans + tmp * 2 / 3 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 31 return 0; 32}  2.1 Healthy Holsteins  題意：牛需要 V 種維他命。有 G 種飼料可選擇，問最少要選擇幾種飼料，才能使維他命的和達到牛所需的量。 解法：枚舉所有組合檢查。 複雜度：$$O(VG2^G)$$  1/* 2ID: whitech1 3TASK: holstein 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8int main() { 9 freopen(\u0026#34;holstein.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 10 freopen(\u0026#34;holstein.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 11 int v; cin \u0026gt;\u0026gt; v; 12 vector\u0026lt;int\u0026gt; need(v); 13 for (int i = 0; i \u0026lt; v; i++) cin \u0026gt;\u0026gt; need[i]; 14 int n; cin \u0026gt;\u0026gt; n; 15 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; vit(n, vector\u0026lt;int\u0026gt;(v)); 16 for (int i = 0; i \u0026lt; n; i++) 17 for (int j = 0; j \u0026lt; v; j++) 18 cin \u0026gt;\u0026gt; vit[i][j]; 19 int N = 1 \u0026lt;\u0026lt; n; 20 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(N, vector\u0026lt;int\u0026gt;(v)); 21 int ans = n, id = N - 1; 22 for (int i = 0; i \u0026lt; N; i++) { 23 int cnt = 0; 24 for (int j = 0; j \u0026lt; n; j++) { 25 if ((1 \u0026lt;\u0026lt; j) \u0026amp; i) cnt++; 26 else for (int r = 0, k = i | (1 \u0026lt;\u0026lt; j); !dp[k][r] \u0026amp;\u0026amp; r \u0026lt; v; r++) 27 dp[k][r] = dp[i][r] + vit[j][r]; 28 } 29 bool success = true; 30 for (int r = 0; r \u0026lt; v; r++) 31 if (dp[i][r] \u0026lt; need[r]) success = false; 32 if (success) { 33 if (cnt \u0026lt; ans) ans = cnt, id = i; 34 else if (cnt \u0026lt;= ans) id = min(i, id); 35 } 36 } 37 cout \u0026lt;\u0026lt; ans; 38 for (int i = 0; i \u0026lt; n; i++) 39 if (id \u0026amp; (1 \u0026lt;\u0026lt; i)) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; i + 1; 40 cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 41 return 0; 42}  2.1 Hamming Codes  題意：輸出一個大小為 N ≤ 64 的集合，裡面的元素長度為 B ≤ 8 個 bits，兩兩 Hamming distance 不小於 D ≤ 7。 解法：測資弱，直接暴力枚舉。用 __builtin_popcount(x) 算幾個 1-bit。  1/* 2ID: whitech1 3TASK: hamming 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8typedef unsigned int ui; 9vector\u0026lt;ui\u0026gt; ans; 10bool success = false; 11int N, M, D, B; 12void dfs() { 13 if (success) return; 14 if (ans.size() == N) { 15 success = true; 16 sort(ans.begin(), ans.end()); 17 for (int i = 0; i \u0026lt; N; i++) 18 cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i % 10 == 9 || i == N - 1]; 19 return; 20 } 21 for (ui i = 0; i \u0026lt; M \u0026amp;\u0026amp; !success; i++) { 22 bool add = true; 23 for (ui x : ans) { 24 if (__builtin_popcount(i ^ x) \u0026lt; D) { 25 add = false; break; 26 } 27 } 28 if (add) { 29 ans.push_back(i); 30 dfs(); 31 ans.pop_back(); 32 } 33 } 34} 35int main() { 36 freopen(\u0026#34;hamming.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 37 freopen(\u0026#34;hamming.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 38 int B; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; B \u0026gt;\u0026gt; D; 39 M = 1 \u0026lt;\u0026lt; B; 40 dfs(); 41 return 0; 42}  ","date":"2021-02-10T11:36:51+08:00","permalink":"https://Luke2336.github.io/p/20210210/","title":"2021/02/10 日記"},{"content":"今天左下腹還是悶悶的。\nUSACO  重新開始刷 USACO，USACO 最早是 2018 年就有看到的網站，以前因為是英文題面所以沒認真刷。覺得不能亂刷題，應該有系統的刷題，所以就想寒假把這邊刷到 chapter 3，練基礎能力。 今天刷完 Chapter 1 了～  1.4 Wormholes 1.4 Ski Course Design 1.5 Arithmetic Progressions 1.5 Mother’s Milk 1.6 Number Triangles 1.6 Prime Palindromes 1.6 Superprime Rib    1.4 Wormholes  題意：有 12 個蟲洞，要配對成兩兩一組，一旦碰到蟲洞就會被傳送到另一端，且一直往 +X 方向移動，問有多少種組合能形成環？ 這題是很好的題目，能練習實作暴搜。首先要會 DFS 枚舉組合，方法是每次找到第一個沒被用到的點，然後枚舉能和他匹配的點。之後再檢查每個組合是否有環，採取 BFS，每次走兩步，先一步蟲洞，再走到下一個點。  1/* 2ID: whitech1 3TASK: wormhole 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8typedef pair\u0026lt;int, int\u0026gt; pii; 9#define x first 10#define y second 11int n, ans = 0; 12vector\u0026lt;pii\u0026gt; p; 13vector\u0026lt;vector\u0026lt;bool\u0026gt; \u0026gt; G; 14vector\u0026lt;int\u0026gt; pr; 15bool check() { 16 vector\u0026lt;int\u0026gt; visit(n); 17 queue\u0026lt;int\u0026gt; q; 18 for (int i = 0; i \u0026lt; n; i++) q.push(i); 19 while (!q.empty()) { 20 int u = q.front(); q.pop(); 21 if (visit[u] \u0026gt; 2 * n) return true; 22 for (int i = 0; i \u0026lt; n; i++) { 23 if (G[pr[u]][i]) 24 q.push(i), visit[i] = visit[u] + 2; 25 } 26 } 27 return false; 28} 29void per(int cnt) { 30 if (cnt == n) { 31 if (check()) ans++; 32 return; 33 } 34 for (int i = 0; i \u0026lt; n; i++) { 35 if (pr[i] != -1) continue; 36 for (int j = i + 1; j \u0026lt; n; j++) { 37 if (pr[j] != -1) continue; 38 pr[i] = j, pr[j] = i; 39 per(cnt + 2); 40 pr[i] = pr[j] = -1; 41 } 42 break; 43 } 44} 45int main() { 46 freopen(\u0026#34;wormhole.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 47 freopen(\u0026#34;wormhole.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 48 cin \u0026gt;\u0026gt; n; 49 p.resize(n), pr.resize(n, -1); 50 G.resize(n, vector\u0026lt;bool\u0026gt;(n)); 51 for (int i = 0; i \u0026lt; n; i++) 52 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 53 sort(p.begin(), p.end()); 54 for (int i = 0; i \u0026lt; n; i++) 55 for (int j = i + 1; j \u0026lt; n; j++) 56 if (p[i].y == p[j].y) { 57 G[i][j] = true; 58 break; 59 } 60 per(0); 61 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 62 return 0; 63}  1.4 Ski Course Design 1/* 2ID: whitech1 3TASK: skidesign 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8inline int d(int x) {return x * x;} 9int main() { 10 freopen(\u0026#34;skidesign.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 11 freopen(\u0026#34;skidesign.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 12 int n; cin \u0026gt;\u0026gt; n; 13 vector\u0026lt;int\u0026gt; v(n); 14 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; 15 sort(v.begin(), v.end()); 16 int ans = n * d(100); 17 for (int m = 0; m \u0026lt;= 100; m++) { 18 int cnt = 0; 19 for (int a : v) 20 if (a \u0026lt; m) cnt += d(m - a); 21 else if (a \u0026gt; m + 17) cnt += d(a - m - 17); 22 ans = min(ans, cnt); 23 } 24 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 25 return 0; 26}  1.5 Arithmetic Progressions  題意：枚舉 p * p + q * q (0 ≤ p, q ≤ m ≤ 250)序列中的長度為 n ≤ 25 的序列。時間為 5 秒。 作法：把序列先用 bool seq[2 * m * m + 1] 紀錄。枚舉前兩個元素來檢查序列。  1/* 2ID: whitech1 3TASK: ariprog 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8typedef pair\u0026lt;int, int\u0026gt; pii; 9set\u0026lt;int\u0026gt; s; 10int main() { 11 freopen(\u0026#34;ariprog.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 12 freopen(\u0026#34;ariprog.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 13 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 14 vector\u0026lt;int\u0026gt; sq(m + 1); 15 for (int i = 1; i \u0026lt;= m; i++) sq[i] = i * i; 16 for (int i = 0; i \u0026lt;= m; i++) 17 for (int j = i; j \u0026lt;= m; j++) 18 s.insert(sq[i] + sq[j]); 19 set\u0026lt;pii\u0026gt; ans; 20 vector\u0026lt;int\u0026gt; v(s.begin(), s.end()); 21 vector\u0026lt;bool\u0026gt; seq(2 * m * m + 1); 22 for (int i : v) seq[i] = true; 23 for (int i : v) { 24 for (int j : v) { 25 if (i \u0026gt;= j) continue; 26 int d = j - i; 27 bool success = true; 28 for (int k = i + (n - 1) * d; k \u0026gt; j; k -= d) 29 if (k \u0026gt;= seq.size() || !seq[k]) { 30 success = false; 31 break; 32 } 33 if (success) ans.insert(pii(d, i)); 34 } 35 } 36 for (auto i : ans) cout \u0026lt;\u0026lt; i.second \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i.first \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 37 if (!ans.size()) cout \u0026lt;\u0026lt; \u0026#34;NONE\\n\u0026#34;; 38 return 0; 39}  1.5 Mother\u0026rsquo;s Milk  題意：給定 1 ≤ A, B, C ≤ 20，三個桶子，問 A 桶為空時，C 有哪些可能的容量。  1/* 2ID: whitech1 3TASK: milk3 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8int a, b, c; 9bool ans[25][25][25]; 10void solve(int x, int y, int z) { 11 if (ans[x][y][z]) return; 12 ans[x][y][z] = true; 13 int d; 14 // A -\u0026gt; B 15 d = min(x, b - y); 16 solve(x - d, y + d, z); 17 // A -\u0026gt; C 18 d = min(x, c - z); 19 solve(x - d, y, z + d); 20 // B -\u0026gt; A 21 d = min(a - x, y); 22 solve(x + d, y - d, z); 23 // B -\u0026gt; C 24 d = min(y, c - z); 25 solve(x, y - d, z + d); 26 // C -\u0026gt; A 27 d = min(a - x, z); 28 solve(x + d, y, z - d); 29 // C -\u0026gt; B 30 d = min(b - y, z); 31 solve(x, y + d, z - d); 32} 33int main() { 34 freopen(\u0026#34;milk3.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 35 freopen(\u0026#34;milk3.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 36 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; 37 solve(0, 0, c); 38 for (int i = 0; i \u0026lt; c; i++) 39 if (c - i \u0026lt;= b \u0026amp;\u0026amp; ans[0][c - i][i]) 40 cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 41 cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 42 return 0; 43}  1.6 Binary Numbers    Value Binary Sample Meaning     x 00101100 the original x value   x \u0026amp; -x 00000100 extract lowest bit set   x | -x 11111100 create mask for lowest-set-bit \u0026amp; bits to its left   x ^ -x 11111000 create mask bits to left of lowest bit set   x \u0026amp; (x - 1) 00101000 strip off lowest bit set   x | (x - 1) 00101111 fill in all bits below lowest bit set   x ^ (x - 1) 00000111 create mask for lowest-set-bit \u0026amp; bits to its right   ~x \u0026amp; (x - 1) 00000011 create mask for bits to right of lowest bit set   x | (x + 1) 00101101 toggle lowest zero bit   x / (x \u0026amp; -x) 00001011 shift number right so lowest set bit is at bit 0    1.6 Number Triangles 1/* 2ID: whitech1 3TASK: numtri 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8int main() { 9 freopen(\u0026#34;numtri.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 10 freopen(\u0026#34;numtri.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 11 int r; cin \u0026gt;\u0026gt; r; 12 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; a(r); 13 for (int i = 0; i \u0026lt; r; i++) { 14 a[i].resize(i + 1); 15 for (int j = 0; j \u0026lt;= i; j++) 16 cin \u0026gt;\u0026gt; a[i][j]; 17 } 18 for (int i = 1; i \u0026lt; r; i++) 19 for (int j = 0; j \u0026lt;= i; j++) 20 a[i][j] += max(a[i - 1][max(0, j - 1)], 21 a[i - 1][min(i - 1, j)]); 22 int ans = 0; 23 for (int j = 0; j \u0026lt; r; j++) 24 ans = max(ans, a[r - 1][j]); 25 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 26 return 0; 27}  1.6 Prime Palindromes  題意：找 [a, b] 中同時為迴文和質數的數。 方法：枚舉迴文，再檢查使否為質數，相反會超時。可以發現除了 11 以外的偶位數迴文都會被 11 整除，即非質數。  1/* 2ID: whitech1 3TASK: pprime 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8vector\u0026lt;int\u0026gt; prime; 9bool isprime[10000]; 10void gen_prime() { 11 prime.push_back(2); 12 for (int i = 3; i \u0026lt; 10000; i += 2) { 13 if (isprime[i]) continue; 14 prime.push_back(i); 15 for (int j = i * i; j \u0026lt; 10000; j += 2 * i) 16 isprime[j] = true; 17 } 18} 19bool check_prime(int x) { 20 for (int p : prime) { 21 if (p * p \u0026gt; x) return true; 22 if (x % p == 0) return false; 23 } 24 return true; 25} 26int num(int x) { 27 int ret = x; 28 vector\u0026lt;int\u0026gt; v; 29 while (x) { 30 v.push_back(x % 10); 31 x /= 10; 32 } 33 for (int i = 1; i \u0026lt; v.size(); i++) 34 ret = ret * 10 + v[i]; 35 return ret; 36} 37int main() { 38 freopen(\u0026#34;pprime.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 39 freopen(\u0026#34;pprime.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 40 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 41 gen_prime(); 42 vector\u0026lt;int\u0026gt; ans; 43 int c[] = {2, 3, 5, 7, 11}; 44 for (int i : c) 45 if (a \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt;= b) 46 ans.push_back(i); 47 for (int i = 10; i \u0026lt; 10000; i++) { 48 int x = num(i); 49 if (a \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= b \u0026amp;\u0026amp; check_prime(x)) 50 ans.push_back(x); 51 } 52 for (int i : ans) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 53 return 0; 54}  1.6 Superprime Rib 1/* 2ID: whitech1 3TASK: sprime 4LANG: C++14 5*/ 6#include \u0026lt;bits/stdc++.h\u0026gt;7using namespace std; 8vector\u0026lt;int\u0026gt; prime; 9bool isprime[10000]; 10void gen_prime() { 11 prime.push_back(2); 12 for (int i = 3; i \u0026lt; 10000; i += 2) { 13 if (isprime[i]) continue; 14 prime.push_back(i); 15 for (int j = i * i; j \u0026lt; 10000; j += 2 * i) 16 isprime[j] = true; 17 } 18} 19bool check_prime(int x) { 20 if (x \u0026lt; 2) return false; 21 for (int p : prime) { 22 if (p * p \u0026gt; x) return true; 23 if (x % p == 0) return false; 24 } 25 return true; 26} 27vector\u0026lt;int\u0026gt; ans; 28void solve(int cnt, int n, int num) { 29 if (cnt == n) { 30 ans.push_back(num); 31 return; 32 } 33 for (int i = 1; i \u0026lt;= 9; i++) { 34 int d = num * 10 + i; 35 if (check_prime(d)) solve(cnt + 1, n, d); 36 } 37} 38int main() { 39 freopen(\u0026#34;sprime.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); 40 freopen(\u0026#34;sprime.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); 41 int n; cin \u0026gt;\u0026gt; n; 42 gen_prime(); 43 solve(0, n, 0); 44 for (int i : ans) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 45 return 0; 46}  ","date":"2021-02-09T11:30:39+08:00","permalink":"https://Luke2336.github.io/p/20210209/","title":"2021/02/09 日記"},{"content":"ICPC 2020 Taipei 出了一題水母圖的同構，於是今天找了這題樹同構練習，採用括號字串的方法，而不是 Hashing。\n 水母圖  對於環上每個點當 root 去生出樹字串。 串接起來後，用環狀字串的演算法去比較。    TIOJ 1214 - 樹論 之 樹同構測試 $$O(|G|^2 \\log \\Delta(G)) = O(n^2 \\log n)$$\n n ≤ 100。給定兩棵樹的邊，問他們是否同構 \u0026ldquo;isomorphic\u0026rdquo; 先 DFS 找出所有的樹重心（最多 2 個）。樹重心的定義為，最大子樹大小最小的點。 從重心開始做 DFS，將每個點用 () 表示，中間夾括入他所有子樹字串，將他們排序後加入。每次排序為度數個，所以總共需要排序 deg - 1 個，所有點加起來為 n 個，再乘上字串比較的複雜度 O(n)。 最後再將重心們的字串排序後串接，比較兩棵樹是否相同。  1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt;3using namespace std; 4#define pb push_back 5int n; 6int dfs(int u, int p, int \u0026amp;mi, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;G, vector\u0026lt;int\u0026gt; \u0026amp;ret) { 7 int cnt = 0, mx = 0; 8 for (int uu : G[u]) { 9 if (uu == p) continue; 10 int r = dfs(uu, u, mi, G, ret); 11 mx = max(mx, r), cnt += r; 12 } 13 mx = max(mx, n - cnt - 1); 14 if (mx \u0026lt;= mi) { 15 if (mx \u0026lt; mi) ret.clear(), mi = mx; 16 ret.pb(u); 17 } 18 return cnt + 1; 19} 20vector\u0026lt;int\u0026gt; centroid(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;G) { 21 vector\u0026lt;int\u0026gt; ret; 22 int mi = n; 23 dfs(1, -1, mi, G, ret); 24 return ret; 25} 26string tree(int u, int p, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;G) { 27 string ret = \u0026#34;\u0026#34;; 28 vector\u0026lt;string\u0026gt; sub; 29 for (int uu : G[u]) 30 if (uu != p) sub.pb(tree(uu, u, G)); 31 sort(sub.begin(), sub.end()); 32 for (string s : sub) ret += s; 33 return \u0026#34;(\u0026#34; + ret + \u0026#34;)\u0026#34;; 34} 35string solve() { 36 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; G(n + 1); 37 for (int i = 1; i \u0026lt; n; i++) { 38 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 39 G[a].pb(b), G[b].pb(a); 40 } 41 vector\u0026lt;string\u0026gt; ans; 42 for (int u : centroid(G)) ans.pb(tree(u, -1, G)); 43 sort(ans.begin(), ans.end()); 44 string ret = \u0026#34;\u0026#34;; 45 for (string s : ans) ret += s; 46 return ret; 47} 48int main() { 49 ios::sync_with_stdio(0), cin.tie(0); 50 while (1) { 51 cin \u0026gt;\u0026gt; n; if (!n) break; 52 cout \u0026lt;\u0026lt; (solve() == solve() ? \u0026#34;Same\u0026#34; : \u0026#34;Different\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 53 } 54 return 0; 55}  ","date":"2021-02-08T20:36:05+08:00","permalink":"https://Luke2336.github.io/p/tioj1214/","title":"TIOJ 1214 樹同構"},{"content":"今天都腦袋昏昏的，只有睡覺和寫 code，晚餐吃了泡麵。\n Project Euler  25 29 36   TIOJ  1214 樹論 之 樹同構測試 1044 [Interactive] Guess My Number 1072 A.誰先晚餐 1006 大數除法    CSES 2205 - Gray Code 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt;3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;int, int\u0026gt; pii; 6int main() { 7 ios::sync_with_stdio(0), cin.tie(0); 8 int n; cin \u0026gt;\u0026gt; n; 9 for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) { 10 for (int j = n - 1; j \u0026gt;= 0; j--) { 11 int a = i \u0026gt;\u0026gt; j; 12 int b = a \u0026gt;\u0026gt; 1; 13 cout \u0026lt;\u0026lt; ((a ^ b) \u0026amp; 1); 14 } 15 cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 16 } 17 return 0; 18}  CSES 1624 - Chessboard and Queens 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt;3using namespace std; 4bool a[8], b[20], c[20]; 5char m[8][9]; 6int ans = 0; 7void dfs (int i) { 8 if (i == 8) { 9 ans++; 10 return; 11 } 12 for (int j = 0; j \u0026lt; 8; j++) { 13 if (m[i][j] == \u0026#39;*\u0026#39;) continue; 14 if (a[j] || b[i + j] || c[i - j + 8]) continue; 15 a[j] = b[i + j] = c[i - j + 8] = true; 16 dfs(i + 1); 17 a[j] = b[i + j] = c[i - j + 8] = false; 18 } 19} 20int main() { 21 ios::sync_with_stdio(0), cin.tie(0); 22 for (int i = 0; i \u0026lt; 8; i++) scanf(\u0026#34; %s\u0026#34;, m[i]); 23 dfs(0); 24 printf(\u0026#34;%d\\n\u0026#34;, ans); 25 return 0; 26}  ","date":"2021-02-08T10:52:36+08:00","permalink":"https://Luke2336.github.io/p/20210208/","title":"2021/02/08 日記"},{"content":"常用指令    command 用途     clear clear terminal window   ls list directory content   ls -a 將隱藏檔案也列出   cd change directory to home   cd .. change directory to parent   cd - change directory to last working directory   cd / change directory to root   pwd print working directory   rm file_name remove file   mkdir dir_name make directory   rmdir dir_name remove directory   rm -R dir_name remove the directory and all files in the directory   cp -R A B 將 A 資料夾的東西全部複製到 B   mv A dir_name 將 A 搬到資料夾   cat file_name 查看內容   grep text file_name 抓取內容    ","date":"2021-02-07T14:08:22+08:00","permalink":"https://Luke2336.github.io/p/mac_cmd/","title":"MacOS Command Line Note"},{"content":"今天左下腹有些不舒服，頭也悶悶痛痛的，在車上一直睡。\nzerojudge:\n e507 e513 a782 a780 b112  馬崗 五色鳥、喜鵲巢。\n石頭屋的貓。\n蜜月灣 Kattis - Walrus Weights 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int n; cin \u0026gt;\u0026gt; n; 6 bool dp[2005] = {true}; 7 for (int i = 0; i \u0026lt; n; i++) { 8 int x; cin \u0026gt;\u0026gt; x; 9 for (int j = 2000; j \u0026gt;= x; j--) 10 dp[j] = dp[j] | dp[j - x]; 11 } 12 for (int i = 0; i \u0026lt;= 1000; i++) 13 if (dp[1000 + i]) { 14 cout \u0026lt;\u0026lt; 1000 + i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 15 return 0; 16 } else if (dp[1000 - i]) { 17 cout \u0026lt;\u0026lt; 1000 - i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 18 return 0; 19 } 20 return 0; 21}  ","date":"2021-02-07T12:44:00+08:00","permalink":"https://Luke2336.github.io/p/20210207/","title":"2021/02/07 日記"},{"content":"今天去動物園玩，直接搭遊園車從鳥園站開始走，花了近五個小時，除了爬蟲館和貓熊館以外幾乎都有參觀到，還看了新的穿山甲館。比較喜歡的動物有小貓熊、狐獴、無尾熊等等。\n晚上在北車二樓吃飯，然後搭自強號回去，下車時不小心開了駕駛室的門，超囧。\nzerojudge 滿 500 題了 www\n e473 e196 e466 d925 d810 a158 d813  ","date":"2021-02-06T20:11:59+08:00","permalink":"https://Luke2336.github.io/p/20210206/","title":"2021/02/06 日記"},{"content":"下午吃了草莓加煉乳，晚餐去博愛吃了牛肉麵，然後耍廢看了一部電影。\nKattis - Alphabet 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 string s; cin \u0026gt;\u0026gt; s; 5 int dp[30][55] = {}; 6 for (int i = 0; i \u0026lt; 26; i++) 7 for (int j = 0; s[j]; j++) 8 if (s[j] == i + \u0026#39;a\u0026#39;) 9 dp[i + 1][j + 1] = dp[i][j] + 1; 10 else 11 dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]); 12 cout \u0026lt;\u0026lt; 26 - dp[26][s.length()] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 return 0; 14}  ","date":"2021-02-05T09:38:23+08:00","permalink":"https://Luke2336.github.io/p/20210205/","title":"2021/02/05 日記"},{"content":"早上在清夜吃完永和豆漿後，就搭豪泰去北車，下高速公路時遇到車禍，塞了很久，下車的地點換到轉運站裡，之後就到館前路的台灣銀行開戶。\n開戶完之後，就去北一女找老師，等老師下班的時間，看了樂儀旗的練習。之後一起去了館前路的「咖啡弄」吃了午餐，覺得還滿棒的！之後我們到北門附近散步，逛了一些歷史建築，之後就各自回去了。\n在北車地下街逛了誠品，覺得頭有點昏，回到新竹後覺得很累。\n回宿舍後讀了德文，晚上去忠孝路的大潤發吃了烤雞，等了很久才出餐。\n開戶 - 台灣銀行館前分行  雙證件、印章、$1000 大概花 30 分鐘，官方說法是 40 分鐘。我隔壁的先生連 email 都沒有，感覺就要弄很久。 量完體溫後，保全會問你要辦什麼，說要開戶，就直接拿到號碼牌，完全不用等，就直接被叫號了。 會問職業，還有確認是否要在那家分行開戶，之後就一直簽名。 要下載兩個手機 app（強迫推銷），「台灣銀行」和「台灣行動支付」，行員會讓你在製作卡片時自己做這件事。結果行員聽到我沒用過行動支付，她似乎很訝異。 網銀要回家自己更換密碼開通。回去後發現自己的讀卡機不支援 macOS，一整個慘，之後回基隆再弄。  台北記憶倉庫 是日治時代留下的三井物產的倉庫，裡面有小酒吧，有賣一些精釀啤酒，還有一些歷史介紹。\n台博館鐵道部 因為要收門票，就沒有進去參觀了。\n","date":"2021-02-04T17:42:09+08:00","permalink":"https://Luke2336.github.io/p/20210204/","title":"2021/02/04 日記"},{"content":"心情不太好，懶懶散散的不想做任何事。\nCode zerojudge:\n c303 c304  CSES 2195 - Convex Hull  這題是要求在凸包上的所有點，所以 cross() \u0026lt; 0 才需要拔掉。 cross 的部分要記得開 long long，不然會溢位。  1// monotone chain 2#include\u0026lt;bits/stdc++.h\u0026gt;3using namespace std; 4struct point { 5 long long x, y; 6 point() {} 7 point(long long _x, long long _y) { x = _x, y = _y;} 8 point operator-(const point p) { 9 return point(x - p.x, y - p.y); 10 } 11 long long cross(const point \u0026amp;p) { 12 return x * p.y - y * p.x; 13 } 14}; 15static bool cmp(const point \u0026amp;a, const point \u0026amp;b) { 16 return (a.x \u0026lt; b.x) || (a.x == b.x \u0026amp;\u0026amp; a.y \u0026lt; b.y); 17} 18void convex_hull(vector\u0026lt;point\u0026gt; p, vector\u0026lt;point\u0026gt; \u0026amp;h) { 19 sort(p.begin(), p.end(), cmp); 20 h.resize(p.size() + 1); 21 int m = 0; 22 for (int i = 0; i \u0026lt; p.size(); i++) { 23 while (m \u0026gt;= 2 \u0026amp;\u0026amp; 24 (h[m - 1] - h[m - 2]).cross(p[i] - h[m - 2]) \u0026lt; 0) 25 m--; 26 h[m++] = p[i]; 27 } 28 for (int i = p.size() - 2, t = m + 1; i \u0026gt;= 0; i--) { 29 while (m \u0026gt;= t \u0026amp;\u0026amp; 30 (h[m - 1] - h[m - 2]).cross(p[i] - h[m - 2]) \u0026lt; 0) 31 m--; 32 h[m++] = p[i]; 33 } 34 if (p.size() \u0026gt; 1) m--; 35 h.resize(m); 36} 37int main () { 38 ios::sync_with_stdio(0), cin.tie(0); 39 int n; cin \u0026gt;\u0026gt; n; 40 vector\u0026lt;point\u0026gt; P(n); 41 for (int i = 0; i \u0026lt; n; i++) 42 cin \u0026gt;\u0026gt; P[i].x \u0026gt;\u0026gt; P[i].y; 43 vector\u0026lt;point\u0026gt; H; 44 convex_hull(P, H); 45 cout \u0026lt;\u0026lt; H.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 46 for (point p : H) 47 cout \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 48 return 0; 49}  ","date":"2021-02-03T14:10:52+08:00","permalink":"https://Luke2336.github.io/p/20210203/","title":"2021/02/03 日記"},{"content":"早上妹妹翻肚肚給我看。\n練習用 Python 解水題。\nzerojedge 水題：\n f043 e997 b969 c716 c717 c186 e051 c726 c760 c659 c929 f035 e340 e346 e357 e343 d244 f063 a275 c676 c705  從基隆回新竹，晚上去巨城吃飯。\n","date":"2021-02-02T10:19:00+08:00","permalink":"https://Luke2336.github.io/p/20210202/","title":"2021/02/02 日記"},{"content":"今天倦怠感很重，吃完早餐就簡單的睡個午覺，然後被吵醒幫小白目點眼藥水，然後又睡到傍晚。\n看了幾集 DW 的 ABC。\n晚餐去夜市吃牛排，然後去找小白目和小黑白玩，小黑白在我旁邊打轉，不時咬我的外套，小白目怕冷所以爬到腿上給抱抱。\n挖完耳朵後，量了耳溫，兩邊差 1.5 度。\n","date":"2021-02-02T10:12:07+08:00","permalink":"https://Luke2336.github.io/p/20210201/","title":"2021/02/01 日記"},{"content":"目錄 這邊的分類不代表開課系所，只是用課的性質去歸納。\n 物理  物理（一）、（二） 物理實驗（一）、（二）   數學  微積分甲（一）、（二） 離散數學 線性代數 微分方程 訊號與系統 機率   資工  程式  計算機概論與程式設計 物件導向與資料結構 基礎程式設計（GPE）   硬體、底層  數位電路設計 數位電路實驗 計算機組織 作業系統概論   計算理論  基礎圖論 演算法概論 隨機演算法 高等演算法   其他選修  競技程式設計（一）、(二)、（三） 人工智慧概論 資料庫系統概論     電機  電子學（一） 電子實驗（一） 電路學   通識  校基本  疾病知識與防治 幾何造型 統計方法與資料分析 認識語言   跨院  統計學   核心  政治學     外文  大一英文（一） 德文（一）    修課建議  微積分 → 微分方程、訊號與系統 → 電路學、電子學 → 電子實驗\n微積分 → 機率 → 統計\n數位電路設計 → 數位電路實驗 → 計算機組織 → 作業系統\n離散數學、資料結構、機率 → 演算法 → GPE\n 物理 物理（一）、（二）榮譽班（英文班）  授課老師：電物系 籔下篤史 評分方式：功課 20%、期中 4 x 20% 授課方式：  每次教一個章節，平均一節半就下課放人。上課就投影片唸過，一點點公式推導而已，老師很日本腔，所以大多數人還是選擇自己念。 考試基本上是填充加計算，填充是有點配合題加背公式，百分之九十九考古，計算題半考古半作業吧，反正考古背熟就拿 A 了。 我對這門課真的沒有任何興趣，加上星期五兩節課後來都被我拿去準備專題的meeting，所以上課不是打瞌睡，就是隨便聽聽。大家分數都不錯，所以完全沒調分。很後悔沒有認真背考古題，最後分數淒慘，卻賭一把期末沒退選。下學期決定翹課看簡紋斌的 OCW 就好，加上把考古背好。 結果下學期全部翹課，只去考試。一樣很考古，但計算的比例似乎比上學期重了一些。我真的對物理沒啥興趣，就很乾脆的拿了個 B。    物理實驗（一）、（二）  完全看助教開心來給預報和結報的分數，考驗妳的 Excel 能力，來決定你哪時候下課。我覺得一學分真的投資報酬率低，但因為他會公開每次報告的分數，讓人不由自主花很多時間只為了多拿五分，所以我最後調到 A+。 下學期以光學和電學實驗為主，所以報告相對上學期的力學變得難寫。完全看助教開心來給預報和結報的分數。我期末忘記帶計算機，就爛掉了。 要注意「有效位數」！  數學 微積分甲（一）、（二）（英文班）  授課老師：應數系 符麥克 評分方式：功課 10%、期中 25%、期末 25%、大會考 30% 授課方式：  每週四 inclass homework 開書考 10 分鐘 2 題，每週 homework 課本習題 2 題、老師自己出的 4 題。 老師是奧地利人，英文帶了點德國腔，剛開始聽會超不習慣，加上他的字小且帶個人風格，上課速度很快，所以剛開始會跟不上。個人是認真的把板書抄下來，但這麼做基本上你就很難認真聽懂他在講什麼，所以抄筆記和聽課可能得取捨一下吧！最好還是課前預習一下。 他的期中是偏證明大約 7 題，期末 6 題，計算要快、觀念要熟，和偏計算的大會考真的方向不同。老師會按規定調到平均 79 左右，今年是調 3 分。 下學期計算量較多，不像上學期那麼多證明，期中考比大會考多了osculating plane的部分。大會考爆難，我算了五年的考古，還只拿70，總成績調分滿多的。感覺班上來上課的人比上學期又更少了。    離散數學  授課老師：資工系 楊武 評分方式：功課 15%、期中 40%、期末 40%、平時表現 5% 授課內容：簡單的數論（質數講很久）、集合、數學歸納法、遞迴、排組、鴿籠、Relation。 授課方式：  老師教得很隨性，上課只是抄一抄板書。 偶而會有小考十分鐘兩題，會先提醒，千萬別遲到。小考蠻過分的，不是滿分 10 分就是鴨蛋 0 分。 期中期末，三成考古，和上課內容不會差太遠，滿分超過一百，平均落在 60 左右，最高 99，基本上就是高於全班平均就能拿 A，期末調分超過 15 分。 老師偶而會一直重複上節課講過的東西，記得點醒他，不然他一直講同一型的題目進度很慢。然後他的麥克風雜音超吵，勇者請把它關小聲。個人覺得他還算是個好玩的老師，不過證明有時不太嚴謹，是小小的缺點。    線性代數（英文班）  授課老師：電控 林源倍 評分方式：平時 15%、小考 2 x 10%、期中 30%、期末 35% 上課方式：翻轉教學，回家看 OCW，上課時發作業，大約四大題，四人一組，抽籤上去用英文講解，可以找其他人的 bug 加分。是一門需要有組員 Carry 的課。助教和老師人都很好。 成績：考試大約都是七成基礎定義和計算，三成偏證明，確認是否有把線代融會貫通。認真讀書拿九十分以上不難，雖然我都粗心掉基本分（例如問 row space 我看成 col. space… ），最後就沒有拿到 A+。會調分就是了，而且線代通常對於有些人滿抽象的，所以拿高分的人並不會太多。 啟發：這門課給我的收穫算是還滿大的。首先，我們這個班主要是電資班和電機系的學生，所以算是能和系上同學多多互動，也能認識外系的機會。再來也是養成自己規劃讀書進度的習慣，看影片的速度也能慢慢修正。最後，很重要一點是，能增進用英文上台發表看法的能力，同時也會在過程中不斷練習去找同學解法的 bug。是一門規劃得很不錯的反轉教學，讓我回憶起以前去台大上資芽的過程。  微分方程（英文班）  授課老師：電機 李冕 評分方式：  12 次小考取 10 次平均 期中期末小組報告   授課方式：  不會點名。老師是義大利人，口音不算太難懂。講投影片為主，老師上課會一直點人上台做題。每週小考，一週手寫，一週 Matlab，題目都是從課本出為主，但我覺得題目選得很爛。助教雷雷的，是印度人，我們不太知道怎麼跟她溝通。 期中期末各一個專題，是 3 人小組報告，選一個數學或物理現象用微方解釋。報告會要求解釋物理和數學原理，以及用 Matlab 模擬，還有動手實作的影片，還有放幾個小笑話。期末因為我看到了「Harmonograph」這個主題很有趣，然後剛好懶得找組員，就自己做了，老師給了 100 分，不小心就對到他的胃口了。    訊號與系統（英文班）  授課老師：資工 黃敬群 評分方式：  作業 6 次 40% 期中期末各 30% 一次加分考 5%   授課內容：  LTI System Convolution Fourier Series Fourier Transform Sampling   授課方式：  很早就變成非同步線上授課了，主要是用書商的投影片上課，然後在旁邊手寫補充。 上了不少例題，上課速度偏慢，所以 Laplace 和 Z Transofrm 都沒有上到。 後來覺得自己應該去 YouTube 看陳永平的 OCW 比較有效率。   作業和考試：  作業是每個單元勾課本習題 5~10 題，我自己花了很多時間寫，常常要算 5~15 個小時。原本有說要出 Matlab 作業，但大概就只有一題而已… 考試和作業題目類型有點像，大約 5 題，但還是會有比較不一樣的題目，基本上時間很充裕，不用擔心寫不完，助教給分還算寬鬆。 總分只有調了一分，但作業分數都給很高，所以覺得會比其他班輕鬆。   附註：這是老師第一年在交大開課，因為是英授，所以不到十個人選課，之後也不會再開這門課了。老師人很好，但是我覺得教學上仍有待改進。  機率（英文班）  授課老師：電機 高榮鴻 評分方式：作業 6 次共 20%、期中期末各 40%、加分程式作業一次 授課內容：  高中範圍內容（快速帶過） Independence、Expectation、Variance、Covariance Total Probability Theorem、Bayes’ Rule、Union Bound Discrete/Continuous Random Variable、Transform（Fourier、Laplace、Linear） Markov Inequality、Chebyshev Inequality Weak Law of Large Numbers、Convergence in Probability、Central Limit Theorem Discrete-Time Markov Chain Some Matlab Simulation   授課方式：  純版書，證明定理，然後帶幾題課本例題。 個人覺得期中考前的某些東西教得有點慢，可能是因為很多時間在寫板書。 老師習慣先寫完整個黑板，然後再開始講，但通常抄完黑板後，就大概了解他要講的東西了…   作業和考試：  作業是勾課本上的，通常不到 5 題，難度中等，網路上也可以找到解答。 考試難度也不高，滿分 110，基本上看一份考古，然後稍微看一下上課和作業的題目，考到 90 很簡單。期中考班平均 72，標準差 25，但還是有約三成的人不及格。期末考班平均 77，標準差 24。良心建議考完多檢查，計算過程要寫多一點點，分數會比較好看。   附註：不知道是因為疫情，老師沒有給加簽的名額。個人對這門課沒有太多的感覺，只覺得要拿學生證簽名點名很煩，然後神奇的是考試時反而沒檢查學生證。總成績感覺是沒有調分，也完全不知道點名到底有沒有分數。  資工 - 程式 計算機概論與程式設計（英文授課）  授課老師：資工系 張永儒 Stanley 評分方式：  Lab、HW 各佔 20%，有 demo 就滿分。 期中筆試上機各 12.5%。 期末專題，書面計畫和最終書面報告各佔 8.75%，demo 佔17.5%。   授課方式：  上課都用投影片，偶爾會開 IDE 打幾行程式，但 bug 一堆。前 8 週上 C，但作業我還是偷用 C++寫，進度跳很快，我原本就會寫了所以沒認真聽，其他人大部分就 Lab 時間找大神救，投影片內容很豐富。   考試方式：  期中分為選擇和上機，選擇我們這些原本就會寫程式的人大概可以拿 90～100，滿分大約 110，可以 openbook，所以不少人印前一年的考古題，拿滿分，換句話說，完全考古嘔死你。 上機四題選三題，我是拿 95，賽後人工評測，寫不出來寫註解也有分，但那天好死不死，想提早交時當機，只好換一台重打一次，快被系計中的冷氣凍死，難度大概不當機一小時打完收工。   期末專題：  後面幾週教 python，有教到爬網站、BeautifulSoup、正規表達式等東西。 期末專題就是要用「一個爬網站 + 兩個 API」，湊出一個實用的東西。我是用 openCV，但它不用傳 key 之類的東西，導致我分數沒有預期的高，這點可以注意一下，原本有打算加臉書的 API，但它的權限真的很難搞，反正有創意、難度高、實用性都兼顧到應該分數可以到 95 以上。    物件導向與資料結構（英文班）  授課老師：資工 黃世強 評分方式：  不調分，真的有不少人被當。 Lab 10%：  基本上會前一天就放上 e3，所以大多數人都滿分   程式作業 10% x 3：  給一些老師寫好的 project 挖空，需把一些重點函式填上，主要是用 OpenGL 的方式呈現，但這部分不需要理解。 我自己寫起來大致上每次需要花 10~20 小時，通常會給一個月左右的時間完成。   期中上機 15% x 2：  可帶紙本資料，第一次需要熟悉基本的 OOP 語法，第二次需要會寫一些基礎的資料結構（BST之類的）。 第一次爆簡單，結果第二次就很難，據說第二次平均低於 40。   期末筆試 20%：  我這學期成績爆掉的主因，上機和作業都有拿到 90 以上，但忘記筆試佔很重，只考了 60 幾 QQ 除了基礎的 OOP 和資料結構外，上課有教到的檔案處理和除錯用的語法也要背。   期末上機 10%：  從三次作業去改，可從 e3 上下載作業去改，拿 100 不難。     感想：  老師是香港人，所以英文有點口音。 上課進度我有點不喜歡，前三週都在複習計概教過的東西（迴圈、陣列、指標），然後資料結構的部分，紅黑樹也只講到定義而已，前面一些基礎的資料結構都重複上好幾次，但每次都講得亂亂的，我覺得自己在上課學會的東西極少。 功課的部分算是培養我們寫大型專案的能力吧，但有些註解及說明資料寫得不夠具體，變數的名字好像讓我誤解了不少，讓我實作上花了很多時間。   附註：  上機考的部分公平性極低，出場後補交可拿到 60 分。而且抄襲應該也沒有抓得很認真。 成績往往都是好幾週後公布，有可能超過退選截止日期。 沒有筆電或沒灌 windows 建議不要修，因為功課需要用 vs，不然就得像我一樣窩在計中一整天。然後 vs 老師不知道為什麼不採用 2007 版，造成大家寫功課時花了很多時間把環境搞定。第一次作業時，我因為計中電腦無法用 vs2007 開作業的檔案花了很久嘗試，計中助教也花了幾天才把問題解決。    基礎程式設計  不用上課，只要去考 GPE。 一個學期可以考很多場，但每場有人數限制。總共 6 題，3 小時。 這門課沒有過的話，會擋修專題和一些實作類課程，所以早點考一考比較好。 有提供官方題庫，內容以 UVA 題目為主，但是測資品質普遍沒有 UVA 好。建議考前先熟悉系統，能用的語言就只有 C/C++、JAVA，沒有 Python。 難度每次有些落差。雖然只要通過 2.4 題（大概就是有一定的實作能力，拿完部分分就有的分數，不用會太多演算法或資料結構），但聽老師們建議為了讓成績單上成績好看，不要影響到升學、就業等等，就算 0 學分不列入 GPA，還是要考高一點。  資工 - 硬體、底層 數位電路設計  授課老師：資工系 范倫達 評分方式：小考20%、期中兩次25%、期末30% 授課內容：內容是課本 1～7 章，算是不需要什麼基礎知識，從邏輯二進位教到 latch、flip-flop、counter，會帶一些 verilog，但不需要上機，只要看得懂就好了。 授課方式：上課都是用投影片，上課速度時快時慢。小考和期中期末以課本題為主，有練拿 A+ 很簡單，小考是前一週的範圍。老師人很好，很愛關心學生。  數位電路實驗（英文班）  授課老師：資工 范倫達 評分方式：  Lab 10 次取 8 次 40% 期中上機 20%、期末上機 20% 期末小組專題 20%   授課方式：  不會點名。作業每週一晚上 demo，10 天前公佈。基本上上課內容以硬體架構為主，講了一些 FPGA 的東西，還有合成的過程，會有幾堂請業界的人講課，但我真心覺得聽課很無趣，且對作業幫助不大。 打分數全由 TA 負責，TA 主要是前一年的修課學生。 期中上機剛好是我高二用 Arduino 寫過的東西，所以就拿了 100 分。期末則出 UART，剛好那次Lab碰上日本比賽，所以沒寫，之後沒補，只帶了同學的模板，電腦剛好選到一台無敵爛的，就考 0 分。總之，上機跟選電腦的運氣成分有很大關聯。 FPGA 不能帶出實驗室，環境 Vivado 不支援 mac，所以每次都得去實驗室做，後來幾次幾乎都寫超過 10 小時，很崩潰。 專題最後我組員退選退光，於是我就一個人做，大概弄了 25~30 小時。期末成績因為調分有拿到A+。 板子是用 Arty，有遇過有錢的同學自己買一個玩，就不用假日窩在實驗室合成了。畢竟到後面有時候燒一次就要 20 分鐘，這時候建議多霸佔幾台電腦，這樣就可以同時跑很多版本的 code 了（應該沒有人像我一樣這樣節省時間的吧）。   課程內容：  Lab1 乘法器 Lab2 ALU Lab3 矩陣乘法 Lab4 Button \u0026amp; LED Lab5 LCD Lab6 UART Lab7 矩陣乘法(用 SRM，空間優化) Lab8 SD card Lab9 暴力解MD5（用 Pipeline，時間優化） Lab10 VGA 顯示 期末專題 VGA 小遊戲 2 選 1（貪吃蛇、皮卡丘打排球）    計算機組織  授課老師：資工 蔡文錦 評分方式：  我討厭 Verilog 所以選了 B Plan A  考試 20% * 3 小考 20% Verilog HW 20%   Plan B  考試 25% * 3 小考 25%     課程範圍  Ch 1: Computer Abstractions and Technology Ch 2: Instructions: Language of the Computer Ch 4: The processor Ch 3: Arithmetic for Computers Ch 5: Memory Hierarchy Ch 6: Multiprocessor   覺得教得很清楚，讓我沒那麼討厭計組了。重點主要放在第四章。第五、六章和 OS 重疊率很高。  作業系統概論  授課老師：資工 吳育松 評分方式：  大考 2 x 30% 作業 4 x 10%  HW1 Multitasking: Python HW2 Memory: C, Linux HW3 File System: Linux cmd HW4 Meltdown: Linux cmd     授課方式  用投影片上課，但投影片很多有的沒的東西，不容易抓到重點。 覺得很催眠的一堂課，只好自學。 作業覺得沒學到太多東西。 期中期末平均都 60 幾，學期分數調了 7 分左右。    資工 - 計算理論 基礎圖論  授課老師：應數系 傅恆霖 評分方式：期中40%、期末60%，滿分約115左右，不調分。 授課方式：老師人超好，因為開在早八，所以會晚十分鐘開始上課（我下堂還有課，結果就因為晚下課搶不到位子），有時會在開始上課前給早到的講點小故事。內容還算滿豐富的，上課全是板書，老師的字大小適中且整齊，上課速度也不會太快，老師手寫筆記和考古題也會公開到網路上。 授課內容：主要是簡單圖為主，從圖的定義，到一些基本性質，還有介紹一些經典問題，尤拉路徑、中國郵差問題、七橋問題之類的，最小生成樹、最短路徑的演算法也有提一下下，最大流最小割，四色定理等等。 會選這門課，主要是因為系上開的離散數學完全跳過圖論這塊，加上以前聽過很多上述的經典問題，卻都不太清楚證明，想說不需要什麼基礎就修修看。 考試內容：以上課範圍為主，證明和定義要記清楚，還有一些簡單的構造題，平常上課聽之外，還需要考試前念一點書。老師偶爾會出作業，寫出證明的話，直接總成績加一分，不過我都在忙東忙西，就都沒有寫了。  演算法概論（英文班）  授課老師：資工 蔡孟宗 評分方式：max ( (2 max(A + B) + min(A, B) + C + D) / 5, 99)  A. 3 次手寫作業 + 2 次小考 B. 3 次程式作業(5題) + 2 次上機 C. 期中筆試 D. 期末筆試   不會點名，某程度上不會被當的課，大神很容易刷分的課，修到 A+ 不難，拿 99 也不無可能，因為每次作業考試都滿分 125。 程式作業和考試題目質感高，手寫作業和筆試難度略高，但基本分很好拿。上課是投影片，老師自己做的，所以品質很好。會先英文授課 7 成的時間，然後再用中文講一次。 該上的內容都有上，還會自己加一些好玩的題材，像是隨機演算法、近似演算法，還有 Treap、Quake heap 這種比傳統的紅黑樹和費波那契堆好實作且好懂的平衡樹。  隨機演算法（英文班）  授課老師：清華 韓永楷 評分方式：5作業（最低 2.5%，其他 37.5%）、3考試60% 授課內容：  Basic Probability, Discrete Random Variable Verify Matrix Multiplication Random Min-Cut Random Median Poisson Trial Markov Inequality, Chebyshev Inequality, Chernoff Bounds Balls and Bins Probability Methods Markov Chain   課程資料 授課方式：  板書。老師是香港人，但口音聽久就習慣了。 老師人很好，會問大家問題，答錯沒關係。上課氣氛非常愉快，然後不需要太多基礎，可能會一點離散數學就夠了。 這門課大概讓我喜歡上了機率，然後機率變得滿熟悉的 XD   附註：加簽沒上限？  高等演算法  授課老師：資科碩 蔡孟宗 評分方式：小考 5 x 20% 授課內容：Graph Orientation, Color Coding, Connectivity, Spanner, Decomposition, Cuckoo Hash, Monge Matrix, Matroid, Submodularity, Epsilon Net, Derandomization, Distributed Algorithm, Streaming Algorithm, Dynamic Algorithm, …… 連續上兩個多小時有點累以外，其實滿喜歡這門課的。每個星期都花不少時間複習，但考試就是難到 Open Internet 還是寫不出來。不知不覺就在一學期學了很多東西，算是看到更廣闊的世界……？用到不少機率，所以現在看到再多機率都不怕了 www  資工 - 其他選修 競技程式設計（一）、(二)、（三）  授課老師：謝旻錚 算是競賽用演算法課吧，因為這年有勾題目，所以大家期中期末都比往年高。這學期放了很多假，因此課程的內容比預期少了不少。 很開心在競程一找到 ICPC 的隊友。 競程二是要在任一場比賽打敗清大第四名或台大第六名的隊伍才能 PASS。競程三就只要賽季時一週練 10 小時就解決了。  人工智慧概論  授課老師：資工 王才沛 評分方式：  原本  程式 50%（個人3次小組1次） 大考＋小考＋手寫作業 50%   實際  手寫作業 2% x 3 小考 2% x 2 段考 23% x 2 個人程式作業報告 13% x 2 小組程式作業報告 10% ＋對戰排名 8％ 點名額外加分 1% x 2     授課方式：平常上課以投影片為主。主要是以概論的方式來上。  介紹 AI 的大致種類。 State Space Search：有教基本的 DFS、BFS、A*、IDA* 等。 Constraint Satisfaction Problem：教 AC3、MRV、LCV、Degree heuristic、Forward checking 等。 Adversarial Search：以 0-sum 遊戲為主介紹，教 Min-max pruning、MCTS 等經典算法。 介紹 Learning 的種類：介紹 Learning 相關的概念（Bias-Variance Dilemma、Cross validation等）。 Supervised Learning：教 Decision Tree、CART 的具體實現，神經網路相關的概念、SVM。 Unsupervised Learning，k-means、SOM、VQ 等算法簡介。 Reinforcement Learning：Q-Learning 為主、TD。 Logic：Propositional Logic、First-Order Logic 這兩種，結合了一些Searching 類的演算法。   其他：  手寫作業和小考段考題型都是一樣，投影片讀熟應該考個 90 是沒問題的，但我期中題目沒看仔細，分數跌了不少。 個人程式作業以報告評分，大致描述實踐分法、實驗結果就行了，以 C++、python、java、matlab 都行，小組作業就限 C++ 和 python。 第一次程式作業是給幾個圖及 3000 個單字，用 AC3、Forward checking 等算法，選幾種去寫，去完成填字遊戲。我自己大約寫了 350 行的 C++，把有教的東西都實踐出來，Forward checking、AC3、Degree hueristic、MRV 都有做效果還不錯。 第二次程式作業是實作 Random Forest，可以直接用網路上別人寫好的 code 去改，但我還是選擇自己寫一個出來，也是用 C++寫了 350 行左右，花了很多時間，但一開始對於attritbute bagging的部分理解錯了，到最後一天才在重寫，資料就沒有跑很多，但報告不知道為什麼還拿滿高分的。 整體來說很吃寫實驗報告能力，但因為有修過物理實驗，所以這部分就還算能抓個方向，加上一些專題 meeting 時訓練出的做圖表能力，所以報告都拿 90+，助教給分的 Range 從 50~98 都有，這部分電資班的成績普遍比資工系的高，顯然物理實驗和專題對寫報告的能力增進不少。看了一下同系學長姐的成績，似乎程式不怎麼樣，但報告卻拿很高就是了，所以修這門課好像寫報告能力重於程式能力。 小組作業是 1~3 人一組，針對 Game 那個單元出一個對戰作業，給定一個黑白跳棋的規則（四方棋盤，可以跳或是直接走一步，跳過對方棋子可以吃掉，看遊戲結束時到對面的棋子數量決定勝負）。總共 51 組，我們拿第 7 名，我們是大概以兩步的結果去評估，加上一些 hueristic 的調整。其他朋友則是真的去做 min-max 和 MCTS 之類的實踐，普遍成績都不錯，我在 PCCA 的隊友，也是同門課中和我唯二的大一生，好像用這個方法拿到第一名。    資料庫系統概論  授課老師：資工系 彭文志 評分方式：由於疫情，調整成只有作業和期末專題，在討論區發言或回答同學問題能加分。 授課方式：修課人數很多，開學就用 Microsoft Teams 遠端，沒上過實體課，原本是一週三堂課，但因為改成線上就只有兩堂。講投影片，投影片的份量有點重，可能因為是線上的，所以覺得老師講起來沒什麼吸引力。加上有時候還沒敲鐘就開始上，前面常常沒聽到，後面就跟不上。 作業：我退掉這門課的原因。HW1 我就決定退選了，因為助教給了一份 LOL 的遊戲紀錄，然後搞不懂規則，加上第一次學 mySQL 的狀態下，實在不想在期中考月花時間寫作業，寫了 8 小時左右就放棄了。聽說總共出了四份作業，然後期末專題是三人一組，寫一個應用程式或網頁之類的（類似口罩地圖之類的），主題自訂。據說總共有 4 次 HW，第二次是 B+ Tree，後面我就不清楚了。 原本期末專題找隊友兩人一組，他還很認真的陪我寫作業。但因為那陣子忙著算係好與系統，還有讀專題的東西，於是最後就早早停修了，至少不會拖累他。總之，這是一門每年都上靠北交大的課，請慎選，個人覺得今年似乎比往年少一點點雷了。  電機 電子學（一）  授課老師：電工 陳龍英（已逝） 評分方式：3次大考100%、作業一次1%、點名加分 雖然老師是電子學名師，但真的老到講話有氣無力，上課常常東跳西跳，品質據說比以前低。我對這門課真的沒興趣，加上很早就發現跟老師對不到拍，於是很果斷的開始翹課 。 第一次期中剛好在 NCPC 完，比完賽隔天病懨懨沒空讀書，於是只讀了第一章就上場考試，然後就低於 40 分。最後去日本比賽完，發現沒空準備第二次期中，就果斷退選了。  電子學（一）（英文班）  授課老師：電子 吳介琮 評分方式：六次考試 課程網站 需要自己先預習課本作者 Razavi 的影片，和其他班用的 Smith 課本不一樣。 老師教的很好，考古題也都有給，但課本實在太少人用了，連解答都找不到，所以也不好準備。三週考一次試實在來不及準備。  電子實驗（一）  授課助教：電工 陳建安 評分方式：  小考 8% 結報 24% 專題 26% 實驗 26% 期末考 20%   課程網頁 授課內容：基本儀器操作（示波器、電源供應器、訊號產生器、三用電錶）、基本元件（電阻、電容、電感、二極體）、LTspice。 授課方式：  無故缺席兩次會被當，請假要補做。每週上課要先小考，要先看影片預習。小考結束助教會講解實驗內容，要在10點半前做完，大多數人為了早點離開，會直接開始做，不聽助教說明。 專題就是有焊接的部分，分別是直流供電器、音源播放器，但美觀完全不影響分數。期末考實驗內容和電子電路學知識大概一半一半，所以我拿41分（平均48）。 結報雖然我什麼都不會，但寫認真點，也能拿到70分（平均66）。小考平均也70左右，所以就算不會電子電路學，認真預習，不要翹實驗，照著規則，基本上很難被當，雖然有可能是電工系有些人太混。 實驗做不完想繼續完成，或是有事請假，可以跟助教約平日下午補做。    電路學（英文班）  授課助教：生醫 蔡德明 評分方式：  小考 15% 作業 10% 大考 25% x 3 期末專題加分   課本：Fundamentals of Electric Circuits, 7th  作業是從最新版的課本出，但可以跟助教借課本拍照。 Exam 1: 1, 2, 3, 4, 5, 6 Exam 2: 7, 8, 9, 10 Exam 3: 11, 13, 14, 15, 16   授課內容：  KCL, KVL, Nodal Analysis, Mesh Analysis Theorem: Norton, Thevenin, Superposition, Source Transformaion op-amp, Capacitor, Inductor First/Second-Order Circuit Phasor Magnetically Coupled Circuits Frequency Response, Bode Plot Laplace Transform   授課方式：  每個章節會出一次作業，作業會公布詳解。 交作業時會小考，小考只有一題，通常不難，考完會馬上講解。 講解的很清楚，覺得可以只要會一點微積分就可以了，但有學過線性代數、微分方程、訊號與系統，應該會比較有概念。 整個學期大致上是從 t-domain, w-domain, s-domain 去認識電路。 上課時會講很多範例，老師強調應該要先把觀念搞懂再寫作業，作業是用來檢驗自己是否有熟習觀念，不應該一邊寫一邊翻課本。 老師英文語速不快，私下聊天時可以跟他用中文，很鼓勵學生跟他聊職涯相關問題。 每次大考都有提供補考，但最高只能 60 分。 週二晚上會有一個小時的助教課，助教會選和作業相似的習題演算，助教們人都很好，偶而可以跟他們聊天。    通識 校基本 - 疾病知識與防治  授課老師：黃元惠（新竹台大醫院的外科醫生） 評分方式：上課參與與發問 30%（全勤80，問一次約加 2分）、分組討論報告 20%、個人書面報告 20%、期末考 30% 上課是用投影片，老師非常認真回答同學問題。就算你高中不是三類組，也保證能聽得懂。 一學期大概點三次名，會挑人數有點少又不會太少。 報告最好不要第一組，你比較知道準備方向，五個人一組其實負擔很小，小心不要遇到很雷的人就是了。個人和分組報告都是自己選擇主題，很自由，書面報告大約期末倒數第三週交。 期末筆試，可用網路查，兩題申論，一題會是和上課內容有關「冬天需注意的疾病、防治方法」，一題時事題「同婚公投」。反正不翹課應該就能拿 80 分以上，算是甜了。  校基本 - 幾何造型  授課老師：陳明璋 評分方式：隨堂作業 8 次 65%、期末作業 25%、作業每次超過 90 分 + 0.9%、85分 + 0.5% 作業會分成課堂操作歷程呈現的部分，還有課後自己練習及成品彙整的部分（5頁以上）。老師作業改得有點慢，所以我有些做的不錯的圖放在歷程的部分，而不是放在彙整的部分，老師就沒有仔細留意，作業分數就落在 87 左右，因此沒到 90 很虧。 課堂上由老師帶著做一遍，用老師研發的 AMA 軟體（PPT外掛）進行造型繪製。內容包含對稱、碎形、錯覺等等，上課教的很扎實，設計的過程不只對圖形構造的方法更了解，也能學到如何利用工具提升自己的工作速度，避免一再重複一樣的操作，是一門滿有意義的課。老師準備要退休了，真難過。 期末專題是以繪本的方式呈現，至少 25 頁，我做了大約 30 小時，但最後總成績卻還是 A 而已。平常的作業我花的時間大約 5 小時，但認識某資工大神每次花 10 小時做作業，自認不如人家。  校基本 - 統計方法與資料分析  授課老師：唐麗英 網路課程很涼，給分很甜。 有三堂面授，有小組報告，每堂老師都會遲到。 考試可以帶小抄，期中期末各一。  校基本 - 認識語言  授課老師：  上半學期：盧郁安 下半學期：周昭廷   評分方式：  上半學期  課堂參與 15%：每堂課結束會玩 Kahoot。 作業 15%：Praat、\u0026hellip; 期中影片 30%：選一個主題做「60 秒懂 xxx」   下半學期  下課前 Kahoot 小考 2% x 8 Google 表單小考 2% x 7：每週會給一篇文章回去閱讀、題目也會先公布 期末報告 20%：5 important ideas in the course 每週可針對閱讀或語言學提出一個問題 0.5% 上課回答問題 0.5%     上課內容  上半學期：聲音的結構與測量、發音部位、語言感知、句法學\u0026hellip; 下半學期：認知科學、Universal Grammar、母語的學習歷程、嬰兒的認知能力、Finite State Grammar\u0026hellip;   上半學期的內容著重在音韻學，但也有上到一些句法學，期中專題一半的分數是同學互評。下半學期很有趣，是以認知科學的角度去認識語言學。 上半學期有一次上課會用「沙拉油＋活性碳」去塗在舌頭上，做顯影觀察發音的位置。 算是偏涼和甜的課，但可以學到很多東西。  跨院 - 統計學  授課老師：彭南夫 評分方式：小考 15% x 2、期中期末各 35% 不會點名。上課基本上就是投影片唸一唸，每個章節至少重複講 2 次。 因為是電機系開的，所以沒講數學證明，讓我很失望，就不太上這門課了。 考前會出作業，會讓助教講解，但不收作業。考試是 openbook，有些人會有考古題抄上去，於是就 95 以上。但我有些計算錯誤之類的，分數就被扣一半掉了，於是總成績只拿 C。  核心社會 - 政治學  授課老師：胡志光 評分方式：出席 10%、上台報告 10%、期中考 30%、期末考 30%、期末書面報告 20% 用書：《政治學與台灣政治》，建議一定要準備一本，清大人社圖書館有幾本。 授課方式：用書商的投影片，但會在口頭補充一些東西。上課老師會點同學回答問題當點名，一學期大概被點到三次左右。每週上一個單元，有些單元內容不多，甚至會提早一堂課下課。 考試：有些名詞定義，還有一些閱讀題，考運用了什麼政治學觀念。老師統計後，大家考前準備時間平均是 7 小時。認真聽課應該就會知道哪些地方是重點，雖然我到考試時就把前一天讀的東西忘光了，讀工科讀久了就忘記怎麼記背科了。老師說只要期末考比期中考進步，就不太會當掉你。 上台報告：10 分鐘左右，報告一則國內時事，只要準備新聞網址，說明為什麼是政治的新聞，政治主要就是兩群人的衝突，這個部分有抓到應該都不會太差。報告日期是自己選，建議選中間偏前面，愈早報吿老師要求愈低。 期末報告：選一則解嚴後的國內政治事件，寫 2000 字的書面報告，一半的篇幅敘述事件，另外一半用課本中的政治學概念做分析。在最後一個月，老師會點同學確認報告主題。班上滿多人選年金改革、同婚、公投、土地徵收等近幾年的時事。本來有想選大巨蛋案當作題目，但是老師說後來的發展都很陰謀論，所以就聽老師的建議換主題了。繳交時間訂在期末考後下一週，感覺還算友善。 原本是聽隊友建議選了這門課當作核心向度的通識，聽他說上課都在聽故事，不會太累，考試不難分數也還可。但後來才知道他是指兩學分的政治學 QQ  外文 大一英文（一）  授課老師：吳思葦 評分方式：出席10%、課堂學習單和平時加分30%、期中20%、期末20%、課堂寫作5%、GEPT 10%（一次課堂三次線上）、VOD 5%（去圖書館三樓語言中心 5 次） 以聽力為主，口說次之。絕對不要翹課或請假，分數會差很多。上課還算輕鬆，功課大約 15 分鐘就可以寫完。期中是考聽力，期末是一組三人，十分鐘的對話要背稿。整體來說投資報酬率不高，要拿 90 以上有點難，完全沒調分。  ","date":"2021-01-31T11:00:15+08:00","permalink":"https://Luke2336.github.io/p/course_nctu/","title":"交大修課心得"},{"content":"早上去吃早餐，順便摸了小黑白。\n刷了一些 Zerojudge 的水題。\n e948 e968 e926 f070 f345  更新了修課心得。\n傍晚去餵小乖，順便跟廟旁邊的小貓玩。\n晚餐吃了魚，還有卦菜雞。\n有點進入放假倦怠期\u0026hellip;\nKattis - Firefly 1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt;3using namespace std; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 int n, h; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h; 7 vector\u0026lt;int\u0026gt; a(n); 8 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 9 vector\u0026lt;int\u0026gt; even(h + 1), odd(h + 1); 10 for (int i = 0; i \u0026lt; n; i += 2) 11 even[a[i]]++, odd[a[i + 1]]++; 12 for (int i = h - 2; i \u0026gt;= 1; i--) 13 even[i] += even[i + 1], odd[i] += odd[i + 1]; 14 int ans = n, cnt = 0; 15 for (int i = 1; i \u0026lt;= h; i++) { 16 int sum = odd[h - i + 1] + even[i]; 17 if (sum \u0026lt; ans) ans = sum, cnt = 1; 18 else if (sum == ans) cnt++; 19 } 20 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 21 return 0; 22}  ","date":"2021-01-31T10:17:31+08:00","permalink":"https://Luke2336.github.io/p/20210131/","title":"2021/01/31 日記"},{"content":"一早沒吃東西就直接搭車回基隆，回到家後睡了一覺。\n午餐吃了餛飩湯和乾麵，看完了神偷卡門。\n去公園看了貓，只有遇到小黑白，結果有兩個小屁孩一直追她。\n晚餐去瑞芳吃了米苔目，飯後吃了燒麻糬，回到家喝了杯梅酒就去睡了。\n","date":"2021-01-30T16:29:26+08:00","permalink":"https://Luke2336.github.io/p/20210130/","title":"2021/01/30 日記"},{"content":"Codeforces 10 D. LCIS dp[i][j] 為 a[1\u0026hellip;i], b[1\u0026hellip;j] 結尾為 b[j] 的 LCIS 的長度。\n$$dp_{i, j} := \\begin{cases} \\max_{p \u0026lt; j, b_{p} \u0026lt; b_{j}} dp_{i - 1, p} + 1 \u0026amp;, a_{i} = b_{j} \\\\ dp_{i - 1, j} \u0026amp;, \\text{otherwise}. \\end{cases}$$\n複雜度：O(nm)，n, m 為兩序列長度。\n1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt;3using namespace std; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 // INPUT 7 int L[2]; 8 vector\u0026lt;int\u0026gt; v[2]; 9 for (int i = 0; i \u0026lt; 2; i++) { 10 cin \u0026gt;\u0026gt; L[i]; 11 v[i].resize(L[i] + 1); 12 for (int j = 1; j \u0026lt;= L[i]; j++) 13 cin \u0026gt;\u0026gt; v[i][j]; 14 } 15 // LCIS 16 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(L[0] + 1, vector\u0026lt;int\u0026gt;(L[1] + 1)); 17 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; par(L[0] + 1, vector\u0026lt;int\u0026gt;(L[1] + 1)); 18 for (int i = 1; i \u0026lt;= L[0]; i++) { 19 int p = 0; 20 for (int j = 1; j \u0026lt;= L[1]; j++) { 21 if (v[0][i] == v[1][j]) { 22 dp[i][j] = dp[i - 1][p] + 1; 23 par[i][j] = p; 24 } else { 25 dp[i][j] = dp[i - 1][j]; 26 par[i][j] = j; 27 if (v[0][i] \u0026gt; v[1][j] \u0026amp;\u0026amp; 28 dp[i - 1][j] \u0026gt; dp[i - 1][p]) 29 p = j; 30 } 31 } 32 } 33 // BACKTRACKING 34 int p = 0; 35 for (int j = 1; j \u0026lt;= L[1]; j++) 36 if (dp[L[0]][p] \u0026lt; dp[L[0]][j]) 37 p = j; 38 vector\u0026lt;int\u0026gt; ans; 39 for (int i = L[0]; i \u0026gt; 0; i--) { 40 if (v[0][i] == v[1][p] \u0026amp;\u0026amp; p != par[i][p]) 41 ans.push_back(v[0][i]); 42 p = par[i][p]; 43 } 44 cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 45 for (int i = ans.size() - 1; i \u0026gt;= 0; i--) 46 cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[!i]; 47 return 0; 48}  ","date":"2021-01-29T12:05:24+08:00","permalink":"https://Luke2336.github.io/p/lcis/","title":"Longest Common Increasing Subsequence(LCIS)"},{"content":" 弄了寒訓的題單，研究了 LCIS。 研究轉系，發現歷年轉入資工大三的人極少。推測可能是因為需要修完必修，而必修不好加簽？ 晚上跟導師和師母去靠近東門那區吃飯。 飯後洗了衣服，又收拾了東西。 看完了甄嬛傳，順便補了一下夜叉姬的進度。  Codeforces 180 C. Letter 寫這題才發現 isupper() 不是回傳 0 或 1。\n1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt;3using namespace std; 4inline bool up(char c) {return isupper(c);} 5inline bool low(char c) {return islower(c);} 6int main() { 7 ios::sync_with_stdio(0), cin.tie(0); 8 string s; cin \u0026gt;\u0026gt; s; 9 int len = s.length(); 10 vector\u0026lt;int\u0026gt; dp[2]; 11 dp[0].resize(len), dp[1].resize(len); 12 dp[0][0] = low(s[0]), dp[1][0] = up(s[0]); 13 for (int i = 1; s[i]; i++) { 14 dp[0][i] = dp[0][i - 1] + low(s[i]); 15 dp[1][i] = min(dp[0][i - 1], dp[1][i - 1]) + up(s[i]); 16 } 17 cout \u0026lt;\u0026lt; min(dp[0][len - 1], dp[1][len - 1]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 18 return 0; 19}  筆記 - 近世代數 ","date":"2021-01-29T12:03:58+08:00","permalink":"https://Luke2336.github.io/p/20210129/","title":"2021/01/29 日記"},{"content":"早上洗個澡後，中午去隊練，結果 LinLee 又遲到一小時，真是的！\n晚餐吃了烤雞和冰淇淋，覺得很開心。 之後因為練習很累就早睡了。\n隊練 今天和 LinLee 和 LnadyLu 進行對練，打了 CF GYM 102785 - ICPC Central Russia Regional Contest (CRRC 18)。\n我寫了 pB，還有想了 pG 的轉移式。我很早就想出 pG 的狀態，LinLee 幫我想了轉移時的複雜度，不過要處理運算式很麻煩就是了，於是交給 LandyLu。\nLandyLu 自己解了不少偏向找規律的題目。\n   Problem  Solver     A 水題 LinLee   B BFS Kelly   C String LinLee   D     E Math Landy   F     G DP, String Landy, LinLee, Kelly   H 構造 Landy   I     J DP LinLee   K      pB. Gremlins attack!  題意：有 m 個人，及依序關 k 盞燈。人只能走在有關燈的地方，問最少要關幾盞燈時，至少有一個人能走到邊界？ 解法：BFS＋priority_queue，答案為走到邊界的路徑上，最大編號的燈。  1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt;3using namespace std; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5typedef pair\u0026lt;int, pii\u0026gt; piii; 6#define pb push_back 7int dx[4] = {1, -1, 0, 0}; 8int dy[4] = {0, 0, 1, -1}; 9int main() { 10 ios::sync_with_stdio(0), cin.tie(0); 11 int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; 12 int a[505][505], dis[505][505]; 13 memset(a, -1, sizeof(a)), memset(dis, -1, sizeof(dis)); 14 priority_queue\u0026lt;piii, vector\u0026lt;piii\u0026gt;, greater\u0026lt;piii\u0026gt; \u0026gt; pq; 15 for (int i = 0; i \u0026lt; m; i++) { 16 int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; 17 a[x][y] = dis[x][y] = 0; 18 pq.push(piii(0, pii(x, y))); 19 } 20 for (int i = 1; i \u0026lt;= k; i++) { 21 int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; 22 a[x][y] = i; 23 } 24 while (!pq.empty()) { 25 int x = pq.top().second.first; 26 int y = pq.top().second.second; 27 pq.pop(); 28 if (x == 0 || y == 0 || x == n - 1 || y == n - 1) { 29 cout \u0026lt;\u0026lt; dis[x][y] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 30 return 0; 31 } 32 for (int d = 0; d \u0026lt; 4; d++) { 33 int xx = x + dx[d], yy = y + dy[d]; 34 if (xx \u0026lt; 0 || xx \u0026gt;= n || yy \u0026lt; 0 || yy \u0026gt;= n) continue; 35 if (a[xx][yy] == -1) continue; 36 int tmp = max(a[xx][yy], dis[x][y]); 37 if (dis[xx][yy] == -1 || tmp \u0026lt; dis[xx][yy]) 38 dis[xx][yy] = tmp, 39 pq.push(piii(dis[xx][yy], pii(xx, yy))); 40 } 41 } 42 return 0; 43}  pG  題意：給定一個 n 以及一個布林運算式，此運算式會定義連續十個以內的位元的函數，求有多少個長度為 n 的 01 字串使得任意子字串都符合此運算式。 解法：枚舉長度及最後十位的狀態，因為每個狀態接下來只會補 0 或 1，所以轉移是 O(1)，狀態共 O(2^{10} n)。打表預處理每個狀態是否合法。  1#include \u0026lt;bits/stdc++.h\u0026gt;2#define int ll 3using namespace std; 4#define vt vector 5#define sz(x) int((x).size()) 6#define all(x) (x).begin(), (x).end() 7#define rall(x) (x).rbegin(), (x).rend() 8#define fi first 9#define se second 10using ll = long long; 11using pii = pair\u0026lt;int, int\u0026gt;; 12const ll MOD = (ll)1 \u0026lt;\u0026lt; 60; 13int n, p; 14string s; 15int eval(int x) { 16 int neg = 0, val = 1; 17 char op = 0; 18 while (p \u0026lt; sz(s)) { 19 if (isdigit(s[p])) { 20 int next = ((x \u0026gt;\u0026gt; (s[p] - \u0026#39;0\u0026#39;)) ^ neg) \u0026amp; 1; 21 neg = 0; 22 if (op == \u0026#39;\u0026amp;\u0026#39;) val \u0026amp;= next; 23 else if (op == \u0026#39;|\u0026#39;) val |= next; 24 else if (op == \u0026#39;+\u0026#39;) val ^= next; 25 else val = next; 26 p++; 27 } else if (s[p] == \u0026#39;(\u0026#39;) { 28 p++; 29 int next = (eval(x) ^ neg) \u0026amp; 1; 30 neg = 0; 31 if (op == \u0026#39;\u0026amp;\u0026#39;) val \u0026amp;= next; 32 else if (op == \u0026#39;|\u0026#39;) val |= next; 33 else if (op == \u0026#39;+\u0026#39;) val ^= next; 34 else val = next; 35 } else if (s[p] == \u0026#39;)\u0026#39;) { 36 p++; 37 return val; 38 } else if (s[p] == \u0026#39;-\u0026#39;) { 39 p++, neg ^= 1; 40 } else { 41 op = s[p++]; 42 } 43 } 44 return val; 45} 46void solve() { 47 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; 48 int k = 0; 49 for(char i = \u0026#39;9\u0026#39;, flag = 0; i \u0026gt;= \u0026#39;0\u0026#39;; i--){ 50 for(char j: s){ 51 if(i == j){ 52 k = i - \u0026#39;0\u0026#39;; 53 flag = 1; 54 break; 55 } 56 } 57 if(flag) break; 58 } 59 vector\u0026lt;int\u0026gt; tb(2 \u0026lt;\u0026lt; k); 60 for (int i = 0; i \u0026lt; (2 \u0026lt;\u0026lt; k); i++) { 61 p = 0; 62 tb[i] = eval(i); 63 } 64 int rolling = 1; 65 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(2, vector\u0026lt;int\u0026gt;(1 \u0026lt;\u0026lt; (k + 1))); 66 for(int i = 0; i \u0026lt; (2 \u0026lt;\u0026lt; k); i++) 67 dp[not rolling][i] = tb[i]; 68 for(int i = 0; i \u0026lt; n - k - 1; i++){ 69 for(int j = 0; j \u0026lt; (2 \u0026lt;\u0026lt; k); j++) 70 dp[rolling][j] = 0; 71 for(int j = 0; j \u0026lt; (2 \u0026lt;\u0026lt; k); j++){ 72 int r = (j \u0026lt;\u0026lt; 1) % (1 \u0026lt;\u0026lt; (k + 1)); 73 dp[rolling][r] += dp[not rolling][j] * tb[r]; 74 dp[rolling][r + 1] += dp[not rolling][j] * tb[r + 1]; 75 dp[rolling][r] %= MOD; 76 dp[rolling][r + 1] %= MOD; 77 } 78 rolling ^= 1; 79 } 80 int output = 0; 81 for(int i = 0; i \u0026lt; (2 \u0026lt;\u0026lt; k); i++){ 82 output += dp[not rolling][i]; 83 output %= MOD; 84 } 85 cout \u0026lt;\u0026lt; output; 86} 87int32_t main() { 88 ios::sync_with_stdio(0), cin.tie(0); 89 solve(); 90}  ","date":"2021-01-29T10:06:55+08:00","permalink":"https://Luke2336.github.io/p/20210128/","title":"2021/01/28 日記"},{"content":"睡到下午才起床，去了一趟生輔組交資料，之後吃了麥當勞，然後跟隊友勾寒訓的 DP 題單，晚上吃了壽司。\n","date":"2021-01-28T12:01:22+08:00","permalink":"https://Luke2336.github.io/p/20210127/","title":"2021/01/27 日記"},{"content":"看到德文一的成績出來了，拿了 A，可能是期末考考差了，希望下學期的德文二能拼到 A+。\n上週四從家裡寄限時信，結果今天都還沒到宿舍。\n早餐吃了燻雞蛋土司，午餐吃了麥當勞。下午寫了題，然後讀了代數的第一章，是在講同餘系，還有用輾轉相除法求解同餘方程式。\n晚上吃了火鍋。\n筆記 - 近世代數 Toggl 上週主要都在學 kotlin 和寫 PCCA 的寒假作業，希望寒假能恢復實作的能力。\nKattis Kattis - The Dragon of Loowater 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 int n, m; 5 while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m) { 6 if (!n \u0026amp;\u0026amp; !m) break; 7 vector\u0026lt;int\u0026gt; a(n), b(m); 8 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 9 for (int i = 0; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; b[i]; 10 sort(a.begin(), a.end()); 11 sort(b.begin(), b.end()); 12 int ans = 0; 13 for (int i = 0, j = 0; i \u0026lt; n; i++) { 14 while (j \u0026lt; m \u0026amp;\u0026amp; a[i] \u0026gt; b[j]) ++j; 15 if (j \u0026lt; m) ans += b[j++]; 16 else { ans = -1; break;} 17 } 18 if (ans == -1) cout \u0026lt;\u0026lt; \u0026#34;Loowater is doomed!\\n\u0026#34;; 19 else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 20 } 21 return 0; 22}  Kattis - Postal Delivery 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4typedef long long ll; 5ll solve(vector\u0026lt;pii\u0026gt; \u0026amp;v, int k) { 6 ll ret = 0; 7 sort(v.begin(), v.end()); 8 while (v.size()) { 9 int cap = k; 10 ret += v.back().first; 11 while (v.size() \u0026amp;\u0026amp; cap) { 12 int load = min(cap, v.back().second); 13 v.back().second -= load, cap -= load; 14 if (!v.back().second) v.pop_back(); 15 } 16 } 17 return ret; 18} 19int main () { 20 int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; 21 vector\u0026lt;pii\u0026gt; v[2]; 22 for (int i = 0; i \u0026lt; n; i++) { 23 int x, t; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; t; 24 if (x \u0026lt; 0) v[1].push_back(pii(-x, t)); 25 else v[0].push_back(pii(x, t)); 26 } 27 cout \u0026lt;\u0026lt; (solve(v[0], k) + solve(v[1], k)) * 2 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 return 0; 29}  Kattis - Ladice  Union-Find Tree，覺得題目出得很好。  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3struct UnionFind { 4 vector\u0026lt;int\u0026gt; p, r, sz; 5 UnionFind(int n) { 6 p.resize(n), r.resize(n, 1), sz.resize(n, 1); 7 for (int i = 0; i \u0026lt; n; i++) p[i] = i; 8 } 9 int par(int x) { 10 while (x != p[x]) x = p[x]; 11 return x; 12 } 13 int size(int x) { return sz[par(x)]; } 14 void add(int x) { sz[par(x)]--; } 15 void uni(int a, int b) { 16 a = par(a), b = par(b); 17 if (a == b) return; 18 if (r[a] \u0026gt; r[b]) { int t = a; a = b; b = t; } 19 else if (r[a] == r[b]) r[b]++; 20 p[a] = b, sz[b] += sz[a]; 21 } 22}; 23int main () { 24 ios::sync_with_stdio(0), cin.tie(0); 25 int n, L; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L; 26 UnionFind uf(L); 27 for (int i = 0; i \u0026lt; n; i++) { 28 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 29 uf.uni(--a, --b); 30 if (uf.size(a)) uf.add(a), cout \u0026lt;\u0026lt; \u0026#34;LADICA\\n\u0026#34;; 31 else cout \u0026lt;\u0026lt; \u0026#34;SMECE\\n\u0026#34;; 32 } 33 return 0; 34}  Kattis - Misa 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 int r, s; cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; s; 5 vector\u0026lt;string\u0026gt; a(r); 6 for (int i = 0; i \u0026lt; r; i++) cin \u0026gt;\u0026gt; a[i]; 7 int mx = 0, sum = 0; 8 for (int i = 0; i \u0026lt; r; i++) { 9 for (int j = 0; j \u0026lt; s; j++) { 10 int cnt = 0; 11 for (int dx = -1; dx \u0026lt;= 1; dx++) { 12 for (int dy = -1; dy \u0026lt;= 1; dy++) { 13 int x = i + dx, y = j + dy; 14 if (x \u0026lt; 0 || y \u0026lt; 0 || 15 x \u0026gt;= r || y \u0026gt;= s) continue; 16 if (a[x][y] == \u0026#39;o\u0026#39;) cnt++; 17 } 18 } 19 if (a[i][j] == \u0026#39;o\u0026#39;) sum += cnt - 1; 20 else mx = max(mx, cnt); 21 } 22 } 23 cout \u0026lt;\u0026lt; sum / 2 + mx \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 24 return 0; 25}  Kattis - Relocation 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 6 vector\u0026lt;int\u0026gt; v(n + 1); 7 for (int i = 1; i \u0026lt;= n; i++) 8 cin \u0026gt;\u0026gt; v[i]; 9 while (q--) { 10 int op, a, b; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 11 if (op == 1) v[a] = b; 12 else cout \u0026lt;\u0026lt; abs(v[a] - v[b]) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 } 14 return 0; 15}  ","date":"2021-01-26T10:38:26+08:00","permalink":"https://Luke2336.github.io/p/20210126/","title":"2021/01/26 日記"},{"content":"OS 的總成績出來了，被調了 7 分左右。\n晚餐吃了將軍村的「翟九」紅燒牛肉麵，覺得價位偏高，但肉質偏祡，湯味略苦，不合胃口。\n圖書館 早上去圖書館還書，順便借了幾本書。\n含羞草開花 含羞草開花了，但看到時已經謝了一半。\n系羽 下午 14:00 - 15:40 去舊館打球，覺得退步滿多的。去的人不多，只有五六個，打了幾場雙打。但也能趁現在改一下打球的風格，後場除了切球，還多試了長球。\n導師 打完球後去請導師簽文件，順便聊了一個鐘頭。有問了一下有沒有推薦的機率論，老師推薦了 Ross 的 Introduction to Probability Models，老師還多借了另一本書給我讀。\nKattis - Average Speed 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int T(string s) { 4 int h = (s[0] - \u0026#39;0\u0026#39;) * 10 + s[1] - \u0026#39;0\u0026#39;; 5 int m = (s[3] - \u0026#39;0\u0026#39;) * 10 + s[4] - \u0026#39;0\u0026#39;; 6 int ss = (s[6] - \u0026#39;0\u0026#39;) * 10 + s[7] - \u0026#39;0\u0026#39;; 7 return (h * 60 + m) * 60 + ss; 8} 9void input(string s, int \u0026amp;op, int \u0026amp;speed, int \u0026amp;time) { 10 stringstream ss; 11 ss.clear(); ss.str(s); 12 ss \u0026gt;\u0026gt; s; 13 if (ss \u0026gt;\u0026gt; speed) op = 0; 14 else op = 1; 15 time = T(s); 16} 17int main () { 18 int cnt = 0, speed = 0, last = 0; 19 while (1) { 20 string s; 21 getline(cin, s); 22 if (cin.fail()) break; 23 int op, time, new_speed; 24 input(s, op, new_speed, time); 25 if (op) { 26 double dis = (cnt + (time - last) * speed) / 3600.0; 27 cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; dis \u0026lt;\u0026lt; \u0026#34; km\\n\u0026#34;; 28 } else { 29 cnt += (time - last) * speed; 30 speed = new_speed; 31 last = time; 32 } 33 } 34 return 0; 35}  Kattis - Circuit Math 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 ios::sync_with_stdio(0); cin.tie(0); 5 int n; cin \u0026gt;\u0026gt; n; 6 vector\u0026lt;char\u0026gt; r(n); 7 for (int i = 0; i \u0026lt; n; i++) 8 cin \u0026gt;\u0026gt; r[i]; 9 char c; 10 vector\u0026lt;bool\u0026gt; v; 11 while (cin \u0026gt;\u0026gt; c) { 12 if (c == \u0026#39;*\u0026#39;) { 13 bool t = v.back(); 14 v.pop_back(); 15 v.back() = v.back() \u0026amp;\u0026amp; t; 16 } else if (c == \u0026#39;+\u0026#39;) { 17 bool t = v.back(); 18 v.pop_back(); 19 v.back() = v.back() || t; 20 } else if (c == \u0026#39;-\u0026#39;) { 21 v.back() = !v.back(); 22 } else { 23 v.push_back(r[c - \u0026#39;A\u0026#39;] == \u0026#39;T\u0026#39;); 24 } 25 } 26 cout \u0026lt;\u0026lt; \u0026#34;FT\u0026#34;[v.back()] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 27 return 0; 28}  Kattis - Three Powers 1while True: 2 n = int(input()) 3 if n == 0: 4 break 5 n -= 1 6 now = 1 7 L = [] 8 while n != 0: 9 if n \u0026amp; 1 == 1: 10 L.append(now) 11 n \u0026gt;\u0026gt;= 1 12 now *= 3 13 ans = \u0026#39;\u0026#39; 14 for i in L: 15 ans += \u0026#39; \u0026#39; + str(i) + \u0026#39;,\u0026#39; 16 print(\u0026#39;{\u0026#39; + ans[:-1] + \u0026#39; }\u0026#39;) Kattis - Quick Brown Fox 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 ios::sync_with_stdio(0); cin.tie(0); 5 int T; cin \u0026gt;\u0026gt; T; cin.ignore(); 6 while (T--) { 7 string s; getline(cin, s); 8 int cnt[26] = {}; 9 for (char c : s) 10 if (isupper(c)) cnt[c - \u0026#39;A\u0026#39;]++; 11 else if (islower(c)) cnt[c - \u0026#39;a\u0026#39;]++; 12 string ans = \u0026#34;\u0026#34;; 13 for (int i = 0; i \u0026lt; 26; i++) 14 if (!cnt[i]) ans += i + \u0026#39;a\u0026#39;; 15 if (ans.length()) cout \u0026lt;\u0026lt; \u0026#34;missing \u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 16 else cout \u0026lt;\u0026lt; \u0026#34;pangram\\n\u0026#34;; 17 } 18 return 0; 19}  Kattis - Square Peg in a Round Hole 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; 5 vector\u0026lt;int\u0026gt; R(n); 6 for (int i = 0; i \u0026lt; n; i++) { 7 cin \u0026gt;\u0026gt; R[i]; 8 R[i] *= 4 * R[i]; 9 } 10 priority_queue\u0026lt;int\u0026gt; pq; 11 for (int i = 0; i \u0026lt; m; i++) { 12 int c; cin \u0026gt;\u0026gt; c; 13 pq.push(4 * c * c); 14 } 15 for (int i = 0; i \u0026lt; k; i++) { 16 int s; cin \u0026gt;\u0026gt; s; 17 pq.push(2 * s * s); 18 } 19 sort(R.begin(), R.end()); 20 reverse(R.begin(), R.end()); 21 int ans = 0; 22 for (int i = 0; i \u0026lt; n; i++) { 23 while (!pq.empty() \u0026amp;\u0026amp; pq.top() \u0026gt;= R[i]) 24 pq.pop(); 25 if (!pq.empty()) 26 pq.pop(), ans++; 27 } 28 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 29 return 0; 30}  Kattis - Radio Commercials 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 int n, p; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; 5 int ans = 0, cnt = 0; 6 for (int i = 0; i \u0026lt; n; i++) { 7 int x; cin \u0026gt;\u0026gt; x; 8 cnt += x - p; 9 ans = max(ans, cnt); 10 cnt = max(cnt, 0); 11 } 12 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 return 0; 14}  Kattis - Ultra-QuickSort 算逆序數對數量，9 ~ 11 行寫起來略卡。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4vector\u0026lt;ll\u0026gt; v, tmp; 5ll inv(int l, int r) { 6 if (l \u0026gt;= r) return 0; 7 int m = (l + r) \u0026gt;\u0026gt; 1; 8 ll ret = inv(l, m) + inv(m + 1, r); 9 for (int i = l, j = m + 1, k = l; k \u0026lt;= r; k++) 10 if (i \u0026gt; m || (j \u0026lt;= r \u0026amp;\u0026amp; v[i] \u0026gt; v[j])) tmp[k] = v[j++]; 11 else tmp[k] = v[i++], ret += j - m - 1; 12 for (int i = l; i \u0026lt;= r; i++) v[i] = tmp[i]; 13 return ret; 14} 15int main () { 16 int n; cin \u0026gt;\u0026gt; n; 17 v.resize(n), tmp.resize(n); 18 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; 19 cout \u0026lt;\u0026lt; inv(0, n - 1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 20 return 0; 21}  ","date":"2021-01-25T13:38:47+08:00","permalink":"https://Luke2336.github.io/p/20210125/","title":"2021/01/25 日記"},{"content":"雙曲線說他最近很忙，沒空用寒訓的東西，也沒空對練，讓我覺得壓力有些大。\n看到 Google Code Jam to I/O for Women 2021 開放註冊了，但是辦在 2/13 23:00，應該沒得打了 QAQ\n晚餐原本想吃炸雞腿，但今天沒賣，於是只吃了豬肉丼。之後很餓便把夏天冰的百香果拿出來吃，然後又下去全家買了雞肉義大利麵。\n下午在寫寒假作業，已經寫到 17 題了，但離 100 題好遙遠。\n Kattis - Almost Union-Find Kattis - Thank God it’s Friday Kattis - Natrij Kattis - Semafori Kattis - Triple Texting Kattis - Functional Fun Kattis - Timebomb  Kattis - Almost Union-Find 1 ≤ n, m ≤ 1e5，有三種操作：\n 1 p q 代表將 p 和 q 所屬的集合合併。 2 p q 代表將 p 移到 q 所屬的集合。 3 p 為查詢 p 所屬集合大小及元素和。  操作 2 較難處理，方法為創出新的節點，並將元素指向新的節點。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 ios::sync_with_stdio(0); cin.tie(0); 5 int n, m; 6 while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m) { 7 vector\u0026lt;long long\u0026gt; sum(n + 1); 8 vector\u0026lt;int\u0026gt; sz(n + 1, 1), par(n + 1), point(n + 1); 9 for (int i = 1; i \u0026lt;= n; i++) 10 par[i] = sum[i] = point[i] = i; 11 while (m--) { 12 int op, p, q; cin \u0026gt;\u0026gt; op; 13 if (op == 2) { 14 cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q; 15 int pp = p; 16 pp = point[pp], q = point[q]; 17 while (pp != par[pp]) pp = par[pp]; 18 while (q != par[q]) q = par[q]; 19 if (pp == q) continue; 20 sz[pp]--, sum[pp] -= p; 21 point[p] = par.size(); 22 par.push_back(q); 23 sz[q]++, sum[q] += p; 24 } else if (op == 1) { 25 cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q; 26 p = point[p], q = point[q]; 27 while (p != par[p]) p = par[p]; 28 while (q != par[q]) q = par[q]; 29 if (p == q) continue; 30 if (sz[p] \u0026gt; sz[q]) { 31 int t = p; p = q; q = t; 32 } 33 par[p] = q; 34 sum[q] += sum[p]; 35 sz[q] += sz[p]; 36 } else if (op == 3) { 37 cin \u0026gt;\u0026gt; p; 38 p = point[p]; 39 while (p != par[p]) p = par[p]; 40 cout \u0026lt;\u0026lt; sz[p] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sum[p] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 41 } 42 } 43 } 44 return 0; 45}  Kattis - Thank God it’s Friday 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3string M[12] = {\u0026#34;JAN\u0026#34;, \u0026#34;FEB\u0026#34;, \u0026#34;MAR\u0026#34;, \u0026#34;APR\u0026#34;, \u0026#34;MAY\u0026#34;, \u0026#34;JUN\u0026#34;, 4 \u0026#34;JUL\u0026#34;, \u0026#34;AUG\u0026#34;, \u0026#34;SEP\u0026#34;, \u0026#34;OCT\u0026#34;, \u0026#34;NOV\u0026#34;, \u0026#34;DEC\u0026#34;}; 5int cnt[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 6string W[7] = {\u0026#34;MON\u0026#34;, \u0026#34;TUE\u0026#34;, \u0026#34;WED\u0026#34;, \u0026#34;THU\u0026#34;, \u0026#34;FRI\u0026#34;, \u0026#34;SAT\u0026#34;, \u0026#34;SUN\u0026#34;}; 7int main () { 8 int d; 9 string m, w; 10 cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; m \u0026gt;\u0026gt; w; 11 for (int i = 0; M[i] != m; i++) 12 d += cnt[i]; 13 int day = d - 1; 14 for (int i = 0; W[i] != w; i++) 15 day++; 16 day %= 7; 17 if (m == M[0] || m == M[1]) { 18 if (day == 4) cout \u0026lt;\u0026lt; \u0026#34;TGIF\\n\u0026#34;; 19 else cout \u0026lt;\u0026lt; \u0026#34;:(\\n\u0026#34;; 20 } else { 21 if (day == 4 || day == 3) cout \u0026lt;\u0026lt; \u0026#34;not sure\\n\u0026#34;; 22 else cout \u0026lt;\u0026lt; \u0026#34;:(\\n\u0026#34;; 23 } 24 return 0; 25}  Kattis - Natrij 1h1, m1, s1 = [int(i) for i in input().split(\u0026#39;:\u0026#39;)] 2h2, m2, s2 = [int(i) for i in input().split(\u0026#39;:\u0026#39;)] 3s = ((h2 - h1 + 24) * 60 + m2 - m1) * 60 + s2 - s1 4if s % (24 * 3600) == 0: 5 print(\u0026#34;24:00:00\u0026#34;) 6else: 7 print(\u0026#39;%02d:%02d:%02d\u0026#39; % (s // 3600 % 24, s // 60 % 60, s % 60) ) Kattis - Semafori 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4typedef pair\u0026lt;int, pii\u0026gt; piii; 5#define x first 6#define y second 7int main () { 8 ios::sync_with_stdio(0), cin.tie(0); 9 int n, L; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L; 10 vector\u0026lt;piii\u0026gt; p(n); 11 for (int i = 0; i \u0026lt; n; i++) 12 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y.x \u0026gt;\u0026gt; p[i].y.y; 13 sort(p.begin(), p.end()); 14 int cnt = 0; 15 for (int i = 0; i \u0026lt; n; i++) { 16 int t = p[i].x + cnt; 17 int cycle = p[i].y.x + p[i].y.y; 18 if (t % cycle \u0026lt; p[i].y.x) 19 cnt += p[i].y.x - t % cycle; 20 } 21 cout \u0026lt;\u0026lt; L + cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 22 return 0; 23}  Kattis - Triple Texting 1s = input() 2L = len(s) // 3 3for i in range(L): 4 if s[i] == s[i + L]: 5 print(s[i], end = \u0026#39;\u0026#39;) 6 else: 7 print(s[i + L + L], end = \u0026#39;\u0026#39;) Kattis - Functional Fun 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3bool input(set\u0026lt;string\u0026gt; \u0026amp;st) { 4 string s; cin \u0026gt;\u0026gt; s; 5 if (cin.fail()) return false; 6 getline(cin, s); 7 stringstream ss; 8 ss.clear(); ss.str(s); 9 while (ss \u0026gt;\u0026gt; s) st.insert(s); 10 return true; 11} 12int main () { 13 ios::sync_with_stdio(0); cin.tie(0); 14 while (1) { 15 set \u0026lt;string\u0026gt; domain, codomain; 16 if (!input(domain) || !input(codomain)) break; 17 int sz1 = domain.size(), sz2 = codomain.size(); 18 int m; cin \u0026gt;\u0026gt; m; 19 bool surjective = true, injective = true; 20 bool function = true; 21 map\u0026lt;string, string\u0026gt; mp; 22 while (m--) { 23 string x, y, tmp; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; tmp \u0026gt;\u0026gt; y; 24 if (mp.find(x) != mp.end()) { 25 if (mp[x] != y) function = false; 26 else continue; 27 } 28 mp[x] = y; 29 if (!codomain.count(y)) injective = false; 30 else codomain.erase(y); 31 } 32 if (codomain.size()) surjective = false; 33 if (!function) cout \u0026lt;\u0026lt; \u0026#34;not a function\\n\u0026#34;; 34 else if (injective \u0026amp;\u0026amp; surjective) cout \u0026lt;\u0026lt; \u0026#34;bijective\\n\u0026#34;; 35 else if (injective) cout \u0026lt;\u0026lt; \u0026#34;injective\\n\u0026#34;; 36 else if (surjective) cout \u0026lt;\u0026lt; \u0026#34;surjective\\n\u0026#34;; 37 else cout \u0026lt;\u0026lt; \u0026#34;neither injective nor surjective\\n\u0026#34;; 38 } 39 return 0; 40}  Kattis - Timebomb 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3string digit[5] = {\u0026#34;*** * *** *** * * *** *** *** *** *** \u0026#34;, 4 \u0026#34;* * * * * * * * * * * * * * \u0026#34;, 5 \u0026#34;* * * *** *** *** *** *** * *** *** \u0026#34;, 6 \u0026#34;* * * * * * * * * * * * * \u0026#34;, 7 \u0026#34;*** * *** *** * *** *** * *** *** \u0026#34;}; 8int main () { 9 string s[5]; 10 for (int i = 0; i \u0026lt; 5; i++) { 11 getline(cin, s[i]); 12 s[i] += \u0026#34; \u0026#34;; 13 } 14 int cnt = 0, len = s[0].length() / 4; 15 for (int i = 0; i \u0026lt; len; i++) { 16 int d = -1; 17 for (int j = 0; j \u0026lt;= 9; j++) { 18 bool check = true; 19 for (int x = 0; x \u0026lt; 5 \u0026amp;\u0026amp; check; x++) 20 for (int y = 0; y \u0026lt; 4 \u0026amp;\u0026amp; check; y++) 21 if (s[x][i * 4 + y] != digit[x][j * 4 + y]) 22 check = false; 23 if (check) {d = j; break;} 24 } 25 if (d == -1) { cout \u0026lt;\u0026lt; \u0026#34;BOOM!!\\n\u0026#34;; return 0;} 26 else cnt = cnt * 10 + d; 27 } 28 if (cnt % 6) cout \u0026lt;\u0026lt; \u0026#34;BOOM!!\\n\u0026#34;; 29 else cout \u0026lt;\u0026lt; \u0026#34;BEER!!\\n\u0026#34;; 30 return 0; 31}  ","date":"2021-01-24T14:34:01+08:00","permalink":"https://Luke2336.github.io/p/20210124/","title":"2021/01/24 日記"},{"content":"今天新竹下著綿綿細雨，早上去了竹東，中午去台中曬太陽。\n不知道為什麼昨晚就覺得身體發熱，今天白天甚是疲倦。\n","date":"2021-01-24T01:16:13+08:00","permalink":"https://Luke2336.github.io/p/20210123/","title":"2021/01/23 日記"},{"content":"今天都在刷 PCCA 的寒假作業。\n晚餐吃了一點串燒，喝了可爾必思的氣泡口味。\nKattis - Jane Eyre 覺得 input 格式很難處理～\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef pair\u0026lt;string, int\u0026gt; psi; 4typedef pair\u0026lt;int, psi\u0026gt; pisi; 5typedef long long ll; 6psi split(string s) { 7 bool flag = false; 8 for (int i = 0; s[i]; i++) { 9 if (flag \u0026amp;\u0026amp; s[i] == \u0026#39; \u0026#39;) s[i] = \u0026#39;$\u0026#39;; 10 else if (s[i] == \u0026#39;\\\u0026#34;\u0026#39;) { 11 if (flag) break; 12 flag = true; 13 } 14 } 15 stringstream ss; 16 ss.clear(); ss.str(s); 17 string name; 18 int page; 19 ss \u0026gt;\u0026gt; name \u0026gt;\u0026gt; page; 20 for (int i = 0; name[i]; i++) 21 if (name[i] == \u0026#39;$\u0026#39;) name[i] = \u0026#39; \u0026#39;; 22 return psi(name, page); 23} 24int main () { 25 ios::sync_with_stdio(0), cin.tie(0); 26 int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; 27 priority_queue\u0026lt;psi, vector\u0026lt;psi\u0026gt;, greater\u0026lt;psi\u0026gt; \u0026gt; pq; 28 psi goal = psi(\u0026#34;\\\u0026#34;Jane Eyre\\\u0026#34;\u0026#34;, k); 29 pq.push(goal); 30 for (int i = 0; i \u0026lt; n; i++) { 31 string s1, s2; 32 cin \u0026gt;\u0026gt; s1; 33 getline(cin, s2); 34 pq.push(split(s1 + s2)); 35 } 36 priority_queue\u0026lt;pisi, vector\u0026lt;pisi\u0026gt;, greater\u0026lt;pisi\u0026gt; \u0026gt; pq2; 37 for (int i = 0; i \u0026lt; m; i++) { 38 int t; cin \u0026gt;\u0026gt; t; 39 string s; getline(cin, s); 40 pq2.push(pisi(t, split(s))); 41 } 42 ll time = 0; 43 while (1) { 44 while (!pq2.empty()) { 45 if (pq.empty() || pq2.top().first \u0026lt;= time) { 46 pq.push(pq2.top().second); 47 pq2.pop(); 48 } else break; 49 } 50 if (pq.empty()) break; 51 time += pq.top().second; 52 if (pq.top() == goal) break; 53 pq.pop(); 54 } 55 cout \u0026lt;\u0026lt; time \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 56 return 0; 57}  Kattis - Sim 原本想用 Linked List 做，但後來發現 deque 比較好寫。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 ios::sync_with_stdio(0); cin.tie(0); 5 int T; cin \u0026gt;\u0026gt; T; cin.ignore(); 6 while (T--) { 7 string s; 8 getline(cin, s); 9 deque\u0026lt;string\u0026gt; dq; 10 dq.push_front(\u0026#34;\u0026#34;); 11 int state = 0; 12 for (int i = 0; s[i]; i++) { 13 if (s[i] == \u0026#39;\u0026lt;\u0026#39;) { 14 if (!state) { 15 if (dq.front() != \u0026#34;\u0026#34;) 16 dq.front().pop_back(); 17 } else { 18 if (dq.back() != \u0026#34;\u0026#34;) 19 dq.back().pop_back(); 20 } 21 } else if (s[i] == \u0026#39;[\u0026#39;) { 22 if (dq.front() != \u0026#34;\u0026#34;) 23 dq.push_front(\u0026#34;\u0026#34;); 24 state = 0; 25 } else if (s[i] == \u0026#39;]\u0026#39;) { 26 state = -1; 27 } else { 28 if (state) dq.back().push_back(s[i]); 29 else dq.front().push_back(s[i]); 30 } 31 } 32 string ans; 33 while (!dq.empty()) { 34 ans += dq.front(); 35 dq.pop_front(); 36 } 37 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 38 } 39 return 0; 40}  Kattis - Teque 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 ios::sync_with_stdio(0); cin.tie(0); 5 int N; cin \u0026gt;\u0026gt; N; 6 deque\u0026lt;int\u0026gt; dq1, dq2; 7 while (N--) { 8 string op; cin \u0026gt;\u0026gt; op; 9 int x; cin \u0026gt;\u0026gt; x; 10 if (op == \u0026#34;push_back\u0026#34;) { 11 dq2.push_back(x); 12 } else if (op == \u0026#34;push_front\u0026#34;) { 13 dq1.push_front(x); 14 } else if (op == \u0026#34;push_middle\u0026#34;) { 15 int sz1 = (dq1.size() + dq2.size() + 1) / 2; 16 while (dq1.size() \u0026lt; sz1) { 17 dq1.push_back(dq2.front()); 18 dq2.pop_front(); 19 } 20 while (dq1.size() \u0026gt; sz1) { 21 dq2.push_front(dq1.back()); 22 dq1.pop_back(); 23 } 24 dq1.push_back(x); 25 } else if (op == \u0026#34;get\u0026#34;) { 26 if (dq1.size() \u0026gt; x) 27 cout \u0026lt;\u0026lt; dq1[x] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 else cout \u0026lt;\u0026lt; dq2[x - dq1.size()] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 29 } 30 } 31 return 0; 32}  Kattis - Continuous Median 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 ios::sync_with_stdio(0); cin.tie(0); 5 int T; cin \u0026gt;\u0026gt; T; 6 while (T--) { 7 int n; cin \u0026gt;\u0026gt; n; 8 priority_queue\u0026lt;int\u0026gt; pq1; 9 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; pq2; 10 pq1.push(-1), pq2.push(2e9); 11 long long ans = 0; 12 for (int i = 0; i \u0026lt; n; i++) { 13 int x; cin \u0026gt;\u0026gt; x; 14 if (pq2.size() \u0026gt;= pq1.size()) pq1.push(x); 15 else pq2.push(x); 16 while (pq1.top() \u0026gt; pq2.top()) { 17 pq1.push(pq2.top()); 18 pq2.push(pq1.top()); 19 pq1.pop(), pq2.pop(); 20 } 21 if (i \u0026amp; 1) ans += (pq1.top() + pq2.top()) / 2; 22 else ans += pq1.top(); 23 } 24 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 25 } 26 return 0; 27}  ","date":"2021-01-22T15:27:14+08:00","permalink":"https://Luke2336.github.io/p/20210122/","title":"2021/01/22 日記"},{"content":"下午收到國際處通知，交換的第一志願上了，北京大學 2022 Spring。不過還很猶豫，拿不定主意，因此還沒跟家人講。\n晚上去吃了和味，然後給人按摩了一小時，覺得小腿和肩膀超痠的。\nKattis - Pivot 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int n; cin \u0026gt;\u0026gt; n; 6 vector\u0026lt;int\u0026gt; a(n); 7 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 8 vector\u0026lt;bool\u0026gt; check(n, true); 9 int mx = a[0]; 10 for (int i = 0; i \u0026lt; n; i++) { 11 if (a[i] \u0026lt; mx) check[i] = false; 12 mx = max(mx, a[i]); 13 } 14 int mn = a[n - 1]; 15 for (int i = n - 1; i \u0026gt;= 0; i--) { 16 if (a[i] \u0026gt; mn) check[i] = false; 17 mn = min(mn, a[i]); 18 } 19 int cnt = 0; 20 for (int i = 0; i \u0026lt; n; i++) 21 cnt += check[i]; 22 cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 23 return 0; 24}  Kattis - Prva 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int r, c; 6 cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c; 7 vector\u0026lt;string\u0026gt; v(r); 8 for (int i = 0; i \u0026lt; r; i++) 9 cin \u0026gt;\u0026gt; v[i]; 10 string ans = \u0026#34;{\u0026#34;; 11 for (int i = 0; i \u0026lt; r; i++) { 12 string tmp = \u0026#34;\u0026#34;; 13 for (int j = 0; j \u0026lt; c; j++) { 14 if (v[i][j] == \u0026#39;#\u0026#39;) { 15 if (tmp.length() \u0026gt;= 2) 16 ans = min(ans, tmp); 17 tmp = \u0026#34;\u0026#34;; 18 } else tmp += v[i][j]; 19 } 20 if (tmp.length() \u0026gt;= 2) 21 ans = min(ans, tmp); 22 } 23 for (int j = 0; j \u0026lt; c; j++) { 24 string tmp = \u0026#34;\u0026#34;; 25 for (int i = 0; i \u0026lt; r; i++) { 26 if (v[i][j] == \u0026#39;#\u0026#39;) { 27 if (tmp.length() \u0026gt;= 2) 28 ans = min(ans, tmp); 29 tmp = \u0026#34;\u0026#34;; 30 } else tmp += v[i][j]; 31 } 32 if (tmp.length() \u0026gt;= 2) 33 ans = min(ans, tmp); 34 } 35 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 36 return 0; 37}  ","date":"2021-01-21T11:50:28+08:00","permalink":"https://Luke2336.github.io/p/20210121/","title":"2021/01/21 日記"},{"content":"因為口腔靠近喉嚨的部分痛了好幾天，所以去看了學校的醫生，然後醫生認為是智齒發炎。覺得有點煩，畢竟要去看牙醫很麻煩，要先預約，然後又要痛個好幾天。\n晚上吃了烤雞和冰淇淋，但心情還是很煩悶。\nKattis - Printing Costs 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 string s = \u0026#34; !\\\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0026#34;; 5 int a[] = {0, 9, 6, 24, 29, 22, 6 24, 3, 12, 12 ,17, 13, 7 7, 7, 4, 10, 22, 19, 8 22, 23, 21, 27, 26, 16, 9 23, 26, 8, 11, 10, 14, 10 10, 15, 32, 24, 29, 20, 11 26, 26, 20, 25, 25, 18, 12 18, 21, 16, 28, 25, 26, 13 23, 31, 28, 25, 16, 23, 14 19, 26, 18, 14, 22, 18, 15 10, 18, 7, 8, 3, 23, 16 25, 17, 25, 23, 18, 30, 17 21, 15, 20, 21, 16, 22, 18 18, 20, 25, 25, 13, 21, 19 17, 17, 13, 19, 13, 24, 20 19, 18, 12, 18, 9 }; 21 ios::sync_with_stdio(0); cin.tie(0); 22 string input; 23 while (1) { 24 getline(cin, input); 25 if (cin.fail()) break; 26 int cnt = 0; 27 for (int i = 0; input[i]; i++) 28 for (int j = 0; s[j]; j++) 29 if (input[i] == s[j]) { 30 cnt += a[j]; 31 break; 32 } 33 cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 34 } 35 return 0; 36}  Kattis - Touchscreen Keyboard 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3 4string board[3] = {\u0026#34;qwertyuiop\u0026#34;, \u0026#34;asdfghjkl\u0026#34;, \u0026#34;zxcvbnm\u0026#34;}; 5 6int x[26], y[26]; 7 8int main () { 9 for (int i = 0; i \u0026lt; 3; i++) { 10 for (int j = 0; board[i][j]; j++) { 11 int k = board[i][j] - \u0026#39;a\u0026#39;; 12 x[k] = i, y[k] = j; 13 } 14 } 15 ios::sync_with_stdio(0); cin.tie(0); 16 int T; cin \u0026gt;\u0026gt; T; 17 while (T--) { 18 string key; cin \u0026gt;\u0026gt; key; 19 int n; cin \u0026gt;\u0026gt; n; 20 vector\u0026lt; pair\u0026lt;int, string\u0026gt; \u0026gt; v; 21 for (int i = 0; i \u0026lt; n; i++) { 22 string s; cin \u0026gt;\u0026gt; s; 23 int cnt = 0; 24 for (int j = 0; s[j] \u0026amp;\u0026amp; key[j]; j++) { 25 int a = s[j] - \u0026#39;a\u0026#39;, b = key[j] - \u0026#39;a\u0026#39;; 26 cnt += abs(x[a] - x[b]) + abs(y[a] - y[b]); 27 } 28 v.push_back(pair\u0026lt;int, string\u0026gt;(cnt, s)); 29 } 30 sort(v.begin(), v.end()); 31 for (auto r : v) 32 cout \u0026lt;\u0026lt; r.second \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r.first \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 33 } 34 return 0; 35}  ","date":"2021-01-20T23:12:56+08:00","permalink":"https://Luke2336.github.io/p/20210120/","title":"2021/01/20 日記"},{"content":"下午簡略的弄了電路期末專題。晚上收到老師的信，結果電路期末又不及格了，星期四下午要補考，原本預計星期三中午要回基隆 QAQ\n晚上卡車勾了題目，於是就刷了兩題。\nKattis - Tic Tac Toe 給定一個 3x3 的棋盤，問是不是合法的。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3 4bool check(char t[3][4]) { 5 for (int i = 0; i \u0026lt; 3; i++) { 6 if (t[i][0] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; t[i][0] == t[i][1] 7 \u0026amp;\u0026amp; t[i][1] == t[i][2]) return false; 8 if (t[0][i] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; t[0][i] == t[1][i] 9 \u0026amp;\u0026amp; t[1][i] == t[2][i]) return false; 10 } 11 if (t[0][0] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; t[0][0] == t[1][1] 12 \u0026amp;\u0026amp; t[1][1] == t[2][2]) return false; 13 if (t[0][2] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; t[0][2] == t[1][1] 14 \u0026amp;\u0026amp; t[1][1] == t[2][0]) return false; 15 return true; 16} 17 18bool solve() { 19 char c[3][4]; 20 int cnt[2] = {}; 21 for (int i = 0; i \u0026lt; 3; i++) { 22 cin \u0026gt;\u0026gt; c[i]; 23 for (int j = 0; j \u0026lt; 3; j++) { 24 if (c[i][j] == \u0026#39;X\u0026#39;) cnt[0]++; 25 if (c[i][j] == \u0026#39;O\u0026#39;) cnt[1]++; 26 } 27 } 28 if (!cnt[0] \u0026amp;\u0026amp; !cnt[1]) return true; 29 if (cnt[0] \u0026lt; cnt[1] || cnt[0] - cnt[1] \u0026gt; 1) 30 return false; 31 char last = \u0026#34;XO\u0026#34;[cnt[0] == cnt[1]]; 32 for (int i = 0; i \u0026lt; 3; i++) { 33 for (int j = 0; j \u0026lt; 3; j++) { 34 if (c[i][j] != last) continue; 35 c[i][j] = \u0026#39;.\u0026#39;; 36 if (check(c)) return true; 37 c[i][j] = last; 38 } 39 } 40 return false; 41} 42 43int main () { 44 ios::sync_with_stdio(0), cin.tie(0); 45 int n; cin \u0026gt;\u0026gt; n; 46 while (n--) { 47 if (solve()) cout \u0026lt;\u0026lt; \u0026#34;yes\\n\u0026#34;; 48 else cout \u0026lt;\u0026lt; \u0026#34;no\\n\u0026#34;; 49 } 50 return 0; 51}  Kattis - Skener 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main () { 4 int r, c, a, b; 5 scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;r, \u0026amp;c, \u0026amp;a, \u0026amp;b); 6 char s[55]; 7 for (int i = 0; i \u0026lt; r; i++) { 8 scanf(\u0026#34; %s\u0026#34;, s); 9 for (int j = 0; j \u0026lt; a; j++) { 10 for (int k = 0; k \u0026lt; c; k++) 11 for (int p = 0; p \u0026lt; b; p++) 12 putchar(s[k]); 13 putchar(\u0026#39;\\n\u0026#39;); 14 } 15 } 16 return 0; 17}  ","date":"2021-01-20T23:03:17+08:00","permalink":"https://Luke2336.github.io/p/20210119/","title":"2021/01/19 日記"},{"content":"AtCoder Beginners Selection 用 AtCoder 的水題來練習 Kotlin 的基礎語法。\nPracticeA - Welcome to AtCoder 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 4private fun readInts() = readStrings().map { it.toInt() } 5 6fun main() { 7 val a = readInt() 8 val(b, c) = readInts() 9 val s = readLn() 10 println(\u0026#34;${a + b + c}$s\u0026#34;) 11} ABC086A - Product 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 4private fun readInts() = readStrings().map { it.toInt() } 5 6fun main() { 7 val(a, b) = readInts() 8 println(if (a % 2 == 1 \u0026amp;\u0026amp; b % 2 == 1 ) \u0026#34;Odd\u0026#34; else \u0026#34;Even\u0026#34;) 9} ABC081A - Placing Marbles 1private fun readLn() = readLine()!! 2fun countOne(s: String) = s.filter {it == \u0026#39;1\u0026#39;}.count() 3 4fun main() { 5 println(countOne(readLn())) 6} ABC081B - Shift only 1import kotlin.math.* 2 3private fun readLn() = readLine()!! 4private fun readInt() = readLn().toInt() 5private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 6private fun readInts() = readStrings().map { it.toInt() } 7 8fun main() { 9 val n = readInt() 10 val A = readInts() 11 var ans = A[0] 12 for (x in A) { 13 var cnt = 0 14 var tmp = x 15 while (tmp % 2 == 0) { 16 tmp /= 2 17 cnt++ 18 } 19 ans = min(ans, cnt) 20 } 21 println(ans) 22} ABC087B - Coins 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3 4fun main() { 5 val A = readInt() 6 val B = readInt() 7 val C = readInt() 8 val X = readInt() 9 var ans = 0 10 for (i in 0..A) { 11 for (j in 0..B) { 12 val sum = i * 500 + j * 100 13 if (sum \u0026lt;= X \u0026amp;\u0026amp; (X - sum) \u0026lt;= C * 50) 14 ans++ 15 } 16 } 17 println(ans) 18} ABC083B - Some Sums 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 4private fun readInts() = readStrings().map { it.toInt() } 5 6fun main() { 7 val(N, A, B) = readInts() 8 var ans = 0 9 for (i in 1..N) { 10 var tmp = i 11 var cnt = 0 12 while (tmp \u0026gt; 0) { 13 cnt += tmp % 10 14 tmp /= 10 15 } 16 if (cnt in A..B) 17 ans += i 18 } 19 println(ans) 20} ABC088B - Card Game for Two 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 4private fun readInts() = readStrings().map { it.toInt() } 5 6fun main() { 7 val N = readInt() 8 var A = readInts() 9 var cnt = IntArray(105) {0} 10 for (i in 0..N-1) cnt[A[i]]++ 11 var ans = 0 12 var r = 1 13 for (i in 100 downTo 1) { 14 for (j in 1..cnt[i]) { 15 ans += r * i 16 r = -r 17 } 18 } 19 println(ans) 20} ABC085B - Kagami Mochi 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3 4fun main() { 5 val N = readInt() 6 var A = IntArray(101) {0} 7 var ans = 0 8 for (i in 1..N) { 9 val x = readInt() 10 if (A[x] == 0) { 11 ans++ 12 A[x] = 1 13 } 14 } 15 println(ans) 16} ABC085C - Otoshidama 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 4private fun readInts() = readStrings().map { it.toInt() } 5 6fun main() { 7 val(N, Y) = readInts() 8 for (i in 0..N) { 9 for (j in 0..(N - i)) { 10 val k = N - i - j 11 if (i * 10000 + j * 5000 + k * 1000 == Y) { 12 println(\u0026#34;$i$j$k\u0026#34;) 13 return 14 } 15 } 16 } 17 println(\u0026#34;-1 -1 -1\u0026#34;) 18} ABC049C - Daydream 1fun main() { 2 val D = listOf(\u0026#34;dream\u0026#34;, \u0026#34;dreamer\u0026#34;, \u0026#34;erase\u0026#34;, \u0026#34;eraser\u0026#34;) 3 val DL = listOf(5, 7, 5, 6) 4 val S = readLine()!! 5 val L = S.length 6 var DP = BooleanArray(L + 1) {false} 7 DP[0] = true 8 for (i in 1..L) { 9 for (j in 0..3) { 10 val l = i - DL[j] 11 if (l \u0026lt; 0) continue 12 if (DP[l] \u0026amp;\u0026amp; S.substring(l, i) == D[j]) { 13 DP[i] = true 14 break 15 } 16 } 17 } 18 println(if (DP[L]) \u0026#34;YES\u0026#34; else \u0026#34;NO\u0026#34;) 19} ABC086C - Traveling 1import kotlin.math.abs 2private fun readLn() = readLine()!! 3private fun readInt() = readLn().toInt() 4private fun readStrings() = readLn().split(\u0026#34; \u0026#34;) 5private fun readInts() = readStrings().map { it.toInt() } 6 7fun main() { 8 val N = readInt() 9 var t = 0 10 var x = 0 11 var y = 0 12 for (i in 1..N) { 13 val(nt, nx, ny) = readInts() 14 val d = abs(nx - x) + abs(ny - y) 15 val dt = nt - t 16 if (d \u0026gt; dt || (dt - d) % 2 != 0) { 17 println(\u0026#34;No\u0026#34;) 18 return 19 } 20 t = nt 21 x = nx 22 y = ny 23 } 24 println(\u0026#34;Yes\u0026#34;) 25} ","date":"2021-01-19T17:00:49+08:00","permalink":"https://Luke2336.github.io/p/atcoder_abs/","title":"AtCoder Beginners Selection"},{"content":"今天起床後吃了雞腿蛋包飯，然後和蘇于討論電路學的專題，之後去買需要的材料，為了鐵粉，我們決定買暖暖包，結果找遍了清夜及交大的每家店都缺貨。晚餐吃了六扇門，發現小吃部在整修。\n晚上躺了一下之後，就去洗了澡，然後用 Kotlin 寫了 AtCoder 的水題。\n結果衣服還沒洗，星期三就要回家了 QAQ\n","date":"2021-01-18T03:02:24+08:00","permalink":"https://Luke2336.github.io/p/20210118/","title":"2021/01/18 日記"},{"content":"花了不少時間才起床，買了麥當勞，看完了烘焙王。\n之後就開始研究怎樣才能讓之後寫 Kotlin 比較方便，改了 bashrc，建立了 oj 指令支援 .cpp / .py / .kt 三種副檔名。\n傍晚研究了 Kotlin 的 Tutorial，然後吃了雞腿便當，一邊看了小時候看的甄嬛傳。\n/.bashrc 將雙曲線寫好的 bashrc 增加了 Kotlin 的指令。\noj() { ext=${1##*.} filename=${1##*/} filename=${filename%.*} case $ext in cpp ) g++ -o \u0026#34;/tmp/$filename\u0026#34; \u0026#34;$1\u0026#34; \u0026amp;\u0026amp; \u0026#34;/tmp/$filename\u0026#34; ;; py ) python3 \u0026#34;$1\u0026#34; ;; kt ) kotlinc \u0026#34;$1\u0026#34; -include-runtime -d \u0026#34;$filename\u0026#34;.jar \u0026amp;\u0026amp; java -jar \u0026#34;$filename\u0026#34;.jar \u0026amp;\u0026amp; rm \u0026#34;$filename\u0026#34;.jar ;; esac } 使用方式 $ oj 1.cpp $ oj 2.kt $ oj 3.py ","date":"2021-01-17T16:41:41+08:00","permalink":"https://Luke2336.github.io/p/20210117/","title":"2021/01/17 日記"},{"content":"今天仍然五點半就自然醒了，之後七點半又醒了一次，最後睡到九點半。左腳有點發炎，喉嚨右側也有點發炎。\n台中行 中午跟朋友去台中玩，有台中人帶就是不一樣，以前覺得台中很無聊。先去了台中女中附近逛街，喝了春水堂的紅茶凍飲。然後去了第一市場附近，走了電子街，去了幸發亭吃蜜豆冰，覺得這種冰很特別，加了很多種水果。之後去了台中都會公園看夕陽，晚上去文心路吃港式飲茶，覺得油雞和葡式蛋塔超級好吃。\n寒假 TODO 新增了幾個想做的事，希望能讓寒假充實一點。\n 學 Kotlin 寫自己的 Codebook 寫完 CSES 大部分的題目 複習機率、線性代數  ","date":"2021-01-16T21:38:53+08:00","permalink":"https://Luke2336.github.io/p/20210116/","title":"2021/01/16 日記"},{"content":"早上有點失眠，在床上躺了一陣子才起床。打扮了一下之後，去清大走了走，賞梅。\n晚餐吃了璽子牛肉麵，之後開始寫水題。因為有點累，所以十一點前就睡了。\nCSES - 2191 - Polygon Area 給一個簡單多邊形，輸出面積的兩倍。\n1#pragma GCC optimization (\u0026#34;O3\u0026#34;) 2#include\u0026lt;bits/stdc++.h\u0026gt;3using namespace std; 4typedef long long ll; 5typedef pair\u0026lt;ll, ll\u0026gt; pii; 6#define x first 7#define y second 8#define pb push_back 9ll det(vector\u0026lt;pii\u0026gt; \u0026amp;p, int n) { 10 ll cnt = 0; 11 for (int i = 0; i \u0026lt; n; i++) 12 cnt += p[i].x * p[i + 1].y - p[i + 1].x * p[i].y; 13 return (cnt \u0026gt; 0) ? cnt : -cnt; 14} 15int main() { 16 ios::sync_with_stdio(0), cin.tie(0); 17 int n; cin \u0026gt;\u0026gt; n; 18 vector\u0026lt;pii\u0026gt; p(n); 19 for (int i = 0; i \u0026lt; n; i++) 20 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 21 p.pb(p[0]); 22 cout \u0026lt;\u0026lt; det(p, n) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 23 return 0; 24}  清華踏青 天氣很好，於是就搭小紅巴出去走走。\n第二招待所 去二招吃印度料理，被老闆娘說很久沒看到我，今天生意相對比較好的樣子。\n梅園 第一次在梅花開的時候過去，上次去是秋天某次滿月和電資系羽的一個學長去夜遊。梅花開的很茂盛，賞花的人也絡繹不絕，剛剛在二招吃飯的一桌老人們也在這邊。有很多蜜蜂在採蜜，有一株有結了三顆梅子，看起來很好吃。\n相思湖 蝴蝶園 台積館 發現了一條蝴蝶園通往台積館的小徑，就從南大門走回交大，然後在石園發現了三隻五色鳥。之後買了蛋捲冰淇淋就回宿舍休息了。\n","date":"2021-01-15T15:17:37+08:00","permalink":"https://Luke2336.github.io/p/20210115/","title":"2021/01/15 日記"},{"content":"Kein Problem!    German  English     das Restaurant die Restaurants restaurant   das Hotel die Hotels hotel   das Theater die Theater theater   das Konzert die Konzerte concert   das Museum die Mussen museum   der Supermarkt die Supermärkte supermarket   die Bank die Banken bank   die Flughafen die Flughäfen airport   der Pilot die Piloten pilot   die Pilotin die Pilotinnen pilot   das Büro die Büros office   das Kino die Kinos movie theater   die Toilette die Toiletten toilet   das Zentrum die Zentren downtown, city center   die Universität die Universitäten university, college   der Student die Studenten student   die Studentin die Studentinen student   die Familie die Familien family       German  English     Taxi     der Bus die Busse bus   die Gitarre die Gitarren guitar   das Hobby die Hobbys hobby   die Musik  music   der Sport  sports   die Kultur  culture   die E-Mail die E-Mails e-mail   das Telefon die Telefone telephone   der Computer die Computer computer   der Kaffee die Kaffees coffee   die Pizza die Pizzen/Pizzas pizza    die Spaghetti spaghetti   das Problem die Probleme problem   die Information  Information       German English     bitte please   Kein Problem No problem       German  English     studieren studiert, studierte to study in an university    ","date":"2021-01-14T14:25:28+08:00","permalink":"https://Luke2336.github.io/p/dw_a1_kein_problem/","title":"[DW-A1] Kein Problem!"},{"content":"今天白天大部分的時間在讀德文，半夜完成了 OS 的 HW4，順邊幫 Maxwill debug，他的 CPU 是 ARM 的，不支援 Meltdown。\n晚上突然被明憲學長約，原來他隔天就要離開新竹了，很開心他離開前有想到要約我出來。和他在西區散了步，到科三樓頂吹吹風，聽他聊最近他在研究的投資學。\n","date":"2021-01-14T10:55:24+08:00","permalink":"https://Luke2336.github.io/p/20210114/","title":"2021/01/14 日記"},{"content":"早上被某學長約出去圖書館教他演算法，結果因為他說頭暈想吐就被放鴿子了。之後就在圖書館，寫 OS HW4，但還是卡住做不出來，問了彥彤，結果他還沒開始做。\n中午吃了水餃，心情悶悶的，就在宿舍寫 Blog，把修課心得搬到這邊。\n晚上去了 PCCA 聚餐，吃忠孝路的「海水屋」，隊友非常喜歡吃金沙豆腐，大部分的菜我覺得吃起來都不好吃，份量也有點少。隊友的作業好像也還剩不少。\nOS HW4 - Meltdown  Meltdown: Reading Kernel Memory from User Space，網路上有看到中文翻譯。  ","date":"2021-01-13T10:36:23+08:00","permalink":"https://Luke2336.github.io/p/20210113/","title":"2021/01/13 日記"},{"content":"Hallo! Grammar Formal 正式的會握手。\n Guten Tag, Frau Kamp!\n     時間     Guten Morgen! ~ 11:00   Guten Tag! 11:00 ~ 18:00   Gutne Abend! 18:00 ~    Informal  Hallo, Tom!\n  Hey! Hi! Tach! Na?      Region     Servus! Austria (informal)   Früß Gott! Southern Germany and Austria   Grüezi! Switerland   Moin! Northern Germany    Vocabulary    German  English     auch  also   oder  or   und  and   nicht  not   das Beispiel die Beispiele example   Danke.  Thanks.   Danke schön.     Danke sehr.     Gut  good   Sehr good  Very good   Super  super   schön  nice, pretty   Es geht mir gut.  I\u0026rsquo;m doing well.   Nicht so gut.  Not so good.   Und dir?  How about you? (Informal)   Und Inhen?  How about you? (Formal)   Wie geht es dir?  How are you? (Informal)   Wie geht es Inhen?  How are you? (Formal)   Es ist 09:00 Uhr.     Herr  Mr   Frau  Ms/Mrs   die Frau die Frauen woman   der Mann die Männer man    ","date":"2021-01-12T16:06:58+08:00","permalink":"https://Luke2336.github.io/p/dw_a1_hallo/","title":"[DW-A1] Hallo!"},{"content":"今天考完了電路學期末考，於是想開始進入寒假狀態，已經有了一些想做的事。\nTodo List  期末的作業們  OS HW4 電路學 Final Project   寒假  競程  PCCA 寒訓 CSES 題單   德文  DW Learn German   Blog  目錄 修課心得 日記      OS HW4 - Meltdown  要在能特定的 CPU 上才能 Meltdown，大部分 Intel 的 CPU 都可以。 Meltdown  現代的 CPU 多透過 Pipeline 去執行指令，當其中某些較快的指令執行完畢後，就會發出 Out-of-order Exception。再 CPU 處理 Exception 前，資料會先從 Register 複製到 Cache。 Meltdown 透過某些指令將 Cache 裡的東西搬到 User Mode 能存取的記憶體裡。    ","date":"2021-01-12T14:56:38+08:00","permalink":"https://Luke2336.github.io/p/20210112/","title":"2021/01/12 日記"},{"content":"今天開始下雨，很冷很冷。大部分的時間都在複習電路學，還有看卡通「烘焙王」。\n晚餐吃了牛肉麵，不過因為是最後一碗，所以只剩碎碎的肉。飯後簡單看了一下筆記後就睡了，睡了兩個小時後起床吃冰，不過因為壓力有點大，有些睡不著。\n電路學期末考複習 這次認真的把大部分的作業算過一遍。\n   Date Range     1/9 CH11   1/10 CH15 ~ CH16   1/11 CH13    ","date":"2021-01-12T13:50:46+08:00","permalink":"https://Luke2336.github.io/p/20210111/","title":"2021/01/11 日記"},{"content":"今天還是很冷，有點過敏，一直流鼻水。也因此大部分的時間都被我混過去，什麼事都沒有好好做，大概只有洗衣服和算了一點點電路學，主要是 Laplace 的部分，發現自己大部分都會，只是不夠熟練。\n決定早點去睡，很難得不到八點就去睡，書沒讀到預定進度其實有點恐慌，但身體舒服點再讀會更有效率。\n結果 12 點剛過就醒了，睡不到 4 小時。去全家買了宵夜吃，練完了電路學 15、16 章的習題。\nToggl 這是三週的讀書時間，邁入期末週後明顯時間上升不少，很多時間都耗在 OS 上面，因為之前一直放生它。電路學就是每週固定有點進度，其他幾科都在 12 月底結束了。很開心最近用功的時間持續上升，雖然一旦少做點事就有點緊張。\n","date":"2021-01-10T19:28:14+08:00","permalink":"https://Luke2336.github.io/p/20210110/","title":"2021/01/10 日記"},{"content":"因為 pA 卡住，所以慘慘的 QAQ\n掉了 31 分到 1685。\nAtCoder Regular Contest 111 A. Simple Math 2 題意 $$1 \\leq n \\leq 10^{18}, 1 \\leq m \\leq 10^4, \\text{find }\\lfloor \\frac{10^n}{m}\\rfloor \\mod m.$$\n解法  求 (10 ** n) % (m * m) // m。 紀錄餘數的循環節。 卡題原因：  忘記循環不一定從一開始。 用了 unordered_map 判斷餘數是否出現過導致 TLE，換成 array 就變很快了。    Code 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4#define pb push_back 5int s[100000008]; 6int main() { 7 ll n, m, mm; 8 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 9 mm = m * m; 10 ll r, d = 1; 11 vector\u0026lt;int\u0026gt; v; // 紀錄餘數 12 for (int i = 0; i \u0026lt;= n; i++) { 13 r = d % mm; 14 if (s[r] || (i \u0026amp;\u0026amp; r == v[0])) break; 15 s[r] = i; 16 v.pb(r); 17 d = r * 10; 18 } 19 if (n \u0026lt; v.size()) { 20 cout \u0026lt;\u0026lt; v[n] / m \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 21 return 0; 22 } 23 int t = s[r]; // 循環節起點 24 int id = t + (n - t) % (v.size() - t); 25 cout \u0026lt;\u0026lt; v[id] / m \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 26 return 0; 27}  B. Reversible Cards 題意 給定 N 張卡（≤2e5），每張卡上正反面各有一個數字（1~4e5），讓你每張牌只能選擇一面，問最多有幾個相異數字？\n解法 建立一個 Source，給每張牌 cap = 1 的邊，然後每張牌建立到正反兩面的數字 cap = 1 到邊，每個數字建立到 Sink cap = 1 的邊，之後求最大流 max-flow 即為答案\n因為是二分圖，所以用 Dinic 複雜度約為 O(sqrt(V)E) ~ 2e8。\nCode 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define pb push_back 6#define inf 1e9 7#define maxn 200000 8#define maxk 400000 9class Dinic { 10 private: 11 struct edge { int d, r; ll c; }; 12 vector\u0026lt;vector\u0026lt;edge\u0026gt;\u0026gt; adj; vector\u0026lt;int\u0026gt; lv, ve; int n; 13 bool mklv(int s, int d) { 14 lv.assign(n, -1); lv[s] = 0; queue\u0026lt;int\u0026gt; q({s}); 15 while (!q.empty()) { 16 int v = q.front(); q.pop(); 17 for (auto\u0026amp; e : adj[v]) { 18 if (e.c == 0 || lv[e.d] != -1) continue; 19 lv[e.d] = lv[v] + 1, q.push(e.d); 20 } 21 } 22 return lv[d] \u0026gt; 0; 23 } 24 ll aug(int v, ll f, int d) { 25 if (v == d) return f; 26 for (; ve[v] \u0026lt; adj[v].size(); ve[v]++) { 27 auto\u0026amp; e = adj[v][ve[v]]; 28 if (lv[e.d] != lv[v] + 1 || !e.c) continue; 29 ll sent = aug(e.d, min(f, e.c), d); 30 if (sent \u0026gt; 0) { 31 e.c -= sent, adj[e.d][e.r].c += sent; 32 return sent; 33 } 34 } 35 return 0; 36 } 37 public: 38 Dinic(int n) : n(n + 1) { clear(); } 39 void clear() { adj.assign(n, {}); } 40 void add_edge(int src, int dst, ll cap) { 41 edge ss{dst, (int)adj[dst].size(), cap}; 42 edge dd{src, (int)adj[src].size(), 0}; 43 adj[src].push_back(ss), adj[dst].push_back(dd); 44 } 45 ll max_flow(int s, int d) { 46 ll ret = 0; 47 while (mklv(s, d)) { 48 ve.assign(n, 0); 49 while (ll f = aug(s, inf, d)) ret += f; 50 } 51 return ret; 52 } 53}; 54int main() { 55 ios::sync_with_stdio(0), cin.tie(0); 56 int n; cin \u0026gt;\u0026gt; n; 57 Dinic D(maxn + maxk + 2); 58 int dst = maxn + maxk + 1; 59 for (int i = 1; i \u0026lt;= n; i++) { 60 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 61 D.add_edge(0, i, 1); 62 D.add_edge(i, maxn + a, 1); 63 D.add_edge(i, maxn + b, 1); 64 } 65 for (int i = 1; i \u0026lt;= maxk; i++) 66 D.add_edge(maxn + i, dst, 1); 67 cout \u0026lt;\u0026lt; D.max_flow(0, dst) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 68 return 0; 69}  ","date":"2021-01-09T22:03:11+08:00","permalink":"https://Luke2336.github.io/p/atcoder_arc111/","title":"AtCoder Regular Contest 111"},{"content":"昨天 11 點前就睡了，但還是睡到 10 點半左右，因為真的很冷。隊友們都去幫忙監考某考試了。\n早餐吃了麵包，然後今天看了好幾集卡通「烘焙王」。\n重新算了電路學 CH11 的作業，為期末考做準備。\n下午吃了麥當勞，今天的薯條超鹹，然後又被找下去吃了蛋捲冰淇淋。\n晚上打了 AtCoder 的 ARC 111，但還是覺得今天太廢了，肯定是上週作業壓力太大，連續趕了三份 OS 作業，所以今天就放鬆到開始耍廢。\nAtCoder Regular Contest 111 打得慘慘的，掉了 31 分！\n","date":"2021-01-09T22:02:20+08:00","permalink":"https://Luke2336.github.io/p/20210109/","title":"2021/01/09 日記"},{"content":"早上難得的吃了早餐，去提款機提錢，順便在旁邊買三明治吃，泡了柚子茶喝。\n用 Virtualbox 的設定，多掛載了 1GB 的記憶體給 Ubuntu VM，於是多出了一個 /dev/sdb 可以切。然後早上就順利把 HW3 做完了。\n中午吃了麥當勞，點了玉米湯，在宿舍泡伯爵茶一直冷掉。\n房間的濕度約為 65%，溫度則為 15 度左右。但外面似乎已經到 8 度了，超級冷的。穿了羽絨衣跟襪子，但還是手腳冰冷。\n開始複習電路學期末，下午讀了第 15 和 16 章，有關 Laplace 的部分，也自己導了 Initial/Final-Value Theorem。\n看到 Slack 有人說 CSES 增加題目了，於是想起自己還剩一堆沒刷，就開了一題恢復手感。\n借了 HW2 的 Code 給雙曲線參考，順便讓他幫我跑一下，不然我一直無法解決找不到 /dev/os 的問題，沒想到晚上他告訴我，在他那邊跑是對的，真是太好了！\n晚上吃了麻油雞麵，暖暖身體。飯後看了電影「爺爺與貓」。\nCSES - 2189 - Point Location Test 基礎的幾何題。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;ll, ll\u0026gt; point; 5#define x first 6#define y second 7ll check(point p[]) { 8 ll dx = p[1].x - p[0].x, dy = p[1].y - p[0].y; 9 return (p[2].y - p[1].y) * dx + (p[1].x - p[2].x) * dy; 10} 11int main () { 12 ios::sync_with_stdio(0), cin.tie(0); 13 int t; cin \u0026gt;\u0026gt; t; 14 while (t--) { 15 point p[3]; 16 for (int i = 0; i \u0026lt; 3; i++) 17 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 18 ll c = check(p); 19 if (c \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#34;LEFT\\n\u0026#34;; 20 else if (c \u0026lt; 0) cout \u0026lt;\u0026lt; \u0026#34;RIGHT\\n\u0026#34;; 21 else cout \u0026lt;\u0026lt; \u0026#34;TOUCH\\n\u0026#34;; 22 } 23 return 0; 24}  爺爺與貓（ねことじいちゃん） 因為九月時媽媽傳了連結給我，於是今晚有空就決定來看這部了。\n導演是岩合光昭，他在 NHK 有電視節目岩合光昭的貓步走世界（岩合光昭の世界ネコ歩き），好想看！！\n故事是描述在小島上面的老爺爺老奶奶們和貓咪的故事，主角是小玉和阿吉爺爺。查了一下是由漫畫改編。\n","date":"2021-01-08T14:39:43+08:00","permalink":"https://Luke2336.github.io/p/20210108/","title":"2021/01/08 日記"},{"content":"中午還是懶得去跟電資一起在校門口拍照，我想系羽消失後，我對電資的歸屬感就也一起消散了。\n下午擔任了「傳說中的助教」，幫忙老師 demo 三個 Lab。\n上了電路學，覺得很冷很想睡，最後上了一點要用到線代解微方的東西，覺得要好好研究一下，不然考試會卡住。\n寄信給 OS TA，結果還是解決不了沒有 /dev/os 的問題，他建議把 ubuntu 重裝。\n晚上吃了 pizza，點了瑪格麗特，還有一個奇怪的大蒜口味，吃起來非常的蒜 QAQ\n然後開始寫 OS HW3，因為我 /dev/sda 的空間沒辦法再切割記憶體，所以用了很久還是解決不了。\n","date":"2021-01-07T11:01:51+08:00","permalink":"https://Luke2336.github.io/p/20210107/","title":"2021/01/07 日記"},{"content":"昨天下腹不舒服，花了一段時間才入睡。早上躺到十點才起床，中間醒來了兩次。\n醒來後就開始寫作業，有了進度後就去買了雞腿便當吃，然後把韓劇「我的女友是九尾狐」看完，雖然國小時已經看過一遍，但最近突然想重溫一下。\n之後把 HW2 的 PartI-1 寫完，主要是把函式的參數做修正，使兩隻程式的 shmget 回傳的 id 是一樣的。午睡起床後寫了 PartII。\n晚餐吃了壽司，肚子略略不舒服，吃了阿德比之後就好了。\nOS HW2  學會用 shmget() 和 shmat() 使兩個 processes 共享記憶體。  shmget() 的參數要注意，兩個程式的 key 值要是一樣的正整數。而 shmflg 的值則是建立記憶體的那隻程式設為 IPC_CREAT|0666，另一隻設 0。   PartII 是要把兩個 pointer 的 page table 指向同一個 physical address。重點是用 cr3 和 virtual_address 取得 page_table_address。  ","date":"2021-01-06T10:28:28+08:00","permalink":"https://Luke2336.github.io/p/20210106/","title":"2021/01/06 日記"},{"content":"早上很想睡，但還是去上了電路學。今天是教如何在 s-domain 下用 Laplace Transform 解電路，比較需要注意的就是 Initial Condition 的部分。\n下午為了寫 OS 作業，所以裝了 TA 提供的 Ubuntu VM。這是我第一次裝 Linux，平常只有比賽的時候會使用 Linux。\n晚餐前注意到含羞草開花了。\n晚上去上了電路學的助教課，結果只有我一個人去，有個女生十幾分鐘就說身體不舒服離開了。結束時和助教隨口聊了一下天，才知道他大學是讀清大。\n在 VirtualBox 裝 Ubuntu  在官網下載 VirtualBox-6.1.16-140961-OSX.dmg。  點擊 VirtualBox.pkg 安裝。 下載 TA 提供的 Ubuntu-18.04 VM 使用 VB 匯入 Ubuntu-VM.ovf。  啟動 VM，將需要用到的 Terminal 和 gedit 拉到左邊。   含羞草開花 不知道是不是因為最近太冷了，加上給的水少，所以就長出花苞了。有一個好像已經謝了，看了一下網路上的文章，他開花到凋謝的時間大概五六小時，希望有機會能看到花。\n","date":"2021-01-05T13:35:28+08:00","permalink":"https://Luke2336.github.io/p/20210105/","title":"2021/01/05 日記"},{"content":"AtCoder Educational DP Contest  [於 Feb, 2020 完成]\n這套從簡到難的 DP 題組，有不少經典題，很適合照順序刷。 開始刷了之後，才發現自己實力的不足，有幾題想了很久還是想不出來，只好去翻別人的解答。刷完發現 code 都不長，狀態也不難列，但轉移式都要想很久。\n A. Frog 1 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); 5 int dp[2] = {}, a[2] = {}; 6 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[1], \u0026amp;a[0]); 7 dp[0] = abs(a[1] - a[0]); 8 for (int i = 3; i \u0026lt;= N; i++) { 9 int x; scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); 10 dp[i % 2] = min(dp[i % 2] + abs(x - a[i % 2]), 11 dp[(i + 1) % 2] + abs(x - a[(i + 1) % 2])); 12 a[i % 2] = x; 13 } 14 printf(\u0026#34;%d\\n\u0026#34;, dp[N % 2]); 15 return 0; 16}  B. Frog 2 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 100005 4int main() { 5 int n, k; 6 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); 7 int a[maxn], dp[maxn]; 8 for (int i = 1; i \u0026lt;= n; i++) 9 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 10 for (int i = 1; i \u0026lt;= n; i++) { 11 if (i \u0026lt;= k) dp[i] = abs(a[i] - a[1]); 12 else { 13 dp[i] = dp[i - 1] + abs(a[i] - a[i - 1]); 14 for (int j = 2; j \u0026lt;= k; j++) 15 dp[i] = min(dp[i], 16 dp[i - j] + abs(a[i] - a[i - j])); 17 } 18 } 19 printf(\u0026#34;%d\\n\u0026#34;, dp[n]); 20 return 0; 21}  C. Vacation 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 5 int dp[2][3] = {}; 6 for (int i = 1; i \u0026lt;= n; i++) 7 for (int j = 0; j \u0026lt; 3; j++) { 8 int x; scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); 9 dp[i % 2][j] = x + max(dp[(i + 1) % 2][(j + 1) % 3], 10 dp[(i + 1) % 2][(j + 2) % 3]); 11 } 12 printf(\u0026#34;%d\\n\u0026#34;, max(dp[n % 2][0], 13 max(dp[n % 2][1], dp[n % 2][2]))); 14 return 0; 15}  D. Knapsack 1 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxW 100005 4int main() { 5 int n, W; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;W); 6 long long dp[maxW] = {}; 7 for(int i = 0; i \u0026lt; n; i++) { 8 int w, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); 9 for(int j = W; j \u0026gt;= w; j--) 10 dp[j] = max(dp[j], dp[j - w] + v); 11 } 12 printf(\u0026#34;%lld\\n\u0026#34;, dp[W]); 13 return 0; 14}  E. Knapsack 2 dp[j] 為價值為 j 需要的物品最低重量。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 int n, W; 5 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;W); 6 int dp[100005] = {}; 7 for (int i = 1; i \u0026lt; 100005; i++) 8 dp[i] = 1000000005; 9 for (int i = 0; i \u0026lt; n; i++) { 10 int v, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); 11 for(int j = 100000; j \u0026gt;= v; j--) 12 dp[j] = min(dp[j], dp[j-v] + w); 13 } 14 for (int i = 100000; i \u0026gt;= 0; i--) 15 if (dp[i] \u0026lt;= W) { 16 printf(\u0026#34;%d\\n\u0026#34;, i); 17 break; 18 } 19 return 0; 20}  F. LCS 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int dp[3005][3005]; 4int p[3005][3005]; 5int main() { 6 ios_base::sync_with_stdio(0), cin.tie(0); 7 string s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; 8 int lens = s.length(), lent = t.length(); 9 for (int i = 1; i \u0026lt;= lens; i++) { 10 for (int j = 1; j \u0026lt;= lent; j++) { 11 if (s[i - 1] == t[j - 1]) { 12 dp[i][j] = dp[i - 1][j - 1] + 1; 13 p[i][j] = 1; 14 } else if (dp[i][j - 1] \u0026gt; dp[i - 1][j]) { 15 dp[i][j] = dp[i][j - 1]; 16 p[i][j] = 2; 17 } else { 18 dp[i][j] = dp[i - 1][j]; 19 p[i][j] = 3; 20 } 21 } 22 } 23 string ans = \u0026#34;\u0026#34;; 24 int ni = lens, nj = lent; 25 while (ni \u0026amp;\u0026amp; nj) { 26 if (p[ni][nj] == 1) { 27 ans = s[ni - 1] + ans; 28 ni--, nj--; 29 } else if (p[ni][nj] == 2) nj--; 30 else ni--; 31 } 32 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 33 return 0; 34}  G. Longest Path 類似拓樸排序的方式在 DAG（有向無環圖）上做 dp。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 100005 4int main() { 5 int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); 6 int in[maxn] = {}, dp[maxn] = {}; 7 vector\u0026lt;int\u0026gt; e[maxn]; 8 for (int i = 0; i \u0026lt; m; i++) { 9 int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); 10 e[a].push_back(b); 11 in[b]++; 12 } 13 queue\u0026lt;int\u0026gt; q; 14 for (int i = 1; i \u0026lt;= n; i++) 15 if (!in[i]) q.push(i); 16 while (!q.empty()) { 17 int u = q.front(); q.pop(); 18 for (int uu: e[u]) { 19 in[uu]--; 20 dp[uu] = max(dp[uu], dp[u] + 1); 21 if (!in[uu]) q.push(uu); 22 } 23 } 24 int ans = 0; 25 for (int i = 1; i \u0026lt;= n; i++) 26 ans = max(ans, dp[i]); 27 printf(\u0026#34;%d\\n\u0026#34;, ans); 28 return 0; 29}  H. Grid 1 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define mod 1000000007 4int main() { 5 int h, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;h, \u0026amp;w); 6 int dp[1005] = {}; 7 char c[1005]; 8 for (int i = 1; i \u0026lt;= h; i++) { 9 scanf(\u0026#34;%s\u0026#34;, c + 1); 10 for (int j = 1; j \u0026lt;= w; j++) 11 if (c[j] == \u0026#39;#\u0026#39;) dp[j] = 0; 12 else if (i == 1 \u0026amp;\u0026amp; j == 1) dp[j] = 1; 13 else dp[j] = (dp[j] + dp[j - 1]) % mod; 14 } 15 printf(\u0026#34;%d\\n\u0026#34;, dp[w]); 16 return 0; 17}  I. Coins 機率的 dp，所以難得用到 double。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 3000 4int main() { 5 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 6 double dp[maxn] = {1.0}; 7 for (int i = 1; i \u0026lt;= n; i++) { 8 double p; scanf(\u0026#34;%lf\u0026#34;, \u0026amp;p); 9 for (int j = min(i, n / 2); j \u0026gt; 0; j--) 10 dp[j] = dp[j] * (1 - p) + dp[j - 1] * p; 11 dp[0] = dp[0] * (1 - p); 12 } 13 double ans = 1; 14 for(int i = 0; i \u0026lt;= n / 2; i++) 15 ans -= dp[i]; 16 printf(\u0026#34;%.9f\\n\u0026#34;, ans); 17 return 0; 18}  J. Sushi i 為剩 3 個，j 為剩 2 個，k 為剩 1 個的盤子數量。\n$$DP_{i,j,k} = 1 + \\frac{(n-i-j-k) DP_{i,j,k} + i DP_{i-1,j+1,k} + j DP_{i,j-1,k+1} + k DP_{i,j,k-1}}{n}$$\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 305 4double dp[maxn][maxn][maxn]; 5inline double dfs(int i, int j, int k, int n) { 6 if(i \u0026lt; 0 || j \u0026lt; 0 || k \u0026lt; 0) return 0; 7 if (dp[i][j][k] \u0026gt; -1) return dp[i][j][k]; 8 return dp[i][j][k] = (i * dfs(i - 1, j + 1, k, n) + 9 j * dfs(i, j - 1, k + 1, n) + 10 k * dfs(i, j, k - 1, n) + 11 n) / (i + j + k); 12} 13int main() { 14 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 15 int cnt[4] = {}; 16 for (int i = 0; i \u0026lt; n; i++) { 17 int x; cin \u0026gt;\u0026gt; x; 18 cnt[x]++; 19 } 20 for (int i = 0; i \u0026lt;= n; i++) 21 for (int j = 0; j \u0026lt;= n; j++) 22 for (int k = 0; k \u0026lt;= n; k++) 23 dp[i][j][k] = -10; 24 dp[0][0][0] = 0; 25 printf(\u0026#34;%.9f\\n\u0026#34;, dfs(cnt[3], cnt[2], cnt[1], n)); 26 return 0; 27}  K. Stones 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 105 4#define maxk 100005 5int main() { 6 int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); 7 int a[maxn]; 8 bool dp[maxk] = {0}; 9 for (int i = 0; i \u0026lt; n; i++) 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 11 for (int i = 0; i \u0026lt;= k; i++) 12 if(!dp[i]) 13 for (int j = 0; j \u0026lt; n; j++) 14 if(i + a[j] \u0026lt;= k) 15 dp[i + a[j]] = true; 16 if (dp[k]) printf(\u0026#34;First\\n\u0026#34;); 17 else printf(\u0026#34;Second\\n\u0026#34;); 18 return 0; 19}  L. Deque 第一次遇到這題是在 2019NCPC，當時思考了很久能不能 Greedy，後來才想到是 0-sum game。於是用了 minimax 的概念，設計出狀態。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long LL; 4int main() { 5 ios_base::sync_with_stdio(0), cin.tie(0); 6 int n; cin \u0026gt;\u0026gt; n; 7 vector\u0026lt;LL\u0026gt; v(n+2); 8 for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; v[i]; 9 vector\u0026lt;vector\u0026lt;LL\u0026gt; \u0026gt; dp(n + 2, vector\u0026lt;LL\u0026gt;(n + 2,0)); 10 for (int len = 1; len \u0026lt;= n; len++) 11 for (int i = 1, j = len; j \u0026lt;= n; i++, j++) 12 if(len % 2 == n % 2) 13 dp[i][j] = max(dp[i + 1][j] + v[i], 14 dp[i][j - 1] + v[j]); 15 else 16 dp[i][j] = min(dp[i + 1][j] - v[i], 17 dp[i][j - 1] - v[j]); 18 cout \u0026lt;\u0026lt; dp[1][n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 19 return 0; 20}  M. Candies dp[i][j] 發到第 i 人剩下 j 顆糖的方法數，用滾動優化空間複雜度。\ndp[i][j] = dp[i-1][j] + \u0026hellip; + dp[i-1][j+a[i]]。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxk 100005 4#define maxn 105 5#define mod 1000000007 6int main() { 7 int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); 8 int a[maxn], dp[2][maxk]; 9 for (int i = 1; i \u0026lt;= n; i++) 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 11 dp[0][k] = 1; 12 for(int i = 1; i \u0026lt;= n; i++) { 13 int sum = 0; 14 for(int j = k; j \u0026gt;= 0; j--) { 15 sum = (sum + dp[(i + 1) \u0026amp; 1][j]) % mod; 16 if(j + a[i] + 1 \u0026lt;= k) 17 sum = (sum + mod 18 - dp[(i + 1) \u0026amp; 1][j + a[i] + 1]) % mod; 19 dp[i \u0026amp; 1][j] = sum; 20 } 21 } 22 printf(\u0026#34;%d\\n\u0026#34;, dp[n \u0026amp; 1][0]); 23 return 0; 24}  N. Slimes dp[i][j] 為合併史萊姆 i ~ j 所需的最小 cost。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 405 4#define INF 100000000000000 5typedef long long LL; 6int main() { 7 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 8 int a[maxn]; 9 for (int i = 1; i \u0026lt;= n; i++) 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 11 LL sum[maxn] = {}; 12 LL dp[maxn][maxn] = {}; 13 for (int i = 1; i \u0026lt;= n; i++) 14 sum[i] = sum[i - 1] + a[i]; 15 for (int len = 2; len \u0026lt;= n ; len++) 16 for(int i = 1, j = i + len - 1; j \u0026lt;= n; i++, j++) { 17 dp[i][j] = INF; 18 for (int k = i; k \u0026lt; j; k++) 19 dp[i][j] = min(dp[i][j], 20 dp[i][k] + dp[k + 1][j] + sum[j] - sum[i - 1]); 21 } 22 printf(\u0026#34;%lld\\n\u0026#34;, dp[1][n]); 23 return 0; 24}  O. Matching 位元 dp。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 23 4#define maxm (1\u0026lt;\u0026lt;21)+5 5#define mod 1000000007 6int dp[maxm] = {1}; 7int main() { 8 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 9 int a[maxn][maxn]; 10 for (int i = 0; i \u0026lt; n; i++) 11 for (int j = 0; j \u0026lt; n; j++) 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); 13 int M = (1 \u0026lt;\u0026lt; n) - 1; 14 for (int j = 0; j \u0026lt;= M; j++) { 15 int i = __builtin_popcount(j) - 1; 16 for (int k = 0; k \u0026lt; n; k++) 17 if (j \u0026amp; (1 \u0026lt;\u0026lt; k) \u0026amp;\u0026amp; a[i][k]) 18 dp[j] = (dp[j] + dp[j - (1 \u0026lt;\u0026lt; k)]) % mod; 19 } 20 printf(\u0026#34;%d\\n\u0026#34;, dp[M]); 21 return 0; 22}  P. Independent Set 經典樹 dp。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 100005 4#define mod 1000000007 5vector\u0026lt;int\u0026gt; e[maxn]; 6long long dp[maxn][2] = {}; 7void dfs(int v, int p) { 8 dp[v][0] = dp[v][1] = 1; 9 for (int u : e[v]) { 10 if (u == p) continue; 11 dfs(u, v); 12 dp[v][0] = dp[v][0] * (dp[u][0] + dp[u][1]) % mod; 13 dp[v][1] = dp[v][1] * dp[u][0] % mod; 14 } 15} 16int main() { 17 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 18 for (int i = 1; i \u0026lt; n; i++) { 19 int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); 20 e[a].push_back(b), e[b].push_back(a); 21 } 22 dfs(1, 0); 23 printf(\u0026#34;%lld\\n\u0026#34;, (dp[1][1] + dp[1][0]) % mod); 24 return 0; 25}  Q. Flowers 帶權最長遞增子序列（Weighted Longest Increasing Subsequence）。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 200005 4typedef long long LL; 5int main() { 6 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 int h[maxn], a[maxn]; 8 for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;h[i]); 9 for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 10 map\u0026lt;int, LL\u0026gt; m; m[0] = 0; 11 for(int i = 0; i\u0026lt;n; i++) { 12 map\u0026lt;int,LL\u0026gt;::iterator iter, iter_tmp; 13 iter = m.lower_bound(h[i]); 14 iter--; 15 LL val = iter-\u0026gt;second + a[i]; 16 iter++; 17 while(iter != m.end() \u0026amp;\u0026amp; iter-\u0026gt;second \u0026lt;= val) { 18 iter_tmp = iter; 19 iter_tmp++; 20 m.erase(iter); 21 iter = iter_tmp; 22 } 23 m[h[i]] = val; 24 } 25 printf(\u0026#34;%lld\\n\u0026#34;, m.rbegin()-\u0026gt;second); 26 return 0; 27}  R. Walk 矩陣快速冪。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 55 4#define mod 1000000007 5typedef long long LL; 6struct matrix { 7 int sz; 8 int m[maxn][maxn]; 9 matrix(){} 10 matrix(int n) : sz(n) { memset(m, 0, sizeof(m)); } 11 void operator = (const matrix \u0026amp;A) { 12 for (int i = 0; i \u0026lt; sz; i++) 13 for (int j = 0; j \u0026lt; sz; j++) 14 m[i][j] = A.m[i][j]; 15 } 16 matrix operator*(const matrix \u0026amp;A) { 17 matrix B(sz); 18 for (int i = 0; i \u0026lt; sz; i++) 19 for (int j = 0; j \u0026lt; sz; j++) { 20 B.m[i][j] = 0; 21 for (int k = 0; k \u0026lt; sz; k++) 22 B.m[i][j] = ((LL)m[i][k] * A.m[k][j] % mod 23 + B.m[i][j]) % mod; 24 } 25 return B; 26 } 27}; 28matrix pow(matrix A, LL k) { 29 matrix ans(A.sz); 30 for (int i = 0; i \u0026lt; A.sz; i++) 31 ans.m[i][i] = 1; 32 while (k) { 33 if (k \u0026amp; 1) ans = ans * A; 34 k \u0026gt;\u0026gt;= 1; 35 A = A * A; 36 } 37 return ans; 38} 39int main() { 40 int n; 41 LL k; 42 scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;k); 43 matrix A(n); 44 for (int i = 0; i \u0026lt; n; i++) 45 for (int j = 0; j \u0026lt; n; j++) 46 scanf(\u0026#34;%d\u0026#34;, \u0026amp;A.m[i][j]); 47 matrix ans = pow(A, k); 48 int cnt = 0; 49 for (int i = 0; i \u0026lt; n; i++) 50 for (int j = 0; j \u0026lt; n; j++) 51 cnt = (cnt + ans.m[i][j]) % mod; 52 printf(\u0026#34;%d\\n\u0026#34;, cnt); 53 return 0; 54}  S. Digit Sum dp[i][j][k]：到第 i 個字母，同餘 j 的方法數，k 代表前 i 位是否和 input 的前 i 位一致。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define mod 1000000007 4int dp[2][102][2] = {}; 5inline void add(int \u0026amp;a, int b) { 6 a = (a + b % mod) % mod; 7} 8int main() { 9 ios_base::sync_with_stdio(0); 10 cin.tie(0); 11 string s; int d; 12 cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; d; 13 int len = s.length(); 14 dp[1][0][1] = 1; 15 for (int i = 0; i \u0026lt; len; i++) { 16 memset(dp[i \u0026amp; 1], 0, sizeof(dp[i \u0026amp; 1])); 17 for (int j = 0; j \u0026lt; d; j++) 18 for (int k = 0; k \u0026lt;= 9; k++) 19 if(k \u0026lt; s[i]-\u0026#39;0\u0026#39;) 20 add(dp[i \u0026amp; 1][(j + k) % d][0], 21 dp[!(i \u0026amp; 1)][j][0]), 22 add(dp[i \u0026amp; 1][(j + k) % d][0], 23 dp[!(i \u0026amp; 1)][j][1]); 24 else if (k == s[i] - \u0026#39;0\u0026#39;) 25 add(dp[i \u0026amp; 1][(j + k) % d][0], 26 dp[!(i \u0026amp; 1)][j][0]), 27 add(dp[i \u0026amp; 1][(j + k) % d][1], 28 dp[!(i \u0026amp; 1)][j][1]); 29 else 30 add(dp[i \u0026amp; 1][(j + k) % d][0], 31 dp[!(i \u0026amp; 1)][j][0]); 32 } 33 cout \u0026lt;\u0026lt; (dp[!(len \u0026amp; 1)][0][0] + 34 dp[!(len \u0026amp; 1)][0][1] - 1 + mod) % mod \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 35 return 0; 36}  T. Permutation dp[i][j] 定義為前 i + 1 個數字結尾為 j 的組合數為多少（1 ≤ j ≤ i + 1）。 前綴和加速到 O(n²)。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3const int mod = 1000000007; 4int main() { 5 ios_base::sync_with_stdio(0),cin.tie(0); 6 int n; 7 string s; 8 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; 9 vector\u0026lt;int\u0026gt; dp(n + 1, 0), sum(n + 1, 1); 10 dp[1] = 1, sum[0] = 0; 11 for (int i = 1; i \u0026lt; n; i++) { 12 for (int j = 1; j \u0026lt;= i + 1; j++) { 13 if (s[i - 1] == \u0026#39;\u0026gt;\u0026#39;) 14 dp[j] = (sum[i] - sum[j - 1] + mod) % mod; 15 else 16 dp[j] = sum[j - 1]; 17 } 18 for (int j = 1; j \u0026lt;= n; j++) 19 sum[j] = (sum[j - 1] + dp[j]) % mod; 20 } 21 cout \u0026lt;\u0026lt; sum[n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 22 return 0; 23}  U. Grouping 學會枚舉子集的辦法了！！\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4int main() { 5 ios_base::sync_with_stdio(0), cin.tie(0); 6 int n; cin \u0026gt;\u0026gt; n; 7 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a(n, vector\u0026lt;int\u0026gt;(n)); 8 for (int i = 0; i \u0026lt; n; i++) 9 for (int j = 0; j \u0026lt; n; j++) 10 cin \u0026gt;\u0026gt; a[i][j]; 11 int m = (1 \u0026lt;\u0026lt; n); 12 vector\u0026lt;ll\u0026gt; cnt(m), dp(m); 13 for (int s = 0; s \u0026lt; m; s++) 14 for (int i = 0; i \u0026lt; n; i++) 15 if (s \u0026amp; (1 \u0026lt;\u0026lt; i)) 16 for (int j = i; j \u0026lt; n; j++) 17 if (s \u0026amp; (1 \u0026lt;\u0026lt; j)) 18 cnt[s] += a[i][j]; 19 for (int s = 0; s \u0026lt; m; s++) 20 for (int sub = s; sub \u0026gt; 0; sub = (sub - 1) \u0026amp; s) 21 dp[s] = max(dp[s], dp[s - sub] + cnt[sub]); 22 cout \u0026lt;\u0026lt; dp[m - 1] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 23 return 0; 24}  V. Subtree 參考 codeforces 這篇討論 才寫出來。\n解法：（有根樹）。\n up/down[node] 是 node 以上/下的點塗黑的方法數。 down 的不難算，直接 dfs 做樹 dp 就行了。 up 需要用到 down 的結果，算如果取 parent，其他子樹 down 的方法數。 +1 代表不取 parent。 最後各點的結果為 up * down。 算其他子樹的方法和，因為需要取 mod 且模數不為質數，故需要維護其前/後綴積。  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4#define maxn 100005 5#define pb push_back 6int mod; 7vector\u0026lt;int\u0026gt; e[maxn]; 8vector\u0026lt;ll\u0026gt; pre[maxn], suf[maxn]; 9ll up[maxn], down[maxn]; 10void dfs1(int u, int p) { 11 for (int uu : e[u]) 12 if (uu != p) dfs1(uu, u); 13 for (int i = 0; i \u0026lt; e[u].size(); i++) { 14 int uu = e[u][i]; 15 pre[u][i] = i ? pre[u][i-1] : 1; 16 if(uu != p) 17 pre[u][i] = pre[u][i] * (1 + down[uu]) % mod; 18 } 19 for (int i = e[u].size() - 1; i \u0026gt;= 0; i--) { 20 int uu = e[u][i]; 21 suf[u][i] = (i \u0026lt; e[u].size() - 1) ? suf[u][i + 1] : 1; 22 if(uu != p) 23 suf[u][i] = suf[u][i] * (1 + down[uu]) % mod; 24 } 25 down[u] = suf[u][0]; 26} 27void dfs2(int u, int p) { 28 for (int i = 0; i \u0026lt; e[u].size(); i++) { 29 int uu = e[u][i]; 30 if (uu == p) continue; 31 ll cnt = up[u]; 32 if(i) 33 cnt = cnt * pre[u][i - 1] % mod; 34 if(i + 1 \u0026lt; e[u].size()) 35 cnt = cnt * suf[u][i + 1] % mod; 36 up[uu] = cnt + 1; // 1是不取par 37 dfs2(uu, u); 38 } 39} 40int main() { 41 ios_base::sync_with_stdio(0); 42 cin.tie(0); 43 int n; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; mod; 44 for (int i = 1; i \u0026lt; n; i++) { 45 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 46 e[a].pb(b), e[b].pb(a); 47 } 48 e[1].pb(0), up[1] = 1; 49 for (int i = 1; i \u0026lt;= n; i++) { 50 pre[i].resize(e[i].size()); 51 suf[i].resize(e[i].size()); 52 } 53 dfs1(1, 0), dfs2(1, 0); 54 for (int i = 1; i \u0026lt;= n; i++) 55 cout \u0026lt;\u0026lt; down[i] * up[i] % mod \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 56 return 0; 57}  W. Intervals  題意： 給定 M (1 ≤ M ≤ 200000) 組 (l[i], r[i]) (1 ≤ l[i] ≤ r[i] ≤ N ≤ 200000) 和 a[i] (|a[i]| ≤ 1000000000)。 當 l[i] ~ r[i] 至少有一個 1 的 a[i] 分，問構造出長度 N 的 01 字串最高得幾分。 解法：  轉移式：dp[i] = max{ dp[j] + sum{a[k]} }, j \u0026lt; l[k] ≤ i ≤ r[k] 優化：區間加值線段樹維護最大值。    1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, ll\u0026gt; pil; 5#define ls i \u0026lt;\u0026lt; 1 6#define rs i \u0026lt;\u0026lt; 1 | 1 7class RangeUpdateSegmentTree { 8 private: 9 struct node { 10 int l, r; 11 ll x = 0, adt = 0; 12 }; 13 vector\u0026lt;node\u0026gt; a; 14 void push(int i) { 15 if (a[i].adt) { 16 a[ls].adt += a[i].adt, a[rs].adt += a[i].adt; 17 a[ls].x += a[i].adt, a[rs].x += a[i].adt; 18 a[i].adt = 0; 19 } 20 } 21 void pull(int i) { 22 a[i].x = max(a[ls].x, a[rs].x); 23 } 24 void build(int l, int r, int i) { 25 a[i].l = l, a[i].r = r; 26 if (l == r) return; 27 int mid = (l + r) \u0026gt;\u0026gt; 1; 28 build(l, mid, ls), build(mid + 1, r, rs); 29 } 30 public: 31 RangeUpdateSegmentTree(int n) : a(n \u0026lt;\u0026lt; 2) { 32 build(0, n, 1); 33 } 34 void add(int l, int r, ll val, int i = 1) { 35 if (a[i].l \u0026gt;= l \u0026amp;\u0026amp; a[i].r \u0026lt;= r) { 36 a[i].x += val; 37 a[i].adt += val; 38 return; 39 } 40 push(i); 41 int mid = (a[i].l + a[i].r) \u0026gt;\u0026gt; 1; 42 if (l \u0026lt;= mid) add(l, r, val, ls); 43 if (r \u0026gt; mid) add(l, r, val, rs); 44 pull(i); 45 } 46 ll maxx(int l, int r, int i = 1) { 47 if (l \u0026lt;= a[i].l \u0026amp;\u0026amp; a[i].r \u0026lt;= r) return a[i].x; 48 push(i); 49 ll ret = -9e18; 50 int mid = (a[i].l + a[i].r) \u0026gt;\u0026gt; 1; 51 if (l \u0026lt;= mid) ret = max(ret, maxx(l, r, ls)); 52 if (r \u0026gt; mid) ret = max(ret, maxx(l, r, rs)); 53 pull(i); 54 return ret; 55 } 56}; 57int main() { 58 ios_base::sync_with_stdio(0); 59 cin.tie(0); 60 int n, m; 61 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 62 vector\u0026lt;ll\u0026gt; add(n + 1); 63 vector\u0026lt;vector\u0026lt;pil\u0026gt;\u0026gt; del(n + 1); 64 for (int i = 0; i \u0026lt; m; i++) { 65 int l, r; ll a; 66 cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; a; 67 add[l] += a; 68 del[r].push_back(pil(l, a)); 69 } 70 RangeUpdateSegmentTree ST(n + 1); 71 ll ans = 0; 72 for (int i = 1; i \u0026lt;= n; i++) { 73 ST.add(0, i - 1, add[i]); 74 ll tmp = ST.maxx(0, i - 1); 75 ans = max(ans, tmp); 76 ST.add(i, i, tmp); 77 for (pil p : del[i]) 78 ST.add(0, p.first - 1, -p.second); 79 } 80 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 81 return 0; 82}  X. Tower 將 solidness 排序後，再做 dp。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long LL; 4typedef pair\u0026lt;int,int\u0026gt; pii; 5typedef pair\u0026lt;int,pii\u0026gt; box; 6#define s first 7#define w second.first 8#define v second.second 9#define maxn 1005 10#define maxs 20005 11int main() { 12 int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); 13 box b[maxn]; 14 for(int i=0; i\u0026lt;n; i++){ 15 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;b[i].w, \u0026amp;b[i].s, \u0026amp;b[i].v); 16 b[i].s += b[i].w; 17 } 18 sort(b, b + n); 19 LL dp[maxs] = {}; 20 LL ans = 0; 21 for (int i = 0; i \u0026lt; n; i++) { 22 for (int j = b[i].s; j \u0026gt;= b[i].w; j--) { 23 dp[j] = max(dp[j], dp[j - b[i].w] + b[i].v); 24 ans = max(ans, dp[j]); 25 } 26 } 27 printf(\u0026#34;%lld\\n\u0026#34;, ans); 28 return 0; 29}  Y. Grid 2 如果沒有障礙物，答案會是 C(h - 1 + w - 1, h - 1)。 有障礙物，就將障礙物那格的答案扣掉 C(x[i] - x[j] + y[i] - y[j], x[i] - x[j]) 次。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4typedef long long ll; 5#define x first 6#define y second 7#define mod 1000000007 8#define LEN 200005 9ll frc[LEN], inv[LEN]; 10ll modinv(ll a, ll p = mod) { 11 if (p == 1) return 0; 12 ll pp = p, y = 0, x = 1; 13 while (a \u0026gt; 1) { 14 ll q = a / p, t = p; 15 p = a % p, a = t, t = y, y = x - q * y, x = t; 16 } 17 if (x \u0026lt; 0) x += pp; 18 return x; 19} 20void init() { 21 frc[0] = frc[1] = inv[0] = inv[1] = 1; 22 for (int i = 2; i \u0026lt; LEN; i++) { 23 frc[i] = frc[i - 1] * i % mod; 24 inv[i] = modinv(frc[i]); 25 } 26} 27inline ll C(int a, int b) { 28 return frc[a + b] * inv[a] % mod * inv[b] % mod; 29} 30inline void sub(ll \u0026amp;a, ll b) { 31 a = (a - b % mod + mod) % mod; 32} 33int main() { 34 ios_base::sync_with_stdio(0); 35 cin.tie(0); 36 init(); 37 int h, w, n; 38 cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w \u0026gt;\u0026gt; n; 39 vector\u0026lt;pii\u0026gt; p(n); 40 for (int i = 0; i \u0026lt; n; i++) 41 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 42 sort(p.begin(), p.end()); 43 p.push_back(pii(h, w)); 44 vector\u0026lt;ll\u0026gt; dp(n + 1, 0); 45 for (int i = 0; i \u0026lt;= n; i++) { 46 dp[i] = C(p[i].x - 1, p[i].y - 1); 47 for (int j = 0; j \u0026lt; i; j++) 48 if (p[i].y \u0026gt;= p[j].y) 49 sub(dp[i], dp[j] * C(p[i].x - p[j].x, p[i].y - p[j].y)); 50 } 51 cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 52 return 0; 53}  Z. Grid 3 h[i] 為遞增，故可斜率優化，總複雜度 O(N)。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4int main() { 5 ios_base::sync_with_stdio(0), cin.tie(0); 6 int n; ll C; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; C; 7 vector\u0026lt;ll\u0026gt; h(n + 1); 8 for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; h[i]; 9 vector\u0026lt;ll\u0026gt; dp(n + 1); 10 deque\u0026lt;int\u0026gt; dq(1, 1); 11 auto X = [\u0026amp;](int i) { 12 return -2 * h[i]; 13 }; 14 auto Y = [\u0026amp;](int i) { 15 return h[i] * h[i] + dp[i]; 16 }; 17 auto F = [\u0026amp;](int i, int j) { 18 return h[i] * X(j) + Y(j) + C + h[i] * h[i]; 19 }; 20 auto cross = [](ll x1, ll y1, ll x2, ll y2) { 21 return x1 * y2 - x2 * y1; 22 }; 23 for (int i = 2; i \u0026lt;= n; i++) { 24 while (dq.size() \u0026gt;= 2) { 25 if (F(i, dq[0]) \u0026gt;= F(i, dq[1])) 26 dq.pop_front(); 27 else break; 28 } 29 dp[i] = F(i, dq[0]); 30 while (dq.size() \u0026gt;= 2) { 31 int j = dq.back(), k = dq[dq.size()-2]; 32 if (cross(X(j)-X(k), Y(j)-Y(k), X(i)-X(j), Y(i)-Y(j)) \u0026gt;= 0) 33 dq.pop_back(); 34 else break; 35 } 36 dq.push_back(i); 37 } 38 cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 39 return 0; 40}  ","date":"2021-01-04T11:59:31+08:00","permalink":"https://Luke2336.github.io/p/atcoder_education_dp/","title":"AtCoder Educational DP Contest"},{"content":"為了寫 OS 功課，下午去計中想試著裝 Ubuntu，但因為記憶體只有 1GB，所以根本不可能。最後想了一下，應該只需要用 Linux 就可以完成功課了，但是用工作站的 Linux 卻抓不到 Kernel Header。心累～\n很開心 nini 學妹下午從台北回來時，買了蛋糕給我吃。\n洗完澡後，吃了吐司抹果醬當晚餐。\n","date":"2021-01-04T11:58:39+08:00","permalink":"https://Luke2336.github.io/p/20210104/","title":"2021/01/04 日記"},{"content":"早上起床時覺得很累，先跳繩 200 下，然後整理了房間，買了麥當勞當午餐。\n中午之後就一直在忙 OS 的 HW1，跟 Steven 借了 Code 參考了一下該用哪些 module 和 function，然後就自己寫的更簡短，大約 70 行左右，算一算總共花了 7.5 小時在這份作業。\n晚餐吃了自助餐，因為心情不好，所以就吃了雞腿。\n下週五要交 HW2，週日要交 HW3，覺得有點趕。看了一下 HW2 比較麻煩，要寫 Page Table，雖然只要填空其中一小部分。HW3 和 HW4 似乎都只要下 cmd。\nHW4 可能會放到電路學考完後再處理，好擔心電路學期末爆掉，也很擔心期末專題的事，不想當雷組員。\n","date":"2021-01-03T21:21:24+08:00","permalink":"https://Luke2336.github.io/p/20210103/","title":"2021/01/03 日記"},{"content":"今天滿滿的都是分手的痛，身心都痛，吃不下飯。很難過，但卻沒有人陪。\n下午試著寫了 OS 的 HW1，但還是一團糟。於是就洗個澡，洗衣服，完成了交換的申請文件。\n晚上被隊友約去吃宵夜，遇到了威達，他們聊了很多 SA 的事，我一個人有點孤單，但還是很開心他們把我約出去。\n","date":"2021-01-02T14:29:12+08:00","permalink":"https://Luke2336.github.io/p/20210102/","title":"2021/01/02 日記"},{"content":"吃完漢堡王後，去山上，過敏有點嚴重，晚餐吃了燒肉。\n飯後，ㄠㄨ傳訊息問我問題，聊了幾句之後，決定分手。\n","date":"2021-01-02T14:22:35+08:00","permalink":"https://Luke2336.github.io/p/20210101/","title":"2021/01/01 日記"},{"content":"白天去看了醫生，把電路作業寫完了。\n晚上去牛排店體驗了豬排，然後去清大跨年。\n","date":"2020-12-31T16:54:08+08:00","permalink":"https://Luke2336.github.io/p/20201231/","title":"2020/12/31 日記"},{"content":"CH14 這章用 Frequency Domain 來討論電路學，主要的重點有以下幾個：\n Frequency \u0026amp; Magnitude Responce Bode Plots Resonance, Half-Power Freq., Quality Factor Filter: Lowpass, Highpass, Bandpass, Bandstop Magnitude \u0026amp; Frequency Scaling  ","date":"2020-12-30T15:29:08+08:00","permalink":"https://Luke2336.github.io/p/circuit_ch14/","title":"電路學第 14 章"},{"content":"氣溫驟降，雖然室內有 19 度左右，室外卻只有 11 度，很冷。\n早上考了兩科期末考。中午看到認識語言的總成績已經出來了，94分，比預想的高，原本以為大約 92 分，可能有微微調分吧？\n下午讀了電路學的第 14 章，量有點大。卦長告訴我他看不懂 OS 作業，所以幫不上忙 QAQ 讓我壓力有點大，畢竟現在還有交換申請的自傳還沒寫完，以及電路學的考試和作業，另外還有電路 Final Project 還沒開始弄。\n晚餐吃了狗尾草雞湯，想到很久沒去八分寮吃了～飯後就直接睡了，從八點睡到快十二點，之後心情不太好，到三點多才又開始睡。\n期末考 德文期末考 沒看到公告說 8:15 才開始，結果太早到。\n考試內容不難，都是考文法居多，動詞變化、受格、所有格、冠詞，有點吃虧，我花了不少時間被單字，反而陰陽性沒有記得很熟，但感覺應該是可以有 70 以上。\nOS 期末考 在綜一考試，共 10 題，每題都 10 分，覺得這種配分有點糟，因為有些題是選擇題，選錯就爆了，不像問答題會有部份分。\n考完試不小心把筆袋掉在教室 QAQ\n","date":"2020-12-30T11:01:35+08:00","permalink":"https://Luke2336.github.io/p/20201230/","title":"2020/12/30 日記"},{"content":"早上自己讀了一下 OS 的第五章，中午去寄了信，然後卦長幫我複習了一下第九章之後的內容。\n晚上跟卡車、宗達、彥彤去巨城吃飯，欠了彥彤 $175。\n晚餐後讀了德文，然後喝了一小杯梅酒氣泡水才睡。\n晚上一直做惡夢，有夢到自己被隊友嫌棄，還有一些偏向災難片的夢，醒了三次以上。\n","date":"2020-12-30T11:01:29+08:00","permalink":"https://Luke2336.github.io/p/20201229/","title":"2020/12/29 日記"},{"content":"CH5 - Process Synchronization The Critical-Section Problem 有些資源只能同時被一個 process 使用。\ndo { entry_section(); // critical section  exit_section(); // remainder section while (true);  Mutual Excusion Progress (Freedom from Deadlock) Bounded Wait (Freedom from Starvation)   preemptive: 資源被使用時可以被打斷 non-preemptive  Peterson\u0026rsquo;s Solution class PetersonLock { // shared var.  bool flag[2]; int victim; public: void lock() { int i = ThreadID.get(); int j = 1 - i; flag[i] = true; victim = i; while (flag[j] \u0026amp;\u0026amp; victim == i); } void unlock() { int i = ThreadID.get(); flag[i] = false; } }; do { lock(); // critical section  unlock(); // remainder section while (true); Test \u0026amp; Set // atomic bool test_and_set (bool *target) { bool ret = *target; *taget = true; return ret; } do { wait[i] = true; while (wait[i] \u0026amp;\u0026amp; test_and_set(\u0026amp;lock) ); wait[i] = false; // critical section  j = (i + 1) % n; while ( (j != i) \u0026amp;\u0026amp; !waiting[j] ) j = (j + 1) % n; if (j == i) lock = flase; else wait[j] = false; } while (true); Compare \u0026amp; Swap int compare_and_swap (int * val, int expected, int new_val) { int tmp = *val; if (*val == expected) *val = new_value; return tmp; } do { while (compare_and_swap(\u0026amp;lock, 0, 1) ); // critical section  lock = 0; // remainder section } while (true); Mutex acqueire() and release() are atomic.\nacquire() { while (!available) ; available = false; } release () { available = true; } do { acquire(); // critical section  release(); // remainder section } while (true); Semaphore  counting/binary semaphore semaphore S : integer wait() and signal() are atomic  wait(S) { while (S \u0026lt;= 0) yeild(); S--; } signal(S) { S++; } Implementation (Blocking) struct sempaphore { int cnt; queue q; } void wait(semaphore *S) { S-\u0026gt;cnt--; if (S-\u0026gt;cnt \u0026lt; 0) { S-\u0026gt;q.push(process); block(); } } void signal(semaphore *S) { S-\u0026gt;cnt++; if (S-\u0026gt;cnt \u0026gt;= 0) { P = S-\u0026gt;q.pop(); wakeup(P); } } Examples 1. Bounded-Buffer Problem init Semaphores: mutex-\u0026gt;cnt = 1; full-\u0026gt;cnt = 0; empty-\u0026gt;cnt = N; // producer do { // produce an item  wait(empty); wait(mutex); // add the item to buffer;  buffer[in] = product; in = (in + 1) % N; signal(mutex); signal(full); } while (true); // consumer do { // produce an item  wait(full); wait(mutex); // add the item to buffer;  product = buffer[out]; out = (out + 1) % N; signal(mutex); signal(empty); } while (true); 2. Readers-Writers Problem 3. Dining-Philosophers Problem ","date":"2020-12-28T14:40:40+08:00","permalink":"https://Luke2336.github.io/p/os_ch5/","title":"OS CH5 複習"},{"content":"今天將認識語言的報告寫完，中午就交出去了，傍晚便收到評語，得到了 94 分，覺得很開心，因為有幾個問題被認為提得不錯，主要是對於演化的部分。\n下午又整理了一下德文筆記，讀了一點點 OS，然後晚餐吃了漢堡。頭有點痛，偶而也會暈，這幾天都很早起來，算是輕微失眠。\n","date":"2020-12-28T11:59:10+08:00","permalink":"https://Luke2336.github.io/p/20201228/","title":"2020/12/28 日記"},{"content":"方向 / 方位    中文 German     上 über   下 unter   左 links   右 rechts       中文 German     東 der Osten   西 der Westen   南 der Süden   北 der Norden     Berlin liegt im Osten von Deutschland. in die Mitte  數字用法    Zahlen German Zahlen German Zahlen German     0 null 10 zehn 20 zwanzig   1 eins 11 elf 21 einundzwanzig   2 zwei 12 zwölf     3 drei 13 dreizehn     4 vier 14 vierzehn     5 fünf 15 fünfzehn     6 sechs 16 sechzehn     7 sieben 17 siebzehn     8 acht 18 achtzehn     9 neun 19 neunzehn         Zahlen German     20 zwanzig   30 dreißig   40 vierzig   50 fünfzig   60 sechzig   70 siebzig   100 (ein)hundert   101 hunderteins   1.000 (ein)tausend   10.000 zehntausend   100.000 hunderttausend   1.000.000 eine Million   1.000.000.000 eine Billion    價格 Preis  小數點 (,) 千分位 (.) 100 Cent = 1 Eruo 9,99 € = 9 Euro 99 9,99 € = 50 Cent  WH 疑問句    German English     Was What   Wer Who   Wie How   Wo Where   Woher From where    動詞變化    中文 人稱 規則 machen leben wohnen arbeiten haben sprechen sein     我 ich e mache lebe wohne arbeite habe spreche bin   你 du st machst lebst wohnst arbeitest hast sprichst bist   他/她 er/sie t macht lebt wohnt arbeitet hat spricht ist   我們 wir - machen leben wohnen arbeiten haben sprechen sind   你們 ihr t macht lebt wohnt arbeitet habt spricht seid   他們/您(們) sie/Sie - machen leben wohnen arbeiten haben sprechen sind    自我介紹 Name 姓名  Wie heißen Sie / heißt du? Wer sind Sie / bist du? Ich bin/heiße ___. Mein Name ist ___.  Herkunft 籍貫  Woher kommen Sie / kommst du? Ich komme aus Taiwan.  Wohnort 居住地  Wo wohnen Sie / wohnst du? Ich wohne in ___.  Alter 年齡  Wie alt sind Sie / bist du? Ich bin 20 Jahre alt  Beruf 職業  Was sind Sie / bist du von Beruf? Was machen Sie / machst du beruflich? Ich bin / arbeite als ___ bei ___.  Famienstand  Ich habe ein Kind / zwei, keine Kinder. Ich bin verheirater（結婚） / geschieden（離婚） / Single. Ich leben (nicht) zusammen.（同居）  問候語 打招呼  Hallo. Guten Morgen. Guten Tag. Guten Abend. Gute Nacht.  How are you?  Wie gets es Ihnen? / Wie geht\u0026rsquo;s?  Sehr gut. Gut, danke. Es geht. Nicht so gut.   Gut, danke. Und Ihnen?  Auch gut.    Googbye  Auf Wiedersehen. Tschüs.  Burufe    中文 男生 女生     工程師 der Ingenieur    機械師 der Mechatroniker    演員 der Schauspieler    大學生 der Student die Studentin   記者 der Journalist die Journalistin   髮型師  die Friseurin   建築師  die Architektin   秘書  die Sekretärin   醫生 der Arzt die Ärztin   教師 der Lehrer    小販 der Verkäufer    服務生  die Kellnerin    Mann / Frau    男生 女生     Kollege Kollegin   Freund Freundin   Partner Partnerin    Familie    中文 English German     父親 Father der Vater   母親 Mother die Mutter   父母 Parent die Eltern   兒子 Son der Sohn   女兒 Daughter die Tochter   兄弟 Brother der Bruder   姐妹 Sister die Schwester   兄弟姊妹 Sibling die Geschwister   祖父 Grandpa der Großvater / Opa   祖母 Grandma die Großmutter / Oma   祖父母 Grandparent die Großeltern   孫女 Granddaughter die Enkelin   孫子 Grandson der Enkel   先生 Husband der Ehemann   太太 Wife die Ehefrau    所有格    主格 der / das die     ich mein meine   du dein deine   er/es sein seine   sie ihr ihre   wir unser unsere   Sie Ihr Ihre    所有格 Akkusativ nach haben, brauchen, suchen, \u0026hellip;     definiter Artikel indefiniter Artikel Netativ-Artikel      Sie hat den einen keinen Laptop.    das ein kein Formula.    die eine keine Briefmarke.    die - keine Stifte.    Sprachen  Welche Sprachen sprechen Sie / sprichst du? Ich spreche sehr gut / gut / ein bisschen \u0026hellip;     der Land Sprachen     das Deutschland Deutsch   das Frankreich Französisch   die USA    die Niederlande Niederländisch   England Englisch   das Mexiko    das Spanien Spanisch   die Türkei    das Polen Polnisch   das Tschechien Tschechisch   das Russsland Russisch   das Österreich     Möbel 家具    English German Plural     bed das Bett Betten   picture das Bild Bilder   armchair der Sessel Sessel   lamp die Lampe Lampen   chair der Stuhl Stühle   sofa das Sofa Sofas   couch die Couch Couchen   table der Tisch Tische   closet（抽屜） der Schrank Schränke   carpet（地毯） der Teppich Teppiche    Gegenstände    English German Plural     pencil der Bleistift Bleistifte   glasses die Brille Brillen   book das Buch Bucher   bottle die Flasche Flaschen   lighter das Feuerzeug Feuerzeuge   camera der Fotoapparat Fotoapparate   chain die Kette Ketten   pen der Kugelschreiber Kugelschreiber   key der Schlüssel Schlüssel   bag die Tasche Taschen    Im Büro    English German Plural     laptop der Laptop Laptops   e-mail die E-Mail E-Mails   cell phone das Handy Handys   SMS die SMS    bill die Rechnung Rechnungen   phone das Telefon Telefone   form das Formular Formulare   printer der Drucker Drucker   mouse die Maus Mauß   computer der Computer Computer   pen der Stift Stifte   notebook das Notizbuch Notizbucher   calender der Kalender Kalender   screen der Bildschirm Bildschirme    Personalpronomen    maskulin neutral feminin     der das die   er es sie    Beratungsgespräche    German English     Brauchen Sie Hilfe Do you need help   Ja, bitte.      Wie viel / Was kostet (denn) die Lampe? Die Lampe kostet 119 Euro. Das ist ein Sonderangebot（特價）.    Das ist (sehr / zu / aber) teuer / günstig / billig. Der Tisch ist zu groß / zu klein. Ich finde die Lampe (wirklich) sehr schön. Das finde ich auch. 我同意 / Das finde ich night. 我不同意 Finden Sie? / Findest du? 你同意嗎？    teuer 昂貴 günstig / billig 便宜 groß 大 klein 小 schön 漂亮  Materialien 材質  Die Brille ist aus ___.     中文 German     木頭 Holz   金屬 Metall   紙 Papier   塑膠 Kunststoff / Plastik   玻璃 Glas    Farben 顏色    中文 German     紅色 röte / rot   綠色 grün   橘色 orange   黑色 schwarz   棕色 braun   藍色 blau   黃色 gelb   白色 weiß    Formen 形狀    中文 German     方形 eckig   圓形 rund    nach Wörtern fragen  A: Entschuldigung, wie heißt das auf Deutsch? B: Das ist eine Uhr. A: We bitte? Noch einmal, bitte. B: Das ist eine Uhr. A: We schreibt man Uhr? B: U - H - R. A: Danke. B: Bitten schön. Kein Problem.  Internet bestellen 網購  Anrede: Frau / Herr Vorname Falmiliename Geburtsdatum: Tag / Monat / Jahr （生日） Postleitzahl (PLZ) （郵遞區號）  ","date":"2020-12-28T10:19:18+08:00","permalink":"https://Luke2336.github.io/p/german1/","title":"德文（一）筆記"},{"content":"「認識語言」期末報告 以下介紹五個我在「認識語言」下半學期學到的重點。\n1. Chomsky 和行為主義 (Behaviorism) 的對立 語言的學習是後天的 (nurutre)，還是天生就有的 (nuture) 學習能力？\n行為主義興起的背景，要從佛洛伊德的時代開始談起，當時心理學是立足於潛意識等無法觀測的東西，因此很多科學家無法認同心理學屬於科學的一支。\n在 Parlov、Skinner 和 Waston 等人的努力下，產生了行為主義學派。他們透過設計實驗來研究人或動物的行為模式，像是古典制約的實驗中，Parlov 的狗被制約，每次接收到搖鈴刺激 (stimulus)，就會不由自主的流口水。而 Skinner 進一步提出了操作制約，透過食物來讓老鼠自己學會按開關。\n行為主義者宣稱，他們可透過制約，也就是給予 positive/negative reforcement，使人類學習，這屬於 stimulus-response learning。他們認為母語的學習也可以透過同樣的管道。\n對此，Chomsky 有不同的看法，他認為語言的習得無法僅僅透過後天的經驗，先天的能力是必須的，因此他提出了 Universal Grammar。\u0026ldquo;What you know exceeds what you were taught.\u0026quot;，舉例來說，小孩子會犯一些大人不會犯的錯誤，像是 \u0026ldquo;holded\u0026rdquo;，這是他們無法透過模仿習得，可以推論出他們先天具備一些學習語言的能力，像是統計、歸納等等。\nChomsky 說明了在語言的學習上，本能和經驗都是重要的。我認為他的想法是重要且具有突破性的，因為他不只影響了語言學的發展，更對心理學造成了重大的影響，他證明了行為主義是無法解釋所有現象的，讓心理學研究慢慢走出行為主義的框架。\n2. Universal Grammar (UG) Universal Grammar 是 Chomsky 的理論，為了描述所有語言的共同點。Universal Grammar 是由 principles 和 parameters 共同組成。\n由於孩童學習語言的時間是有限的，且他們能得到的資訊量也是有限的，但他們能表達的語句，卻是無限的。可見，這些語句不僅僅是藉由經驗而習得，而需要藉由人類天生就有的 Universal Grammar，將得到的句子提取出一些共通的 principles。像是人們能判斷句子中的代名詞或是反身代名詞是在指誰，都是我們在學習時無法直接解釋的，這些天生就具備的能力，就是屬於 Universal Grammar。\n但這些 principles 卻只能解釋語言具有共通性，而無法解釋語言的差異性，因此他在理論中加入了 parameters 的想法。\n在英語中，是先表達動詞，然後才是受詞。然而，在日語中，兩者卻是相反的。又或是在英文中，我們會將 Where/Who 等疑問詞放在句子開頭，而在中文中，我們卻會任意擺放哪裡/誰/何時在句子的其他位置。這些現象無法被 principles 概括，因此我們有了 parameters。parameters 提供了孩童在學習時，能藉由聽到的資訊，將母語中沒有的 parameters 捨棄，讓他們能專注於學習母語中有的文法或發音。\n我認為 UG 重要的原因在於它解釋了大部分的語言學習現象，但其發展卻極具挑戰，畢竟這個理論需要符合世界上的所有語言，所以每當科學家舉出一個反例時，這個理論就必須做出修改，因此這個理論勢必逐漸簡化成現今的模樣。\nUG 到底是如何演化出來的，我認為這是一個滿有趣的問題。人腦中的 Universal Grammar 到底是愈來愈複雜，又或是愈來愈簡化呢？如果按照我對 Universal Grammar 的認識，有了 parameters 的幫助，或許 principles 是可以發展成愈來愈多的？\n3. 嬰兒的語言發展階段 嬰兒的母語發展有幾個重要的階段：\n 在懷孕的最後幾週，嬰兒的聽力系統已接近發育完全，因此他們就會開始聆聽外界聲音，剛出生的嬰兒就對母語有偏好。 3 個月：larynx lowerling，嬰兒的喉頭會下降，他們能發出更多的聲音。 6 ~ 10 個月：phoneme comprehension，嬰兒開始失去辨識母語以外的音的能力，不再能分辨所有語言中的音，這讓他們能更專注於學習母語。 6 ~ 12 個月：他們透過 Babbling 來學會發音。 1 歲多時他們能一些單詞 (1-word)。快 2 歲時，他們會說兩個詞的句子 (2-words)。 2 ~ 2.5 歲時，telegraphic stage，他們的單字量迅速擴增，並且能組合成完整的句子，儘管文法不一定正確。 2.5 歲後：他們開始發展像成人的語句，並且已習得大多數文法規則，但他們會出現 over-generalization 的狀況，也就是有了像 \u0026ldquo;goed\u0026rdquo; 或是 \u0026ldquo;holded\u0026rdquo; 等成人不會犯錯誤。  科學家是如何針對不會說話的嬰兒進行研究呢？他們有幾種有趣的研究方式，例如：\n Pacifier experiment：他們利用嬰兒吸食奶嘴的速度來研究嬰兒對事物的興趣，例如他們在聽到的聲音從 /ba/ 變成 /pa/ 時，他們會改變吸食速度。 Head-turn Experiment：科學家可能藉由讓嬰兒學會某些規則，例如聽到 ABA 時，玩偶會出現在左方，反之，聽到 AAB ，則會出現在右方。之後，在透過紀錄嬰兒轉頭的方向，來實驗嬰兒是否能學會規則。  這幾個發展的階段，有解釋到幾個我以前無法理解的疑問。首先，我了解到我們長大後學習語言，為什麼無法達到學母語一樣的成果。接著，我也理解到人類演化出喉頭下降是非常重要的，像是我們的近親 - 猿類，就沒有這個演化結果，這讓他們有些音是發不出來的（例如：/i/、/a/、/u/）。而這個演化其實是對人類高風險的，因為這會干擾消化道和呼吸道分離。但他卻出現在三個月大時，以適者生存的角度來看，語言對於人類的生存是非常重要的。\n非常有趣的一點是，全世界的嬰兒都是用相近的時程來發展，顯然這些都是演化的結果。在上課中有提過，猿類對語言的學習至多是線性的結構，無法像人類一樣有階層狀/洋蔥狀的結構，也無法創造太長的句子。有些好奇有沒有研究能知道這樣的大腦發展的演化和人類發音器官構造的演化，究竟是誰先誰後？還有是否有其他生物一樣有 phoneme comprehension 的現象？\n4. 雙母語嬰兒的認知能力 在討論雙母語和單母語嬰兒的認知差異前，我們需要先定義認知能力是什麼？\nExecutive functions (EF) 是認知心理學中，對於人類一些認知能力的統稱，包含了管理工作記憶、控制衝動、能處理多項工作（能快速轉換）的能力。這些能力主要是由前額葉所控制。\n根據研究，雙母語和單母語嬰兒習得母語的所需時間是相近的。這是由於雙母語的學習會刺激認知能力的發展，而發展較好的認知能力也有助於雙母語的學習。\n嬰兒在雙母語環境下，他的大腦需要處理兩種語言，因此需要前額葉的幫助，使得嬰兒能快速在兩種語言中切換。根據 Kovács \u0026amp; Mehler 對 7 個月大的研究，當同時有兩個規則時，單母語環境的嬰兒只能學會較簡單的那種，而雙母語嬰兒能學會兩種，得到了雙母語嬰兒有較佳 EF 的結論。\n很重要的一點是，根據科學家的研究，EF 的發展最快速的時期是在 6 歲前，因此父母在 6 歲前給予嬰兒適當的刺激有助於發展他們的 EF，像是唸外語故事書就是很好的方式。而對於雙語的人，就算他們長時間只使用單一語言，但他們的前額葉仍需要去抑制另外一種語言，因此研究也指出雙語的人比單語的人得到老年癡呆的平均年齡晚 4 年。\n我很好奇的一點是，人類嬰兒學習語言的能力和其認知能力是相輔相成的，那他們最多能學習多少種語言才會達到認知能力的極限？\n5. Finite State Grammars (FSGs) Finite State Grammar 是 Chomsky 提出的概念。我們都知道，句子是由 finite 的字詞組成而成，但其組成方法是無限的。對於一個有限長度的句子，我們可以透過一種特殊的 finite state machine 生成，這種 finite state machine 運用了 transition probability (TP) 的概念，藉由 TP 來定義一種 Markov chain。\n然而，這種想法是無法實際運用在生成自然語言，他遠遠不足以表達人類的文法。由於 FSGs 只能藉由上一個狀態去決定下一個狀態，故在定義狀態時，只會是線性的，無法表達出階層的概念，也無法透過機率去生成合乎文法的句子，像是不同時態的 is/was，出現在某個名詞後面的機率會是相近的。因此，最後有了 Phrase Sturcture Grammars (PSGs)，讓句子能嵌入進句子中，有了階層狀的結構，而能表達出字詞間的關聯性，不在侷限於相鄰的字間。\nFSGs 的重要性在於，他提供了一種簡單的運算方式，讓電腦能生成語句。且他將一些遞迴的想法，透過 state diagram 中的 cycle / loop 來達成。\n句子的組成無法用 Finite State Machine 來表達，但英文的構詞是否能用 Finte State Machine 來找到一些規則？\nFeedback 因為提出的問題不錯，所以得到 94 分。\n 有些好奇有沒有研究能知道這樣的大腦發展的演化和人類發⾳器官構造的演化，究竟是誰先誰後?   應該是發音器官的演化比較早，因為喉頭下降的生理現象雖然黑猩猩與猿類沒有，但是在其他的生物上有歐！例如鹿類就有，但是在其他生物上演化出此生理特徵不是了語言，而是為了增加吼叫聲的威嚇力，讓敵人感覺你的體積龐大，由於有這個另外的演化動力，所以學者的假說是發聲器官的改變早於大腦演化。\n  是否有其他⽣生物一樣有 phoneme comprehension 的現象?   其他的生物也會有phoneme comprehension的categorical perception的現象！\n ","date":"2020-12-28T10:09:29+08:00","permalink":"https://Luke2336.github.io/p/understanding_language_final_report/","title":"認識語言 期末報告"},{"content":"中午和ㄠㄨ一起吃了麥當勞，然後在系計中唸了 OS，晚餐吃了女二樓下的丼飯。他送了我一盒巧克力，當作其中一樣聖誕禮物。晚上他回去上競程，我洗完澡後，在宿舍裡寫認識語言的期末報告。\nToggl 用了這個軟體一週，發現用功的時間似乎有增加。發現自己雖然平常課不多，但假日還是相對會想強迫自己用功。這幾天身體相對疲憊，所以週間做的事略少。\n","date":"2020-12-27T10:21:14+08:00","permalink":"https://Luke2336.github.io/p/20201227/","title":"2020/12/27 日記"},{"content":"早上去看醫生，中午吃了蝦仁炒飯＋牛雜湯。\n下午因為天氣不錯，就去走了走，看看白鷺鷥。\n傍晚很累，睡了一個半小時午覺後，就去全家買了晚餐，然後就準備了家教的東西。\n不小心上太快，只好現場打點 code 補時間。結束時聊了一下，感覺因為疫情的緣故，對方不想到美加地區，於是就沒有補習的需求，我快失業了 QAQ 但下學期還要當助教，所以沒有特別有想要接案的念頭，看看暑假實習的面試狀況再決定吧。\n晚上梳洗完後，吃了橘子，一點前睡著。\n","date":"2020-12-27T00:33:15+08:00","permalink":"https://Luke2336.github.io/p/20201226/","title":"2020/12/26 日記"},{"content":"下午去找導師簽交換的文件，然後就開始做家教的投影片。傍晚悅庭來找我玩，送了我瑪露連。晚餐去吃了火鍋，生理期身體不太舒服。飯後複習了德文，然後才休息。\n晚上看了怡芬老師的貼文，被感動到，加上很想念北一女，所以就哭了。\n","date":"2020-12-25T10:08:59+08:00","permalink":"https://Luke2336.github.io/p/20201225/","title":"2020/12/25 日記"},{"content":"早上維持了昨夜的疲倦感，很不想做事。\n上完電路學後，複習了德文。今天電路學教 Laplace Transform。晚上跑去市區吃飯，吃了前幾天吃湯圓時看到的肉。\n109-2 課表 今天早上看了選課結果，不甚滿意，沒選上密碼學，也沒選上素描課，考慮再選一門 EDA 湊 15 學分。\n","date":"2020-12-24T14:10:19+08:00","permalink":"https://Luke2336.github.io/p/20201224/","title":"2020/12/24 日記"},{"content":"儀式感 身邊很多男性友人的生活都充滿儀式感，從日常生活到過節都是。例如睡前一定要打電動，或是早上一定要喝一杯咖啡。\n之前會覺得這種生活很僵硬，有時候男友就算出去約會，也不願放棄他的儀式。但現在的我，對於儀式會有種不同的想法，就是生活中的「錨點」，讓生活不至於太過散亂。\n從每週的運動習慣，吃飯睡覺的時間，或是喝杯茶，洗澡，這些固定的動作都有助於維持生活。雖然會是一種制約，但卻可以訓練成做某些事的時候，心裡能特別興奮，有助於維持健康。\n選課 這是期望的課表，但人社院那門素描只有 15 個名額，目前大約 60% 的機率，感覺不好選到。而密碼學則只有 50% 的機率抽到，不知道這種數學課為什麼那麼熱門。難解問題被正規擋修了，有點難過。資工系好像沒什麼想選的課了，希望至少選到三門主科。我不想再申請低修啊！！\n 主科：密碼學(3)、正規語言(3)、計算方法之實務應用(3) 外文：德文二(2)、進階英文(2) 通識：教育學概論(2) 其他選修：生活中的素描(3)  最後一堂羽球課 考完了期末考，很開心能被稱讚米字步跑得很好！和大家打了單打，今天比上週好，因為不像之前那樣緊張。老師說下學期的期中是高遠球，期末是切球上網連續 8 次。\nPCCA 準備了巧克力和卡片送給隊友。\n今天是個人練習，我前面還算順，但後面就體力不支，放棄後回宿舍休息。\n","date":"2020-12-23T10:18:18+08:00","permalink":"https://Luke2336.github.io/p/20201223/","title":"2020/12/23 日記"},{"content":"有點煩悶，犬齒附近又咬到發炎了。很疲倦，不想做任何事。\n晚上上完電路後，去吃了海洋牛排。\n","date":"2020-12-22T14:38:56+08:00","permalink":"https://Luke2336.github.io/p/20201222/","title":"2020/12/22 日記"},{"content":"Christmas Card 畫了聖誕卡片，想要送給隊友。\n認識語言 今天是最後一堂課，教了 Finate State Grammars，下週要交期末報告。\n冬至 吃了紅豆湯圓。\n","date":"2020-12-21T10:53:26+08:00","permalink":"https://Luke2336.github.io/p/20201221/","title":"2020/12/21 日記"},{"content":"昨晚很冷睡得不太好，期末快到了壓力有點大。下午跟男友把腳踏車擦乾淨，並幫輪胎打氣。之後主要的時間是寫電路學作業，然後吃了漢堡王當晚餐。之後寫了兩成的認識語言期末報告。\n晚上去打了羽球，覺得手很痠痛。心情不太好，於是提早收工，在麥當勞買了雞翅和玉米湯後，回宿舍休息。覺得很失望，原本預期雞翅要有兩隻，結果得到的是一隻拆成兩節。\n期末 Deadlines    Work Deadline     電路 HW12 12/22（二）   家教 12/26（六）   語言 Report 12/28（一）   OS Exam 12/30（三）   德文 Exam 12/30（三）   OS HW1 01/03（日）   OS HW2 01/03（日）   OS HW3 01/03（日）   電路 HW13 01/05（二）   交換 自傳 01/08（五）   家教 01/09（六）   電路 Exam 01/12（二）   電路 Project 01/19（二）    Week Todo List  電路 HW12 家教 投影片 認識語言 期末報告 準備 OS 期末考  一天讀兩章   準備 德文 考試  背單字 讀文法   跑簽核單：導師 \u0026amp; 系辦  Toggl 今天開始重新尋找計時工具，發現了這款可在裝置間同步的 APP。\n","date":"2020-12-20T10:43:32+08:00","permalink":"https://Luke2336.github.io/p/20201220/","title":"2020/12/20 日記"},{"content":"AtCoder Beginning Contest 186 pE 讓我卡了一下，於是就掉分了。pF 想到了一個假解，浪費了不少時間。可能是因為剛打完 CF，所以狀態不好。\nA. Brick 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 int n, w; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; w; 5 cout \u0026lt;\u0026lt; n / w \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 6 return 0; 7}  B. Blocks on Grid 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 ios_base::sync_with_stdio(0); cin.tie(0); 5 int h, w; cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w; 6 int sum = 0, m = 105; 7 for (int i = 0; i \u0026lt; h; i++) { 8 for (int j = 0; j \u0026lt; w; j++) { 9 int x; cin \u0026gt;\u0026gt; x; 10 sum += x; 11 m = min(m, x); 12 } 13 } 14 cout \u0026lt;\u0026lt; sum - m * h * w \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 15 return 0; 16}  C. Unlucky 7 求 1 ~ n 中，有多少個數的十進位和八進位都沒有 7。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3bool check(int n, int k) { 4 while (n) { 5 if (n % k == 7) return false; 6 n /= k; 7 } return true; 8} 9int main() { 10 int n; cin \u0026gt;\u0026gt; n; 11 int cnt = 0; 12 for (int i = 1; i \u0026lt;= n; i++) 13 cnt += check(i, 10) \u0026amp; check(i, 8); 14 cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 15 return 0; 16}  D. Sum of difference 求 |ai - aj|, i \u0026lt; j 的總和。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4int main() { 5 ios_base::sync_with_stdio(0); cin.tie(0); 6 int n; cin \u0026gt;\u0026gt; n; 7 vector\u0026lt;ll\u0026gt; a(n); 8 for (int i = 0; i \u0026lt; n; i++) 9 cin \u0026gt;\u0026gt; a[i]; 10 sort(a.begin(), a.end()); 11 vector\u0026lt;ll\u0026gt; sum(n + 1); 12 for (int i = n - 1; i \u0026gt;= 0; i--) 13 sum[i] = sum[i + 1] + a[i]; 14 ll ans = 0; 15 for (int i = 0; i \u0026lt; n; i++) 16 ans += sum[i + 1] - a[i] * (n - i - 1); 17 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 18 return 0; 19}  E. Throne 先用 extgcd(k, n) 求 xk + bn = gcd(k, n)，再求 xk % n = s 的最小整數解。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;ll, ll\u0026gt; pii; 5ll gcd (int a, int b) { 6 return b ? gcd(b, a % b) : a; 7} 8pii extgcd(ll a, ll b) { 9 if (!b) return {1, 0}; 10 ll k = a / b; 11 pii p = extgcd(b, a - k * b); 12 return {p.second, p.first - k * p.second}; 13} 14int main() { 15 ios_base::sync_with_stdio(0); cin.tie(0); 16 int T; cin \u0026gt;\u0026gt; T; 17 while (T--) { 18 ll n, s, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; 19 ll g = gcd(n, k); 20 if (s % g) { 21 cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; continue; 22 } 23 ll ans = -extgcd(k, n).first * s / g; 24 ans %= n / g; 25 if (ans \u0026lt;= 0) ans += n / g; 26 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 27 } 28 return 0; 29}  F. Rook on Grid 給定一個 H x W 的棋盤，以及 M 個障礙物。 (H, W, M ≤ 2e5)\n求從 (1, 1) 出發 Rook 能在兩步內到達的格子有幾個？\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define x first 6#define y second 7#define maxn 200005 8class RangeUpdateBIT { 9 private: 10 ll d[maxn], dd[maxn]; 11 ll sum(int i) { 12 ll s = 0, ss = 0; 13 int c = i + 1; 14 while (i \u0026gt; 0) s += d[i], ss += dd[i], i -= i \u0026amp; -i; 15 return c * s - ss; 16 } 17 void add(int i, ll v) { 18 int c = i; 19 while (i \u0026lt; maxn) 20 d[i] += v, dd[i] += c * v, i += i \u0026amp; -i; 21 } 22 public: 23 RangeUpdateBIT() { 24 memset(d, 0, sizeof(d)); 25 memset(dd, 0, sizeof(dd)); 26 } 27 ll sum(int l, int r) { return sum(r) - sum(l - 1); } 28 void add(int l, int r, ll v) { 29 add(l, v), add(r + 1, -v); 30 } 31}; 32int main() { 33 ios::sync_with_stdio(0); cin.tie(0); 34 int h, w, m; cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w \u0026gt;\u0026gt; m; 35 vector\u0026lt;pii\u0026gt; p(m); 36 vector\u0026lt;int\u0026gt; col(w + 1, h + 1), row(h + 1, w + 1); 37 for (int i = 0; i \u0026lt; m; i++) { 38 cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 39 col[p[i].y] = min(col[p[i].y], p[i].x); 40 row[p[i].x] = min(row[p[i].x], p[i].y); 41 } 42 sort(p.begin(), p.end()); 43 ll ans = 0; 44 for (int i = 1; i \u0026lt;= w \u0026amp;\u0026amp; col[i] \u0026gt; 1; i++) 45 ans += col[i] - 1; 46 RangeUpdateBIT T; 47 T.add(row[1], w + 1, 1); 48 for (int j = 2, pi = 0; j \u0026lt;= h \u0026amp;\u0026amp; row[j] \u0026gt; 1; j++) { 49 while (pi \u0026lt; m \u0026amp;\u0026amp; p[pi].x \u0026lt; j) pi++; 50 int R = (pi \u0026lt; m \u0026amp;\u0026amp; p[pi].x == j) ? p[pi].y : w + 1; 51 ans += T.sum(1, R - 1); 52 while (pi \u0026lt; m \u0026amp;\u0026amp; p[pi].x ==j) { 53 if (!T.sum(p[pi].y, p[pi].y)) 54 T.add(p[pi].y, p[pi].y, 1); 55 pi++; 56 } 57 } 58 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 59 return 0; 60}  ","date":"2020-12-19T22:03:36+08:00","permalink":"https://Luke2336.github.io/p/atcoder_abc186/","title":"AtCoder Beginning Contest 186"},{"content":"Codeforces Round #691 (Div. 2) 因為 pC 找不到 bug，就一直亂丟，於是打得超爛。Rating 加了 43 到 1695。\npA. Red-Blue Shuffle 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define pb push_back 6int main() { 7 ios_base::sync_with_stdio(0); cin.tie(0); 8 int T; cin \u0026gt;\u0026gt; T; 9 while (T--) { 10 int n; cin \u0026gt;\u0026gt; n; 11 string R, B; 12 cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; B; 13 int r = 0, b = 0; 14 for (int i = 0; i \u0026lt; n; i++) 15 if (R[i] \u0026gt; B[i]) r++; 16 else if (R[i] \u0026lt; B[i]) b++; 17 if (r \u0026gt; b) cout \u0026lt;\u0026lt; \u0026#34;RED\\n\u0026#34;; 18 else if (r \u0026lt; b) cout \u0026lt;\u0026lt; \u0026#34;BLUE\\n\u0026#34;; 19 else cout \u0026lt;\u0026lt; \u0026#34;EQUAL\\n\u0026#34;; 20 } 21 return 0; 22}  pB. Move and Turn 總共走 n 步，每走一步要從東西向換成左右向，問總共有幾種不同的終點？\n首先，計算兩種各自需要走幾步，假設一種為 a 和 b 步，則各自有 a 和 b 種線性組合 (x - y = a)，接下來考慮第一步為東西或南北，若 a 和 b 不同，則答案為 a * b * 2，否則為 a * b。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define pb push_back 6int main() { 7 ios_base::sync_with_stdio(0); cin.tie(0); 8 int n; cin \u0026gt;\u0026gt; n; 9 int a = n / 2, b = n - n / 2; 10 int ans = (a + 1) * (b + 1); 11 if (a != b) ans *= 2; 12 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 return 0; 14}  pC. Row GCD 給定 1 ≤ n, m ≤ 2e5，給定 a1 ~ an, b1 ~ bm，回答 a1 + bj ~ an + aj 的最大公因數 GCDj。\n輾轉相除法是用相減，所以直接用數列差的 GCD 去和 a1 + bj 取 GCD 即可。\n需要小心 n = 1 的狀況，不小心踩到坑了 QAQ\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, int\u0026gt; pii; 5#define pb push_back 6int main() { 7 ios_base::sync_with_stdio(0); cin.tie(0); 8 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 9 vector\u0026lt;ll\u0026gt; a(n); 10 for (int i = 0; i \u0026lt; n; i++) 11 cin \u0026gt;\u0026gt; a[i]; 12 sort(a.begin(), a.end()); 13 ll g = n \u0026gt; 1 ? a[1] - a[0] : 0; 14 for (int i = 2; i \u0026lt; n; i++) 15 g = __gcd(g, a[i] - a[0]); 16 for (int j = 0; j \u0026lt; m; j++) { 17 ll b; cin \u0026gt;\u0026gt; b; 18 cout \u0026lt;\u0026lt; __gcd(g, a[0] + b) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 19 } 20 return 0; 21}  ","date":"2020-12-19T19:07:58+08:00","permalink":"https://Luke2336.github.io/p/cf_contest_1459/","title":"Codeforces Round 691 Div. 2"},{"content":"半夜很餓，難得的去全家買了義大利麵當宵夜。\n北一女校慶擺攤事件  倫子老師的貼文 身為北一女校友以及一個女性，覺得台灣媒體及網民的素質極低。以陪聊天賺錢究竟是不是物化女性呢？若是反過來難道會變成物化男性嗎？顯然這完全是網友們本身對女性帶有著性別偏見。  Code  Codeforces Round #691 (Div. 2) AtCoder Beginning Contest 186  ","date":"2020-12-19T10:38:44+08:00","permalink":"https://Luke2336.github.io/p/20201219/","title":"2020/12/19 日記"},{"content":"下午上了 OS，覺得真的有點無聊，不確定下學期還要不要選他的課。晚餐吃了香菇雞湯，覺得還不錯吃。\n學生證不見？ 一回宿舍就發現找不到學生證，似乎從小包包裡掉出來了，後來有找到。順便研究了學校的掛失系統，覺得一張 $200 會很想哭，加上裡面還剩 $500 以上。雖然掛失後會把 48 Hr 後的餘額退還，但還是很緊張。發現如果 12:00 前申請補發，當天下午就能拿到，比想像中方便。沒有學生證，就不能打球了！！\n語言學演講 中午去聽語言學的演講，學到了一些 L1 / L2 English 的差異。\n Topic: Boundaries, Contrast and Differentiation in Continuous Speech Talker: Chiu-yu Tseng  CSES - 1146 - Counting Bits 問 1 ~ n 的二進制表示法中，共有多少個 1-bit？\n   十進位 $$2^2$$ $$2^1$$ $$2^0$$     0 0 0 0   1 0 0 1   2 0 1 0   3 0 1 1   4 1 0 0   5 1 0 1   6 1 1 0   7 1 1 1    觀察 0/1 交替的方式，最末位是每隔 1 個，接下來是每隔 2 個，接下來是每隔 4 個\u0026hellip;\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4int main() { 5 ll n, ans = 0; 6 cin \u0026gt;\u0026gt; n; n++; 7 for (ll i = 1; i \u0026lt;= n; i \u0026lt;\u0026lt;= 1) { 8 ll c = n / i; 9 if (c \u0026amp; 1) ans += c / 2 * i + n % i; 10 else ans += c / 2 * i; 11 } 12 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 13 return 0; 14}  CSES - 11677 - Network Breakdown 題目是問給一張圖，每次刪除一條邊後，回答所剩的聯通塊數目。\n用 Union Find Tree 維護聯通塊，離線倒著回答詢問，也就是一條一條加回去。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4#define x first 5#define y second 6vector\u0026lt;pii\u0026gt; remove(vector\u0026lt;pii\u0026gt; e, vector\u0026lt;pii\u0026gt; q) { 7 sort(q.begin(), q.end()); 8 vector\u0026lt;pii\u0026gt; ret; 9 for (pii p : e) { 10 auto iter = lower_bound(q.begin(), q.end(), p); 11 if (iter == q.end() || *iter != p) 12 ret.push_back(p); 13 } 14 return ret; 15} 16struct UF { 17 int cnt; 18 vector\u0026lt;int\u0026gt; p, r; 19 UF(int n): cnt(n) { 20 p.resize(n + 1), r.resize(n + 1); 21 for (int i = 1; i \u0026lt;= n; i++) p[i] = i; 22 } 23 int par(int x) { 24 return p[x] = ((p[x] == x) ? x : par(p[x])); 25 } 26 void uni(int a, int b) { 27 a = par(a), b = par(b); 28 if (a == b) return; 29 if (r[a] \u0026lt; r[b]) {int t = a; a = b; b = t;} 30 p[b] = a, r[a] += (r[a] == r[b]), cnt--; 31 } 32}; 33int main() { 34 ios::sync_with_stdio(0); cin.tie(0); 35 int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; 36 UF T(n); 37 vector\u0026lt;pii\u0026gt; e(m), q(k); 38 for (int i = 0; i \u0026lt; m; i++) { 39 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 40 e[i] = pii(min(a, b), max(a, b)); 41 } 42 for (int i = 0; i \u0026lt; k; i++) { 43 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 44 q[i] = pii(min(a, b), max(a ,b)); 45 } 46 e = remove(e, q); 47 for (pii p : e) 48 T.uni(p.x, p.y); 49 vector\u0026lt;int\u0026gt; ans; 50 reverse(q.begin(), q.end()); 51 for (pii p : q) { 52 ans.push_back(T.cnt); 53 T.uni(p.x, p.y); 54 } 55 for(int i = k - 1; i \u0026gt;= 0 ; i--) 56 cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 57 return 0; 58}  氣泡梅酒 晚上朋友調了一杯梅酒加氣泡水給我喝，我才喝一杯就想睡了。應該是第二次喝酒，感覺很新奇，甜甜的很喜歡。上次喝酒是和振華學長跨年。\n","date":"2020-12-18T11:45:29+08:00","permalink":"https://Luke2336.github.io/p/20201218/","title":"2020/12/18 日記"},{"content":"晚餐吃了烤雞。\n資工系停修事件 學校某些重要的條文或會議記錄沒有被公開清楚，（畢竟學生會的貼文本身不具任何效益），產生各種模糊地帶，再加上行政人員不見得全在狀況內。\n自己期中退選時，被課務組拿他們的價值觀來跟我說教，也覺得超不合理的。\n因為分數不好看而停修確實不合理，但大學部的學分費是吃到飽，所以大家很容易選超過可負擔的量。\n電路學 CH13 Self Inductance $$L = N \\frac{d \\phi}{di}$$\nMutual Inductance $$M = M_{12} = M_{21}$$\n$$v_2 = N_2 \\frac{d \\phi_{12}}{dt} = M_{21}\\frac{di_1}{dt}, \\ M_{21} = N_2 \\frac{d \\phi_{12}}{di_1}$$\nCoupled Circuit $$v_1 = L_1 \\frac{di_1}{dt} + M \\frac{di_2}{dt}$$\n$$\\mathbb{V}_1 = j \\omega L_1 \\mathbb{I}_1 + j \\omega M \\mathbb{I}_2$$\nEnergy $$w = \\frac{1}{2} L_1 I_1^2 + \\frac{1}{2} L_2 I_2^2 \\pm M I_1 I_2$$\nCoupling Coefficient $$k = \\frac{M}{\\sqrt{L_1 L_2}} = \\frac{\\phi_{12}}{\\phi_{11} + \\phi_{12}} = \\frac{\\phi_{21}}{\\phi_{21} + \\phi_{22}} \\in [0, 1]$$\nPerfect Coupling $$k = 1 \\iff \\phi_{11} = \\phi_{22} = 0$$\nLinear Transformers $$\\begin{aligned} \\mathbb{Z}_{in} \u0026amp;= \\mathbb{Z}_P + \\mathbb{Z}_R \\\\ \u0026amp;= (R_1 + j \\omega L_1) + \\frac{\\omega^2 M^2}{R_2 + j \\omega L_2 + \\mathbb{Z}_L}\\\\ \\mathbb{Z}_P \u0026amp;:\\text{primary impedance}\\\\ \\mathbb{Z}_R \u0026amp;:\\text{reflected impedance} \\end{aligned}$$\nIdeal Transformers  $$\\begin{cases} L_1, L_2, M \\to \\infty\\\\ k = 1 \\iff M = \\sqrt{L_1 L_2} \\\\ R_1 = R_2 = 0 \\end{cases}$$ $$\\mathbb{V}_2 = \\sqrt{\\frac{L_2}{L_1}} \\mathbb{V}_1 = n \\mathbb{V}_1$$ Turn Ratio $$n = \\frac{\\mathbb{V}_2}{\\mathbb{V}_1} = \\frac{\\mathbb{I}_1}{\\mathbb{I}_2} = \\frac{N_2}{N_1} = \\sqrt{\\frac{\\mathbb{Z}_L}{\\mathbb{Z}_{in}}}$$ Make Ideal !! $$\\omega L_2 \\gg |\\mathbb{Z}_L|$$  ","date":"2020-12-17T10:16:18+08:00","permalink":"https://Luke2336.github.io/p/20201217/","title":"2020/12/17 日記"},{"content":"早上上完德文課，又翹了 OS，吃完了蛋糕，讀了電路學，然後上了羽球課，洗個澡就去練習了。中午參考這篇文章，把 Google Analytics 加到 Blog。\n羽球課 下週要考期末考，但練了一下腳步，覺得很不熟練，甚至還是不會後場的換腳，前場左邊比較跑不到點，然後回中時換另一個方向略略不順。\n之後分組打單打比賽，打了 3 場 7 分，輸了一場，其他幾場都以不錯的比數取勝，普遍看到大家發球不夠高或遠，很容易就變成平球戰。我則是後場接球能力不好，沒辦法很快跑位打回到後場。結束後和學姊單挑了一場 21 分，後面體力不支，就沒有贏了。\nCPTC 001    Problem Coder Topic     A Hyperbola Binary Search   B Kelly Greedy, Sort   C Hyperbola Enumerate, Prefix Sum   D Hyperbola 互動題, DP   E Kelly 數位 DP    今天難得全都 1AC。讀完題後也有迅速抓出水題，兩題都在正常速度開完。pD 被曲線通靈出來，他邊寫我邊聽 LinLee 講題目。我決定把 pE 拿去做，pC 則留給他們想。pE 算是定義好狀態就很好寫的題目，之前常在 AtCoder 看到類似的題目。\npB 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4int main() { 5 int n, m; 6 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n ,\u0026amp;m); 7 vector\u0026lt;int\u0026gt; deg(n); 8 for (int i = 0; i \u0026lt; m; i++) { 9 int a, b; 10 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); 11 deg[a-1]++, deg[b-1]++; 12 } 13 vector\u0026lt;int\u0026gt; h(n); 14 for (int i = 0; i \u0026lt; n; i++) 15 scanf(\u0026#34;%d\u0026#34;, \u0026amp;h[i]); 16 sort(h.begin(), h.end()); 17 sort(deg.begin(), deg.end()); 18 ll ans = 0; 19 for (int i = 0; i \u0026lt; n; i++) 20 ans += ll(h[i]) * ll(deg[n - i - 1]); 21 printf(\u0026#34;%lld\\n\u0026#34;, ans); 22 return 0; 23}  pE  一開始會想用 cal(R) - cal(L - 1)，但後來想到 L 會是 0，且減一其實有點小麻煩，所以就用 cal(R) - cal(L - 1)，如果 L 是 rainbow number 就再把答案加一。 另外也有把前綴是 0 的 case 獨立算出來，讓狀態定義的比官解簡潔。  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 105 4typedef long long ll; 5const ll mod = 1000000007; 6inline int d (char c) {return c - \u0026#39;0\u0026#39;;} 7int check(string s) { 8 for (int i = 1; s[i]; i++) 9 if (s[i - 1] == s[i]) return 0; 10 return 1; 11} 12ll cal(string s) { 13 int len = s.length(); 14 ll ans = 0, tmp = 1; 15 for (int i = 1; i \u0026lt; len; i++) { //長度小於 len 的數量 16 tmp = tmp * 9 % mod; 17 ans = (ans + tmp) % mod; 18 } 19 s = \u0026#39;0\u0026#39; + s; 20 ll dp[maxn][10][2] = {}; 21 dp[0][0][1] = 1; 22 for (int i = 1; i \u0026lt;= len; i++) { //長度等於 len 的數量 23 if (s[i] != s[i - 1]) // dp[i][j][1] 代表前 i 位和 s 一樣 24 dp[i][d(s[i])][1] = dp[i - 1][d(s[i - 1])][1]; 25 for (int j = 0; j \u0026lt;= 9; j++) { 26 for (int k = 0; k \u0026lt;= 9; k++) 27 if (k != j) dp[i][j][0] += dp[i - 1][k][0]; 28 if (d(s[i - 1]) != j \u0026amp;\u0026amp; d(s[i]) \u0026gt; j) 29 dp[i][j][0] += dp[i - 1][d(s[i - 1])][1]; 30 d[i][j][0] %= mod; 31 } 32 } 33 for (int i = 0; i \u0026lt;= 9; i++) 34 ans = (ans + dp[len][i][0] + dp[len][i][1]) % mod; 35 return ans; 36} 37int main () { 38 int T; cin \u0026gt;\u0026gt; T; 39 while (T--) { 40 string L, R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; 41 cout \u0026lt;\u0026lt; (cal(R) - cal(L) + check(L) + mod) % mod \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 42 } 43 return 0; 44}  電路學 因為不太能理解這兩個式子是怎麼推導的，所以就 Line 了老師。得到的結論是，可以透過改變兩個電流的大小，把有平方的那一項變 0，之後我們就可以推出第二個式子。\n","date":"2020-12-16T10:20:38+08:00","permalink":"https://Luke2336.github.io/p/20201216/","title":"2020/12/16 日記"},{"content":"早上寫了投 Google 2021 Summer Intern, SWE 的履歷，然後去上電路學，期中補考勉勉強強有了 60 分，中午去科一印成績單和在學證明，因為中正堂施工不開放，但也去了郵局辦事。\n下午去找了 TTYeh 老師，聊了一下近況，以及助教的工作。下午寫了交換申請資料中的研修計畫，寫了兩頁半，感覺應該差不多了，主要都在花時間看課程表。\n晚餐吃了自助餐，配了卡通「新神偷卡門」，然後去工五看了電路學考卷，和蘇于討論了期末專題。然後收了包裹，整理了衣櫃，收到了兩隻折傘。\n整理衣服時，發現衣櫃後面藏進了一隻蟑螂，之後我就覺得好焦慮。\n交換申請資料 \u0026mdash; 研修計畫＆簡歷表 ","date":"2020-12-15T08:17:24+08:00","permalink":"https://Luke2336.github.io/p/20201215/","title":"2020/12/15 日記"},{"content":"早上搭車回新竹，雨很大，上車後到台北就沒雨了。從馬偕下車，然後搭小紅巴回學校。之後剪了香蜂草的枯枝病葉，還除了蟲，然後洗了衣服，吃了昨晚買的巧克力拿破崙配伯爵茶。\npJ. Inverse Factorial  給定一個長度不超過 1e6 的字串，代表 n!，求 n 是多少？ 答案的範圍不超過 1e6，所以可以直接 mod 一個夠大的質數  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define mod 1000000007 4typedef long long ll; 5int main () { 6 ios_base::sync_with_stdio(0); cin.tie(0); 7 string s; cin \u0026gt;\u0026gt; s; 8 ll sum = 0; 9 for (int i = 0; s[i]; i++) 10 sum = (sum * 10 + s[i] - \u0026#39;0\u0026#39;) % mod; 11 for (ll i = 1, frac = 1; ; i++) { 12 frac = (frac * i) % mod; 13 if (frac == sum) { 14 cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; 15 } 16 } 17 return 0; 18}  CSES - 1202 - Investigation  最短路徑水題 Dijkstra  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3const int mod = 1000000007; 4typedef long long ll; 5typedef pair\u0026lt;ll, int\u0026gt; pii; 6#define pb push_back 7int main () { 8 ios_base::sync_with_stdio(0); cin.tie(0); 9 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 10 vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n + 1); 11 for (int i = 0; i \u0026lt; m; i++) { 12 int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; 13 G[a].pb(pii(c, b)); 14 } 15 vector\u0026lt;bool\u0026gt; visit(n + 1); 16 vector\u0026lt;ll\u0026gt; dis(n + 1, ll(m) * ll(1e9)); 17 vector\u0026lt;ll\u0026gt; cnt(n + 1, 0), mn(n + 1), mx(n + 1); 18 dis[1] = 0, cnt[1] = 1; 19 priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, greater\u0026lt;pii\u0026gt;\u0026gt; pq; 20 pq.push(pii(0, 1)); 21 while (!pq.empty()) { 22 int u = pq.top().second; pq.pop(); 23 if (visit[u]) continue; 24 visit[u] = true; 25 for (pii e : G[u]) { 26 int uu = e.second; ll w = e.first; 27 if (dis[uu] == dis[u] + w) { 28 cnt[uu] = (cnt[u] + cnt[uu]) % mod; 29 mn[uu] = min(mn[uu], mn[u] + 1); 30 mx[uu] = max(mx[uu], mx[u] + 1); 31 } else if (dis[uu] \u0026gt; dis[u] + w) { 32 dis[uu] = dis[u] + w; 33 cnt[uu] = cnt[u] % mod; 34 mn[uu] = mn[u] + 1; 35 mx[uu] = mx[u] + 1; 36 pq.push(pii(dis[uu], uu)); 37 } 38 } 39 } 40 cout \u0026lt;\u0026lt; dis[n] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; cnt[n] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; mn[n] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; mx[n] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 41 return 0; 42}  認識語言 今天老師突然取消了之後所有考試，直接計算分數。除了 20% 的期末報告外，我拿了 72 分，看起來有機會拿 A+。\n今天的主題是手語，還有猩猩無法學會人類語言。\n","date":"2020-12-14T11:29:37+08:00","permalink":"https://Luke2336.github.io/p/20201214/","title":"2020/12/14 日記"},{"content":"回到家之後很好睡，睡了 12 小時。早上寫完電路學作業，難得的好天氣，下午就被帶去海邊看貓，晚上去礁溪吃甕仔雞和泡溫泉，在那邊遇到奇怪的蘭陽溫泉嘉年華遊行。\n 喜歡被摸屁屁的白貓\n很愛蹭的小黑白，想抱回家。\n以前在石頭屋遇到的小貓已經變媽媽了，生了三隻小花貓，一隻健康有問題被獸醫院收養。\n","date":"2020-12-14T11:16:40+08:00","permalink":"https://Luke2336.github.io/p/20201213/","title":"2020/12/13 日記"},{"content":"一大早就搭別人的車，很早就到北一了，發現憲兵的制服很像警察\u0026hellip;\u0026hellip;\n先去資訊組和芳蘭老師聊天，遇到了湘鈴學姊。\n之後去找怡芬老師，但她還在忙，於是我就先去找貽婷老師了，但只遇到進松，聊了一陣子，還拍了一張照。\n去國文科看展，遇到班導，覺得學妹作品很美，作文比賽的得獎作品，文字青澀，沈重而帶有著青春的憂愁。然後也看了資訊科的展，但覺得學妹的作品不吸引人。\n跟郁芬她們會合後，買了學妹的冰淇淋泡芙，然後去了學珠四樓，還有逛了歷史科的展。\n之後我就跑去找荔枝聊天了。四點多才又見到怡芬老師，還遇到薯餅。但只是匆匆忙忙的聊了幾句，她邀請我寒假再過去她家玩，有空也可以在她下班後找她吃飯。\n  人生的密碼：謙虛、感恩\nby 芳蘭老師\n ","date":"2020-12-14T11:16:34+08:00","permalink":"https://Luke2336.github.io/p/20201212/","title":"2020/12/12 日記"},{"content":"和學長吃飯 吃了清夜的義大利麵，然後去蒙民偉樓四樓吃甜點喝茶，聊了很多最主要是關於感情。\n電路學補考 因為星期六想回去北一參加校慶，所以就問助教能不能提早補考。覺得寫得很順，但這兩週其實並未複習，可見第一次考試太焦慮了而已。\n宵夜 吃了熱熱的紅豆湯，覺得很幸福。\n","date":"2020-12-11T21:12:09+08:00","permalink":"https://Luke2336.github.io/p/20201211/","title":"2020/12/11 日記"},{"content":"早上先去還書，之後去處理報帳，把剩下的人的電話交給助理，之後買了麥當勞吃。接下來開始動工交換要繳交的備審資料，今天下午完成了自傳中想放的簡歷表，刪刪減減後，用不到三十行就把高中大學比較重點的成績呈現出來，比當初申請大學時的簡潔。\n之後去上電路學，今天是教電路間的磁場交互作用，提到了一些竊取晶片信用卡密碼的觀念。下課時，跟老師提了想明晚提早補考，以在週六回去參加期待多年的北一大校慶。\n下課後去圖書館領預約了三個月的電路學課本，剛開學時就推薦採購，幸好在學期末前拿到手了，以後寫電路學功課就方便了。順便借了一本中文的作業系統，希望能把之前的觀念補起來。\n晚上去買了自助餐吃，但好像肉夾太多了，被多收五塊錢。然後看了兩集「雲畫的月光」，算是搞笑劇，應該會當作配飯的韓劇。然後讀了一下電路學。\n電路學 CH11     Units      Complex Power VA $$\\mathbb{S} = P + jQ = \\frac{1}{2} \\mathbb{VI}^* = V _{rms} I _{rms} \\angle (\\theta_v - \\theta_i)$$   Apparent Power VA $$S = \\vert\\mathbb{S}\\vert = V _{rms} I _{rms}$$   Real Power Watt $$P$$   Reactive Power VAR $$Q$$   Power Factor  $$pf = \\frac{P}{S} = \\cos(\\theta_v - \\theta_i)$$     $$\\mathbb{Z} = R + jX = |\\mathbb{Z}|\\angle \\theta,\\ \\theta_v - \\theta_i = \\theta \\in [-90\\degree, 90\\degree]$$\n   Load X     Resistive Load $$X = 0$$   Inductive Load $$X \u0026gt; 0$$   Capacitive Load $$X \u0026lt; 0$$     Power Factor Correction (Parallel) $$C = \\frac{P_1 (\\tan {\\theta _2} - \\tan {\\theta _2})}{\\omega V _{rms} ^2}$$ $$L = \\frac{\\omega P_1 (\\tan {\\theta _2} - \\tan {\\theta _2})}{V _{rms} ^2}$$\n","date":"2020-12-10T20:09:00+08:00","permalink":"https://Luke2336.github.io/p/20201210/","title":"2020/12/10 日記"},{"content":"早上心情很不好，所以上完德文後，又把 OS 睡掉了。中午買了個牛腩丼飯，然後去上了羽球課。和卡車吃了蛋捲冰淇淋，剛好店員不小心裝太大隻，所以吃得很滿足。洗完澡後就去練習，有點遲到。點了牛肉燴飯，但料很少，讓我很失望。\n羽球課 今天是教後場步伐和揮拍，然後讓我們練習兩週後要考的米字步。首先是側身架拍，然後右腳蹲，然後單腳跳腰轉隱拍，之後在揮拍，左腳往前恢復準備姿勢。羽球鞋穿的還不太習慣，畢竟跟慢跑鞋比很有重量，希望能早點習慣。\nPCCA  Kattis 題單  今天是拆成 30 分鐘為單位，交換隊友練習，今天有觀察到的有 LandyLu、CTFang 那對，還有 LinLee 找的吳柏橙，只有 CTFang 我比較喜歡。最近對隊友們的感情也有點冷淡，慢慢觀察到不少他們的缺點，而 CTFang 卻比較像 Ud 一樣沈穩，雖然他的隊友卻沒什麼表現，但我還是傾向於換隊友。\nD. Kattis - ivana  賽局 DP 把環狀的東西，直接複製兩份去建表。 Complexity: $$O(n^2)$$  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define INF 10000 4int main() { 5 ios_base::sync_with_stdio(0); cin.tie(0); 6 int n; cin \u0026gt;\u0026gt; n; 7 int a[205], dp[205][205]; 8 for (int i = 0; i \u0026lt; n; i++) { 9 cin \u0026gt;\u0026gt; a[i]; a[n + i] = a[i]; 10 } 11 for (int i = 0; i \u0026lt; 2 * n; i++) 12 dp[i][i] = a[i] % 2; 13 for (int l = 1; l \u0026lt; n; l++) 14 for (int i = 0, j = l; j \u0026lt; 2 * n; i++, j++) { 15 dp[i][j] = (l % 2) ? INF : -INF; 16 if (l % 2) dp[i][j] = min(dp[i][j], 17 min(dp[i + 1][j] - a[i] % 2, 18 dp[i][j - 1] - a[j] % 2)); 19 else dp[i][j] = max(dp[i][j], 20 max(dp[i + 1][j] + a[i] % 2, 21 dp[i][j - 1] + a[j] % 2)); 22 } 23 int ans = 0; 24 for (int i = 0; i \u0026lt; n; i++) { 25 if (n % 2 == 0) { 26 if (-a[i] % 2 + dp[i + 1][i + n - 1] \u0026lt; 0) ans++; 27 } else { 28 if (a[i] % 2 + dp[i + 1][i + n - 1] \u0026gt; 0) ans++; 29 } 30 } 31 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 32 return 0; 33}  ","date":"2020-12-09T12:34:03+08:00","permalink":"https://Luke2336.github.io/p/20201209/","title":"2020/12/09 日記"},{"content":"起床時就覺得很冷很不舒服，心情很悶，就又睡了一下，然後去上電路學。在宿舍時，跌下了樓梯，幸好只滑了五階左右，沒有受傷，只有腰有點痠，腳踝和膝蓋略略不適。上課時因為想吐的感覺，有點坐立不安，回宿舍後一直睡到快三點。起床後又躺到快四點，什麼東西都沒吃。\n電路學今天比較早教完，老師就用十分鐘聊了一下他對台大前一陣子很多學生自殺的想法，他認為，自殺是愚蠢的，讀書讀不好，可能就只是選錯科系，就像交男女朋友一樣，很難第一次就找到對的人，轉換跑道就好了。我認為他這段話或許是正確的，但自殺不應該被想成這麼簡單的行為。\n傍晚看了中醫，因為反胃，所以一整天都沒吃飯，所以有些暈眩，眼前一片黑，針灸後噁心感消失了。之後去建中路吃了原味燉品屋，點了人參雞，覺得人參滿多的。躺了一下，然後去上電路學的演習課，今天 TA 只有講幾個大概念，所以 20:15 左右就下課了。\n半夜收到 email 通知說電路學要補考，覺得很難過，因為自己覺得重點的觀念都已經學會了，卻還是考得不好。滿挫折的，因為這是自己最近花比較多心力的科目，覺得能做好，卻還是沒有。\n","date":"2020-12-08T16:03:04+08:00","permalink":"https://Luke2336.github.io/p/20201208/","title":"2020/12/08 日記"},{"content":"起床後洗了澡，然後就買了個丼飯吃，邊看「夜叉姬 E8」。之後去上認識語言，今天主要是在講雙語嬰兒的認知能力，然後也講了 Executive Function (EF) 的概念，我認為用它去描述一個人是否聰明是合理的。老師也談了應該在 6 歲前，給予小孩足夠的陪伴，在前額葉發展的黃金期，陪他一起讀外語繪本。下課後，在宿舍泡了杯紅茶，然後讀電路學 Ch11 的投影片。之後寫了兩題電路學，花了 45 分鐘。\n電路學 CH11   Instantaneous Power $$\\displaystyle\\begin{aligned} i(t) \u0026amp;= I_m \\cos (\\omega t + \\theta_i)\\\\ v(t) \u0026amp;= V_m \\cos (\\omega t + \\theta_v)\\\\ p(t) \u0026amp;= \\frac{1}{2} I_m V_m (\\cos(\\theta_v - \\theta_i) + \\cos(2\\omega t + \\theta_v + \\theta_i)) \\end{aligned}$$\n  Average Power $$\\displaystyle\\begin{aligned} P \u0026amp;= \\frac{1}{T} \\int_0^T p(t) dt \\\\ \u0026amp;= \\frac{1}{2} I_m V_m \\cos(\\theta_v - \\theta_i) \\\\ \u0026amp;= \\frac{1}{2} Re[\\mathbb{VI}^*] \\end{aligned}$$\n  Maximum Average Power Transform $$\\displaystyle\\begin{aligned} \\mathbb{Z}_{Th} \u0026amp;= R_{th} + j X_{Th},\\mathbb{Z}_{L} = R_{L} + j X_{L} \\\\ \\mathbb{I} \u0026amp;= \\frac{ \\mathbb{V}_{Th} }{\\mathbb{Z}_{Th} + \\mathbb{Z}_{L}} = \\frac{ \\mathbb{V}_{Th} }{(R_{th} + R_L) + j (X_{Th} + X_L)} \\\\ P \u0026amp;= \\frac{1}{2} Re[\\mathbb{VI} ^ *] = \\frac{1}{2} Re[\\mathbb{Z}_{L} \\mathbb{II} ^ *] = \\frac{1}{2} |\\mathbb{I}| ^ 2 {R}_{L} \\\\ \u0026amp;= \\frac{ | \\mathbb{V}_{Th} | ^ 2 {R}_{L} }{({R}_{th} + {R}_{L}) ^ 2 + ({X}_{Th} + {X}_{L}) ^ 2} \\\\ \\frac{\\partial P}{\\partial X _L} \u0026amp;= 0 \\implies X _ L = - X _ {Th} \\\\ \\frac{\\partial P}{\\partial R _L} \u0026amp;= 0 \\implies R _ L = R _ {Th} \\\\ \\implies \\mathbb{Z}_{L} \u0026amp;= \\mathbb{Z}_{Th} ^ * \\implies P_{max} = \\frac{|\\mathbb{V}_{Th}|^2}{8} \\end{aligned}$$\n  Effective Value / RMS Value\n  $$\\begin{aligned} P_R \u0026amp;= \\frac{1}{T} \\int_0^T i^2 R dt = I_{eff}^2 R \\\\ I_{eff} \u0026amp;= \\sqrt{\\frac{1}{T} \\int_0^T i^2 dt} = I_{rms} \\\\ I_{rms} \u0026amp;= \\sqrt{\\frac{1}{T} \\int_0^T I_m^2 \\cos^2 (\\omega t + \\theta_i)dt} \\\\ \u0026amp;= \\sqrt{\\frac{1}{T} \\int_0^T I_m^2 (1 + \\cos (2\\omega t + 2\\theta_i))dt} \\\\ \u0026amp;= \\frac{I_m}{\\sqrt 2} \\\\ P \u0026amp;= I_{rms}^2 R = \\frac{V_{rms}^2}{R} \\end{aligned}$$\n","date":"2020-12-07T12:30:04+08:00","permalink":"https://Luke2336.github.io/p/20201207/","title":"2020/12/07 日記"},{"content":"因為吃了過敏藥，睡到下午一點才起來，買了麥當勞吃，接下來的時間都在整理衣櫃。晚上吃了蛋包飯，然後去打球。打球前和 Hsu 聊過他女友的事，和他散步到清大操場，打完球在 7-11 遇到明憲學長，他送我走回宿舍。今天第一次穿新球鞋打球，略略有點重量。今天打球算是普通普通，沒有特別的感覺，總共只運動了一小時。回房間後收拾完衣櫃，然後喝了杯牛奶，把「大長今」看完。\n今年刷了很多小時候看的卡通和韓劇。\n 犬夜叉 結界師 同伊 善德女王 擁抱太陽的月亮 大長今  ","date":"2020-12-06T21:34:29+08:00","permalink":"https://Luke2336.github.io/p/20201206/","title":"2020/12/06 日記"},{"content":"CSES - 1197 - Cycle Finding  卡車說可以從一個假點開始做 SSSP，也就是將所有點的距離都先設成 0。 我的寫法複雜度看起來不好，感覺假解了，但想不到該怎麼改，可能會 TLE。 想了一個確定複雜度是 O(VE) 的解，將整張圖做 SCC，形成一個 DAG，從每個 in-degree 為 0 的 SCC 選一個點做 DFS。  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;int, ll\u0026gt; pii; 5#define pb push_back 6vector\u0026lt;int\u0026gt; ans; 7vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G; 8vector\u0026lt;bool\u0026gt; visit; 9vector\u0026lt;bool\u0026gt; use; 10vector\u0026lt;ll\u0026gt; dis; 11int dfs(int v) { 12 use[v] = visit[v] = true, ans.pb(v); 13 for (pii e : G[v]) { 14 int u = e.first; 15 ll w = e.second; 16 if (dis[u] \u0026lt;= dis[v] + w) continue; 17 dis[u] = dis[v] + w; 18 if (visit[u]) return u; 19 int ret = dfs(u); 20 if (ret) return ret; 21 } 22 visit[v] = false, ans.pop_back(); 23 return 0; 24} 25int solve(int n) { 26 for (int i = 1, ret; i \u0026lt; n; i++) 27 if (!use[i] \u0026amp;\u0026amp; (ret = dfs(i))) return ret; 28 return 0; 29} 30bool SPFA (int n) { 31 queue\u0026lt;int\u0026gt; q; 32 vector\u0026lt;int\u0026gt; cnt(n); 33 vector\u0026lt;bool\u0026gt; inque(n); 34 for (int i = 1; i \u0026lt; n; i++) { 35 if (cnt[i]) continue; 36 inque[i] = 1, q.push(i); 37 while (!q.empty()) { 38 int u = q.front(); q.pop(); 39 inque[u] = false; 40 for (pii p : G[u]) { 41 int uu = p.first; ll w = p.second; 42 if (dis[uu] \u0026gt; dis[u] + w) { 43 dis[uu] = dis[u] + w, cnt[uu]++; 44 if (cnt[uu] \u0026gt; n) return false; 45 if (!inque[uu]) inque[uu] = true, q.push(uu); 46 } 47 } 48 } 49 } return true; 50} 51int main() { 52 ios_base::sync_with_stdio(0); cin.tie(0); 53 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; n++; 54 G.resize(n), visit.resize(n), dis.resize(n), use.resize(n); 55 for (int i = 0; i \u0026lt; m; i++) { 56 int a, b; ll c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; 57 if (a == b \u0026amp;\u0026amp; c \u0026lt; 0) // loop 58 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 59 G[a].pb(pii(b, c)); 60 } 61 if (SPFA(n)) { cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; return 0;} 62 int v = solve(n), flag = 0; 63 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; 64 for (int x : ans) { 65 if (x == v) flag = 1; 66 if (flag) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 67 } 68 cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 69 return 0; 70}  ","date":"2020-12-05T22:36:18+08:00","permalink":"https://Luke2336.github.io/p/negative_cycle/","title":"有向圖找負環 (Negative-Cycle)"},{"content":"今天較嗜睡，睡了快九個小時。起床後買了麥當勞吃，然後做了家教的投影片 - 最近點對。之後練了打字，也開始練了德文輸入法。\n之後讀了認識語言的閱讀作業 \u0026ldquo;Flexible Learning of Multiple Speech Structures in Bilingual Infants\u0026rdquo;，一篇關於單語和雙語環境小孩的語言學習能力，發現雙語環境的小孩對不同結構的詞區別能力較好，這篇同樣用 Eye-tracking 實驗。\n研究了一下選課和交換相關的東西後，就去買自助餐吃，也泡了一杯熱可可。然後上了家教，今天選 Trie 和 Closest Pair 教，下課後她問了我關於 LCS 的東西。晚上 AC 了找負環的題目。\n","date":"2020-12-05T21:34:29+08:00","permalink":"https://Luke2336.github.io/p/20201205/","title":"2020/12/05 日記"},{"content":"餐聚 和振華學長一起吃風雲四樓，點了紅酒燉牛肉飯，之後去水木二樓的咖啡店。聊了很多事，關於他的新女友，關於我和卦長之間的事，也聊了對於競賽的想法，還有聊一些對於之後幾年的規劃。\n他滿認同我選擇轉系，大四下出去交換的選擇。他鼓勵我研究所留在清大念，但我猜有一部分的因素是考慮到感情。\n羽球鞋 晚上去光復路靠近公園一帶找羽球鞋，在 SOSA 逛的時候，有看到兩雙還算能接受的外觀，但價位在 2500 - 3200。然後去對面的宏展，有多了一些羽排鞋的選項，有看上一雙 $1450 藍白色的 ASICS，一開始我是找 26.5 cm，但只有 26 cm，最後用三倍券買了。剛好顏色會和球衣很搭，然後也相對比較中性。\n","date":"2020-12-04T22:52:12+08:00","permalink":"https://Luke2336.github.io/p/20201204/","title":"2020/12/04 日記"},{"content":"CF-GYM100274 pA  問題：2 \u0026lt;= n \u0026lt;= 1e18，2 \u0026lt;= k \u0026lt;= 1e12，求 n! 是 k 的幾次方。 作法：將 k 做質因數分解，然後各自算出次方數後，再取最小值。 時間：$$O(\\log n \\sqrt k)$$  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4typedef pair\u0026lt;ll, int\u0026gt; pli; 5vector\u0026lt;pli\u0026gt; prime_factor (ll k) { 6 vector\u0026lt;pli\u0026gt; ret; 7 for (ll i = 2; i * i \u0026lt;= k; i++) { 8 if (k % i) continue; 9 pli p = pli(i, 0); 10 while (k % i == 0) k /= i, p.second++; 11 ret.push_back(p); 12 } 13 if (k \u0026gt; 1) ret.push_back(pli(k ,1)); 14 return ret; 15} 16int main() { 17 ios_base::sync_with_stdio(0); cin.tie(0); 18 int T; cin \u0026gt;\u0026gt; T; 19 while (T--) { 20 ll n, k, ans = -1; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; 21 vector\u0026lt;pli\u0026gt; fac = prime_factor(k); 22 for (pli p : fac) { 23 ll cnt = 0, m = n; 24 while (m) cnt += (m = m / p.first); 25 cnt /= p.second; 26 if (ans == -1 || cnt \u0026lt; ans) ans = cnt; 27 } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 } return 0; 29}  pB  問題：給定兩個相同長度的字串，問能不能各自找到長度至少一半的子字串，使得字元和字元兩兩的絕對值差不超過 1。例如 \u0026ldquo;aabb\u0026rdquo; 和 \u0026ldquo;bbbb\u0026rdquo; 就是符合的。 作法：平移後，對重疊處做最大連續和。 時間：$$O(n^2)$$  1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 ios_base::sync_with_stdio(0); cin.tie(0); 5 int T; cin \u0026gt;\u0026gt; T; 6 while (T--) { 7 int n; cin \u0026gt;\u0026gt; n; 8 string a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 9 int ans = 0; 10 for (int i = 0; i \u0026lt; n; i++) { 11 for (int j = 0, sum = 0; j + i \u0026lt; n; j++) 12 if (abs(a[j] - b[j + i]) \u0026lt;= 1) 13 ans = max(ans, ++sum); 14 else sum = 0; 15 for (int j = 0, sum = 0; j + i \u0026lt; n; j++) 16 if (abs(a[j + i] - b[j]) \u0026lt;= 1) 17 ans = max(ans, ++sum); 18 else sum = 0; 19 } 20 if (ans * 2 \u0026gt;= n) cout \u0026lt;\u0026lt; \u0026#34;POSITIVE\\n\u0026#34;; 21 else cout \u0026lt;\u0026lt; \u0026#34;NEGATIVE\\n\u0026#34;; 22 } 23 return 0; 24}  pC  Topological Sort  pD  暴力枚舉＋剪枝  pE  DP  pF  水題  pG  幾何實作  pH  DP  pI  Flow  pJ  找樹的半徑。  pK  Coloring on Plannar Graph  pL  DP  ","date":"2020-12-03T23:56:03+08:00","permalink":"https://Luke2336.github.io/p/cf_gym_100274/","title":"CF GYM 100274"},{"content":"研究大三下課表 昨晚 Hyperbola 告訴我課表已經出來了，於是早上就先研究了一下。系統看起來跟陽明有一些整合，所以時間表示的方式變得比較像清大。\n學分數 預計體育以外總共 6 ~ 7 門課，或許可以把星期一空出來。也想留點時間做研究和打 ICPC。\n   Type Unit     主科 9 - 12   外文 2 - 4   通識 2   Total 15 - 18    時間表     M T W R F     1        2  密碼學      3  正規語言      4  正規語言      n        5  難解問題 羽球  密碼學   6  難解問題 羽球  密碼學   7  難解問題  正規語言    8         資工課程 還在考慮要幾門主科，預計下限三門，上限四門，要看要帶多少學分上去研究所。\n   Course Time Unit     正規語言概論 T34R7 3   密碼學概論 T2F56 3   難解計算問題專論 T567 3   計算方法之實務應用 Mn56 3   自然語言處理（網路課程） F234 3    外文 預計一門大一英文，再加上一門進階英文或二外。 但還是會想考英檢抵掉額外的四學分，畢竟不算在畢業學分，但多修點英文課也沒什麼不好，只是要擔心延畢？\n   Course Time Unit     大一英文（二） M78, W34, R34, R56 2   德文（二） W34 2   日文(一) M12, W12, W34, R34 2   進階英文寫作 F34, M34 2    通識 應該就是選一門核心通識。歷史課幾乎都撞堂，所以可能會先選一門社會向度，四上再選一門歷史課，目前考慮時間應該會優先選 W34 的心理學 和 R34 的教育學。\n   Course Time Unit 向度     哲學概論 F34 2 人文   心理學概論 M56, W34, F34 2 社會   教育學概論 R34 2 社會   文學經典：台灣文學 M789 3 人文   音樂概論 F56 2 人文   文化人類學概論 F56 2 人文   邏輯與思維 F56 2 人文    大四上規劃 如果四下交換時的學分能算在選修裡，那多出來的學分就可以帶到研究所。\n 專題 2 學分 通識 2 學分 主科 6 學分（研究所課） 外文？  報帳 處理得差不多了，還剩五份有問題，就打算拖到一週後再處理。\n電路學  上課前坐在工五一樓打程式，遇到助教，聽起來我第二次期中應該是剛好及格。 下課時老師講了期末專題的事，12/17 要把 Topic 交出來，覺得有點難，雖然只要是跟電路相關的主題都行，但不確定哪個題目較容易做出東西。本來想研究「Dual Circuit in non-plannar graph」，但似乎已經被研究的差不多了。可能得花點時間去想新的題目，一邊閱讀一些文獻，看有沒有辦法做的更仔細，或是有新的作法。  隊練 因為學弟昨天就被劇透了，所以就沒補昨天的題目了。\n宵夜 練完題後，卡車約我們檢討，並去和味吃宵夜，我點了清粥，他們都點滷肉飯。在那邊的停車場遇到三隻有人餵的貓咪。\n","date":"2020-12-03T12:08:51+08:00","permalink":"https://Luke2336.github.io/p/20201203/","title":"2020/12/03 日記"},{"content":"OS HW1 (Python) 中午研究了一下 OS 的作業一，因為對 Python 還不熟，所以先研究了一些模組和函式的用法。之後再慢慢研究 Multithread、Multiprocessing 和 Coroutine。因為期中考表現的很糟，希望能在作業拚一下，把總成績拉到 A。\nRequests: Website Title  $ pip3 install requests $ pip3 install beautifulsoup4  1import requests 2from bs4 import BeautifulSoup 3url = input() 4r = requests.get(url) 5while r.status_code != requests.codes.ok : # 200 6\tr = requests.get(url) 7soup = BeautifulSoup(r.text, \u0026#39;html.parser\u0026#39;) 8print(soup.find(\u0026#39;title\u0026#39;).text) SHA 記得要先 encode('utf-8')\n1import hashlib # 內建的 2 3def SHA256(s): 4 sha = hashlib.sha256() 5 sha.update(s.encode(\u0026#39;utf-8\u0026#39;)) 6 return sha.hexdigest() #str update() 會拼接之前輸入的字串\n1sha1 = hashlib.sha256() 2sha1.update(b\u0026#39;python\u0026#39;) 3 4sha2 = hashlib.sha156() 5sha2.update(b\u0026#39;py\u0026#39;) 6sha2.update(b\u0026#39;thon\u0026#39;) 7 8sha1.hexdigest() == sha2.hexdigest() #true Coding  CSES - 1197 - Cycle Finding  下午研究了一下輸出負環的寫法。    隊練  Kattis 題單 這次試著隨機挑題，我跟 LinLee 採取 pair rogramming， Hyperbola 單開，看結果差多少。LinLee 打了一個鐘頭後就跟我說他想睡覺，於是後面他就有點廢，但看起來 Hyperbola 的速度明顯有優勢，但基本上兩方都不穩定，應該要試著一次 AC。 pG 發現 LinLee 不會 Union Find Tree 的分析，但其實那題應該要用 BFS。 pE 的複雜度分析花了些時間，最後用 O(EF) 估計。 pG 因為沒開 LongLongInt 或 Double，所以 Overflow。 這次題目整體難度不高，下次會選擇難度更高的題組。 晚餐只吃了雞肉飯，結束後有點冷，所以去吃了人參雞湯。      Kelly, LinLee Hyperbola Diff Type     A 4  1.5    B 27(1) 26 2.8 DP   C 5 3 1.8    D 9(1) 8(1) 2.4    E 62 53(3) 4.2 Flow   F 7 5 2.1    G Give Up 12 4.5 BFS   H (3) 6(2) 3.3    I 10 10(2) 3.4    J 20(1) Give UP 4.4 Math    ","date":"2020-12-02T10:58:23+08:00","permalink":"https://Luke2336.github.io/p/20201202/","title":"2020/12/02 日記"},{"content":"早上是電路學第二次期中考，考得有點糟糕，因為不太會算 Initial Condition。\n下午嘗試補了台北站的 pE，但 WA 了。\n今天是卡車生日。\n12 月是個值得期待，但也很多事要做的月份，有聖誕節、跨年，也有期末考、選課。\n12 月 Todo  交換申請資料 OS  複習期末考 HW1、HW2、HW3   電路學  複習期末考 小考、作業 期末專題   認識語言  期末報告 Paper Reading 小考   德文  複習文法、片語、單字   羽球  米字步   競程  補題：CodeForces、Kattis 刷題：USACO、SPOJ Rank：Codeforces、AtCoder    ","date":"2020-12-01T12:24:22+08:00","permalink":"https://Luke2336.github.io/p/20201201/","title":"2020/12/01 日記"},{"content":"今天精神較好，可能是因為前一晚吃了 B 群，雖然為了報帳早起沒睡飽，但晚上的效率還不錯。下午上完課肚子餓，就先買了麥當勞吃。傍晚洗澡前練了一下揮拍，又跳了繩。晚上原本想吃燒餅蛋，但豆漿店又沒有燒餅了。\nICPC 報帳  因為雙曲線早上要值班，所以就跟他約在系計中，想說要幫他送報帳的報表。但沒想到他收的時候都不檢查，他說是因為他擔心他檢查了，有問題他就要負責。心好累，跟他耗了一小時。我覺得他很不負責任，然後整個過程一直兇我，LinLee 聯絡不到，他也一副不在意。我真的很不開心。 去校計中找謝小姐時，看著東缺西缺的東西，覺得好丟臉，但她還是很有耐心的一份份找 bug。 回去找他時，因為我盯著計中櫃檯的螢幕，又被他兇了。我發現每次他態度愈是堅定時，我對他的話愈是無法接受，就算他是合理的，我覺得他對人的態度還是會讓他沒辦法達到目的。 他每一句感謝，聽在我耳裡，我都覺得好累，大概理解媽媽對外婆的想法了。 一直到下午上課時才整理完資料。  電路學 Midterm 2 複習    Chapter Time (min) #Problem     8 55 6   10 55 7    Ch8  Source-Free Series RLC Circuit  $$\\displaystyle i'' + \\frac{R}{L} i' + \\frac{1}{LC} i = 0$$   Source-Free Parallel RLC Circuit  $$\\displaystyle v'' + \\frac{1}{RC} v' + \\frac{1}{LC} v = 0$$   Solutions of Second Order Differential Equations  Overdamped: $$y(t) = A_1 e^{s_1 t} + A_2 e^{s_2 t}$$ Critically Damped: $$y(t) = (A_1 t + A_2) e^{-\\alpha t}$$ Underdamped: $$y(t) = e^{-\\alpha t} (A_1 \\cos \\omega_\\alpha t + A_2 \\sin \\omega_\\alpha t)$$    Ch9     $$R$$ $$L$$ $$C$$     $$Z$$ $$R$$ $$j \\omega L$$ $$\\frac{1}{j\\omega C}$$    ","date":"2020-11-30T11:59:23+08:00","permalink":"https://Luke2336.github.io/p/20201130/","title":"2020/11/30 日記"},{"content":"早上起床洗了衣服，然後洗了澡，之後架好了部落格，然後就去讀書。\nDate 和 Jacky 吃了買一送一的冰炫風，然後一起去圖書館讀書，晚餐去研三吃漢堡王。從圖書館出來時，看到了漂亮的雲。\n部落格 從星期四努力到現在，終於搞定了。\n之後會拿這個部落格來寫日記，可能也會寫一點練題紀錄，摻雜一點點讀書帳的味道。\n 參考了 bb 的部落格，決定使用 hugo 搭配 github.io。 從 blogger 轉來使用 hugo 的原因，其實是想用 markdown，因為會寫一些數學或是程式碼。 逛了一整晚的 Hugo Theme，最後決定用中國人設計的 hugo-theme-stack，主要是喜歡他簡潔的頁面，還有 categories 的設計。 參考 這篇 來放到 github 上。  電路學 Midterm 2 複習    Chapter Time (min) #Problem     7 40 7   8 40 5    Ch7  $$\\displaystyle y(t) = y(\\infty) + (y(t_0) - y(\\infty)) e^{\\frac{-(t - t_0)}{\\tau}}$$ RC Circuit: $$\\tau = RC$$ RL Circuit: $$\\tau = \\displaystyle \\frac{L}{R}$$  羽球 今天在新館打球，不小心跑到舊館。風很大，只有穿短袖短褲，不小心著涼了。今天前場比較積極，所以被稱讚有進步。有和碩班的學長姐打了兩場，覺得還不錯，之後幾場感覺比較沒力。\n驗題 和 Hyperbola 吵了很久，他的 BIT2D 不是區間更新，而只有單點更新。\n最後想了一下，二維 BIT 的區間更新 $$O(\\log^2 N)$$ 應該做不到，需要 $$O(N\\log N)$$。\n暗自覺得他都不搞清楚原理，對自己在寫的東西沒有概念。也許就像 MT 說的，很多競程選手學東西都求快，不夠扎實。卡車對他的觀察有點道理，他有時候過分自信，不容易發現自己的錯。\n","date":"2020-11-29T02:06:51+08:00","permalink":"https://Luke2336.github.io/p/20201129/","title":"2020/11/29 日記"},{"content":"Codeforces Round #615 (Div. 3) 第一次 CF 賽中破台，排名 +178，總算 1700 了。 pD 稍微想了一下子，pE 實作上卡了很久，有些邊界問題沒考慮清楚。pF 想了一下子才發現很好寫，但忘了考慮一直鏈的情況，所以 WA 了一次。\nA. Collecting Coins 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long LL; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 int t; cin \u0026gt;\u0026gt; t; 7 while (t--) { 8 LL a, b, c, n; 9 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; n; 10 LL sum = n + a + b + c; 11 if (sum % 3) { 12 cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; 13 continue; 14 } 15 sum /= 3; 16 if (sum \u0026lt; a || sum \u0026lt; b || sum \u0026lt; c) { 17 cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; 18 continue; 19 } 20 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; 21 } 22 return 0; 23}  B. Collecting Coins 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef pair\u0026lt;int, int\u0026gt; pii; 4#define x first 5#define y second 6int main() { 7 ios::sync_with_stdio(0), cin.tie(0); 8 int t; cin \u0026gt;\u0026gt; t; 9 while (t--) { 10 int n; cin \u0026gt;\u0026gt; n; 11 vector\u0026lt;pii\u0026gt; p(n); 12 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; 13 sort(p.begin(),p.end()); 14 bool success = true; 15 for (int i = 1; i \u0026lt; n; i++) 16 if(p[i].x \u0026lt; p[i-1].x || p[i].y \u0026lt; p[i-1].y) 17 success = false; 18 if(!success) { 19 cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; 20 continue; 21 } 22 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; 23 int xx = 0, yy = 0; 24 for(int i = 0; i \u0026lt; n; i++) { 25 while (xx != p[i].x) cout \u0026lt;\u0026lt; \u0026#34;R\u0026#34;, xx++; 26 while (yy != p[i].y) cout \u0026lt;\u0026lt; \u0026#34;U\u0026#34;, yy++; 27 } 28 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 29 } 30 return 0; 31}  C. Product of Three Numbers 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3int main() { 4 ios::sync_with_stdio(0), cin.tie(0); 5 int t; cin \u0026gt;\u0026gt; t; 6 while (t--) { 7 int n; cin \u0026gt;\u0026gt; n; 8 vector\u0026lt;int\u0026gt; ans; 9 for (int i = 2; i * i \u0026lt;= n \u0026amp;\u0026amp; ans.size() \u0026lt; 2; i++) { 10 if (n % i) continue; 11 ans.push_back(i); 12 n /= i; 13 } 14 if (ans.size() != 2 || n \u0026lt;= ans.back()) { 15 cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; 16 continue; 17 } 18 cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; 19 ans.push_back(n); 20 for (int i = 0; i \u0026lt; 3; i++) 21 cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==2]; 22 } 23 return 0; 24}  D. MEX maximizing 每次新增一個數字到序列裡，可對序列每個數字任意加減x的整數倍，問操作完後，序列中所缺的最小正整數最大是多少？\n一開始可以確定答案不可能超過當前 query 的次數，且答案會單調遞增。可以知道 y[i] 可以加減 x 的整數倍，故可以直接 y[i] 紀錄 mod x 出現幾次，然後將答案往後爬。複雜度 O(q)。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define MAX 800005 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 int q, x; cin \u0026gt;\u0026gt; q \u0026gt;\u0026gt; x; 7 int ans = 0; 8 int cnt[MAX] = {}; 9 for (int i = 0; i \u0026lt; q; i++) { 10 int a; cin \u0026gt;\u0026gt; a; 11 cnt[a % x]++; 12 while (cnt[ans % x]){ 13 cnt[ans % x]--; 14 ans++; 15 } 16 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 17 } 18 return 0; 19}  E. Obtain a Permutation 只需要將每個 column 單獨計算，再將所有結果相加即可。\n單一個 column，對每一格去算到達正確位置需要幾次操作，用個陣列去計算，轉 k 次能讓多少個格子到達正確位置。總複雜度 O(mn)。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define MAX 200005 4int cnt[MAX] = {}; 5int main() { 6 ios::sync_with_stdio(0), cin.tie(0); 7 int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a(n, vector\u0026lt;int\u0026gt;(m)); 9 for (int i = 0; i \u0026lt; n; i++) 10 for (int j = 0; j \u0026lt; m; j++) 11 cin \u0026gt;\u0026gt; a[i][j]; 12 int sum = 0; 13 for (int j = 0; j \u0026lt; m; j++) { 14 for (int i = 0; i \u0026lt; n; i++) { 15 if (a[i][j] \u0026lt;= n * m \u0026amp;\u0026amp; (j+1) % m == a[i][j] % m) { 16 int ii = (a[i][j] - 1) / m; 17 cnt[(i + n - ii) % n]++; 18 } 19 } 20 int ans = MAX; 21 for (int i = 0; i \u0026lt; n; i++) { 22 ans = min(ans, n - cnt[i] + i); 23 cnt[i] = 0; 24 } 25 sum += ans; 26 } 27 cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 28 return 0; 29}  F. Three Paths on a Tree 找出相異三點，使得兩兩之間的路徑聯集起來邊數最多。\n若樹為一直鏈（竹子），則答案為兩端點，和中間任一點。其餘的情況，可以確定答案必有一點落在直徑上，且三點皆為葉子。故先做兩次 BFS 找出直徑，再做樹 DP 得到答案。複雜度 O(n)。\n1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define maxn 200005 4vector\u0026lt;int\u0026gt; v[maxn]; 5bool visit[maxn] = {1,1}; 6typedef pair\u0026lt;int, int\u0026gt; pii; 7int ans = 0; 8int out[3]; 9pii dfs(int u, int dep, int scr) { 10 visit[u] = true; 11 int mx1 = 0, mx2 = 0, a1 = u, a2 = u; 12 for (int uu : v[u]) { 13 if(visit[uu]) continue; 14 pii d = dfs(uu, dep + 1, scr); 15 if (d.first \u0026gt;= mx1) 16 mx2 = mx1, a2 = a1, mx1 = d.first, a1 = d.second; 17 else if (d.first \u0026gt; mx2) 18 mx2 = d.first, a2 = d.second; 19 } 20 if (mx1 + mx2 + dep \u0026gt;= ans) { 21 ans = mx1 + mx2 + dep; 22 out[0] = scr, out[1] = a1, out[2] = a2; 23 } 24 return pii(mx1 + 1, a1); 25} 26int main() { 27 ios::sync_with_stdio(0), cin.tie(0); 28 int n; cin \u0026gt;\u0026gt; n; 29 for (int i = 1; i \u0026lt; n; i++) { 30 int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 31 v[a].push_back(b), v[b].push_back(a); 32 } 33 queue\u0026lt;int\u0026gt; q; 34 int a = 1; 35 q.push(1); 36 while (!q.empty()) { 37 int u = q.front(); q.pop(); 38 a = u; 39 for(int uu : v[u]) 40 if (!visit[uu]) 41 visit[uu] = true, q.push(uu); 42 } 43 int b = a; 44 memset(visit, 0, sizeof(visit)); 45 q.push(a); 46 while(!q.empty()) { 47 int u = q.front(); q.pop(); 48 b = u; 49 for (int uu : v[u]) 50 if (!visit[uu]) 51 visit[uu] = true, q.push(uu); 52 } 53 memset(visit, 0, sizeof(visit)); 54 dfs(a, 0, a); 55 memset(visit, 0, sizeof(visit)); 56 dfs(b, 0, b); 57 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 58 if (out[1] == out[2] || out[0] == out[2]) { 59 for (int i = 1; i \u0026lt;= n; i++) 60 if (i != out[0] \u0026amp;\u0026amp; i != out[1]){ 61 out[2] = i; 62 break; 63 } 64 } 65 for (int i = 0; i \u0026lt; 3; i++) 66 cout \u0026lt;\u0026lt; out[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == 2]; 67 return 0; 68}  ","date":"2020-01-24T11:26:38+08:00","permalink":"https://Luke2336.github.io/p/cf_contest_1294/","title":"Codeforces Round #615 (Div. 3)"},{"content":"此篇是從舊 Blog 搬過來。\nZerojudge a813 - 4. 城市觀測 題目敘述 有 N 棟房子。對於任意 AB 兩棟房子，只要 AB 中間沒有房子的高度超過 A 或 B，則 A 可看見 B。求 1 ~ N 每棟房子可看見的房子總數。\n 測資一，0 \u0026lt; N ≤ 300，0 \u0026lt; H[i] ≤ 1e5，3/17分 測資二，0 \u0026lt; N ≤ 5000，0 \u0026lt; H[i] ≤ 1e5，3/17分 測資三，0 \u0026lt; N ≤ 1e6，0 \u0026lt; H[i] ≤ 1e9，11/17分  範例測資  N = 2，H = {1,1}，ans = 1+1 = 2 N = 3，H = {1,2,3}，ans = 1+2+1 = 4 N = 5，H = {5,2,3,4,4}，ans = 4+2+3+3+2 = 14  參考解法 「A 可看見 B」和「B 可看見 A」等價，因此只要計算一半就好了，也就是可以將問題簡化成，計算每棟房子往左看的sum x 2。\n最直接的做法就是直接 O(N²) 掃過，但第三筆測資顯然需要 O(NlgN) 才有可能 AC。\n因為先寫了 TIOJ 1176 Cows 這題，所以就想到用 stack 去維護遞減性，但因為 stack 無法很計算等號成立的部分，所以 google 了一下，恍然大悟，直接用 array 模擬 stack 解決了，還可以搭配 binary search 達到 O(NlgN) 的時間複雜度。\nTIOJ 那題的複雜度是 O(N)，因為每個元素最多進出 stack 一次，超類似單調隊列！\n為什麼要維護單調性？ 假設我們是由左而右計算，每棟大樓都只能往左看，那只要某數右方有大於它的數，那它就不可能被更右方的數看到。 所以我們就是要維護一個左高右低的梯形/三角形。\n每加入一個數，檢察它左邊的數，如果比他低，就不可能被更後面的數看見，也就可以 pop 掉，之後也不需要檢查。\n而在 stack 裡的數，可以保證單調遞減，也就是中間不會有更高的數，所以只要比你低，一定能被看見，於是 pop 前，將 ans++。\n檢查到一樣高的數時\u0026hellip;\u0026hellip; 麻煩的地方就在這，你不知道在他之前有幾個數和他一樣，但一個一個 pop 再 push 進去實在很浪費時間，例如全部都一樣高的 case，效率會變 O(N²)。於是改成用array來操作，雖然不用 pop 再 push，但查找時一樣是 O(N²)。\n二分搜優化 要徹底解決 O(N²)，還是需要二分搜啦！直接二分搜 stack 最後一個大於等於他的位置就可以加減出答案。\n有單調性的東西就給他二分搜下去吧～\nCode 1#include \u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3typedef long long ll; 4#define maxn 1000005 5int a[maxn], st[maxn]; 6int main() { 7 int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); 8 for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 9 ll ans = 0; 10 int top = 0; 11 for (int i = 1; i \u0026lt;= n; i++) { 12 if (top) { 13 //binary_search 14 int k = 0, left = 1, right = top; 15 while (left \u0026lt;= right) { 16 int mid = (left + right) \u0026gt;\u0026gt; 1; 17 if (st[mid] \u0026gt;= a[i]) 18 k = max(mid, k), left = mid + 1; 19 else right = mid - 1; 20 } 21 ans += top - k; 22 top = k; 23 } 24 if (top) { 25 int k = 0, left = 1, right = top; 26 while (left \u0026lt;= right) { 27 int mid = (left + right) \u0026gt;\u0026gt; 1; 28 if (st[mid] \u0026gt; a[i]) 29 k = max(mid, k), left = mid + 1; 30 else right = mid - 1; 31 } 32 ans += top - k; 33 if (k) ans++; 34 } 35 st[++top] = a[i]; 36 } 37 printf(\u0026#34;%lld\\n\u0026#34;, ans * 2); 38 return 0; 39}  ","date":"2018-08-07T09:52:33+08:00","permalink":"https://Luke2336.github.io/p/zj_a813/","title":"Zerojudge a813 - 城市觀測"},{"content":"UVA 106 - Fermat vs. Pythagoras 題目敘述 輸入 N (1 ≤ N ≤ 1000000)，求X² + Y² = Z²（0 \u0026lt; X \u0026lt; Y \u0026lt; Z ≤ N）的解中\n 三數互質 gcd(X, Y, Z) = 1 的解有幾組 １ ~ Ｎ 中有幾個正整數沒被任何一組解包含  解法 原本想枚舉 Y 和 Z，但時間上會是 10¹¹ 等級，顯然不是一個好方法。\n這時，突然想到了「畢式三元數」(Pythagorean triple)，畢竟每次數學培訓上數論都會講到，前幾天翻數學競賽的書也剛好看到，不過似乎只針對「互質畢式三元數」討論而已。\n 「互質畢式三元數」性質如下：\nX, Y, Z ∈ 𝚴，X² + Y² ＝ Z² 且 gcd(X, Y, Z) = 1，則可表示為\n X = m² - n² Y = 2mn Z = m² + n²  其中 m \u0026gt; n，gcd(m, n) = 1，m, n 為一奇一偶。\n 這題的範圍不僅僅限於 gcd(X, Y, Z) = 1， 但只要將每組「畢式三元數」除以 gcd(X, Y, Z)，就都能變成「互質畢式三元數」了。換句話說，「畢式三元數」一定是由某一組「互質畢式三元數」乘ｋ倍而來。 表示為 X = k (m² - n²)，Y = 2kmn，Z = k (m² + n²)。\n 考慮 m, n 的範圍，1000000 ≥ N ≥ Z ＝ m² + n²，得 1000 ≥ √N ≥ m \u0026gt; n ≥ 1。 枚舉 m, n的時間為 10⁶ 等級，明顯能快很多。\n我的方法是跑一層 for 枚舉 m，裡面再跑一層 for 枚舉 n，if(gcd(m, n) == 1)，則跑一層 k。\n寫完後，丟到 UVA 上排名 21，時間 0.050。 （第一名 0.008，我超好奇怎麼辦到？） 天啊！這真的怪爆了，我到底哪裡比別人快啊？於是 google 了別人的解法。\n看到大部分的人都是對每筆輸入 N 跑一次 for m in range(1,sqrt(N))，這方法我沒想到\u0026hellip;\u0026hellip;因為我寫 DP 寫中毒了，於是動不動就想直接給他一次找完，也就是直接「建表」。\n 這題的數論難關解決後，建表的過程確實有點卡，於是就來記一下重點部分。\n大部分人是直接開個 bool 紀錄數字出現過了沒，還有開個變數紀錄有幾組互質的。\n首先，來談互質的組數 p。用 DP 的角度切入，p[i] 和 p[i-1] 有關嗎？\np[i] = p[i - 1] ＋ (z == i 的互質組數)。 所以就開個 cnt 陣列紀錄，每找到一組互質畢式三元數，cnt[Z]++。p[N]就是cnt[N]的前綴和，O(N)一次做完即可。\n接著，是算有幾個沒用過的數。1 ~ i + 1 會比 1 ~ i 多一個數能用，而 1 ~ i 用過的數 1 ~ i + 1 也同樣被用過。num[i + 1] ＝ num[i] + 1 - (有幾個數在 Z == i + 1 時才出現)。所以重點是計算有幾個數在 Z = i + 1 時第一次出現，也就是紀錄每個數搭配的 Z 的最小值，最後在掃過一遍就行了。\n因為都是由互質三元數去找其他三元數，所以不會找到重複的，所以效率佳。寫這篇時發現自己沒有應用到一奇一偶的性質，改成 n += 2 後，丟到UVA上排名 13，時間 0.040。\nCode 1#include\u0026lt;bits/stdc++.h\u0026gt;2using namespace std; 3#define MAX 1000001 4int f[MAX], num[MAX], p[MAX], ans[MAX] = {0, 1}; 5inline bool coprime(int x, int y, int z) { 6 return __gcd(__gcd(x, y), z) == 1; 7} 8int main() { 9 fill(f, f + MAX, MAX); 10 for (int m = 2; m \u0026lt; 1000; m++) 11 for (int n = (m \u0026amp; 1) + 1; n \u0026lt; m; n += 2) { 12 if (__gcd(m, n) != 1) continue; 13 int x = m * m - n * n, y = 2 * m * n, z = m * m + n * n; 14 if (z \u0026gt;= MAX) break; 15 if (coprime(x, y, z)) { 16 p[z]++; 17 for(int k = MAX / z; k \u0026gt;= 1; k--) { 18 int xx = x * k, yy = y * k, zz = z * k; 19 f[xx] = min(f[xx], zz); 20 f[yy] = min(f[yy], zz); 21 f[zz] = zz; 22 } 23 } 24 } 25 for(int i = 1; i \u0026lt;= MAX; i++) 26 p[i] += p[i - 1], num[f[i]]++; 27 for (int i = 2; i \u0026lt;= MAX; i++) 28 ans[i] = ans[i - 1] + 1 - num[i]; 29 int N; 30 while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;N) == 1) printf(\u0026#34;%d %d\\n\u0026#34;, p[N], ans[N]); 31 return 0; 32}  ","date":"2018-07-04T10:13:53+08:00","permalink":"https://Luke2336.github.io/p/uva_106/","title":"UVA 106 - Fermat vs. Pythagoras"}]