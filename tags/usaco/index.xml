<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>USACO on Luke&#39;s Blog</title>
    <link>https://Luke2336.github.io/tags/usaco/</link>
    <description>Recent content in USACO on Luke&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Feb 2021 11:50:19 +0800</lastBuildDate><atom:link href="https://Luke2336.github.io/tags/usaco/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2021/02/12 日記</title>
      <link>https://Luke2336.github.io/p/20210212/</link>
      <pubDate>Fri, 12 Feb 2021 11:50:19 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20210212/</guid>
      <description>早餐吃了稀飯。 將 Blogger 的幾篇文章搬到這個新的 Blog 上。 將 USACO Section 2.2 完成。 去金山泡溫泉。  金山  去金山鴨肉，發現要戴口罩才能端菜，幸好我有帶一個口罩在身上。 吃了糖葫蘆和冰淇淋，泡了溫泉。 買了 3 張 200 元刮刮樂，刮中 1000 + 1500。 去了水尾漁港看風景，看到有人在停車場放煙火，這大概是這輩子看過最近距離的煙火。走過了觀景橋，到提防散步。  USACO  2.2 Runaround Numbers 2.2 Party Lamps  2.2 Runaround Numbers  題意：給定 M ≤ 2^32，找出一個大於 M 的循環數。循環數的定義為，沒用到 0，且每個位元不重複，從第一個位元 d 開始向右走 d 位，走到最右邊則從最左邊繼續，然後在從此位繼續，走完全部回到第一位且不重複。 解法：DFS 暴搜所有解，不斷更新最小值剪枝。  1/* 2ID: whitech1 3TASK: runround 4LANG: C++14 5*/ 6#include &amp;lt;bits/stdc++.h&amp;gt;7using namespace std; 8typedef long long ll; 9ll m; 10vector&amp;lt;int&amp;gt; v; 11bool used[10]; 12bool check(ll num, int len) { 13 if (num &amp;lt;= m) return false; 14 vector&amp;lt;int&amp;gt; cnt(len); 15 for (int i = 0, r = 0; i &amp;lt; len; i++) { 16 r = (r + v[r]) % len; 17 cnt[r]++; 18 } 19 for (int i = 0; i &amp;lt; len; i++) 20 if (!</description>
    </item>
    
    <item>
      <title>2021/02/11 日記</title>
      <link>https://Luke2336.github.io/p/20210211/</link>
      <pubDate>Thu, 11 Feb 2021 09:57:18 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20210211/</guid>
      <description>過年好痛苦。昨晚做了惡夢，夢到 Alice 跟我絕交，覺得很難過。晚上醒來好幾次。好討厭除夕，跟一群一直刺探隱私的人吃飯。
自己過生日好孤單。
USACO  2.2 Preface Numbering 2.2 Subset Sums  2.2 Preface Numbering  題意：給定 N ≤ 3500，計算 1 ~ N 的羅馬字母表示法共用了每種字母個幾個。  1/* 2ID: whitech1 3TASK: preface 4LANG: C++14 5*/ 6#include &amp;lt;bits/stdc++.h&amp;gt;7using namespace std; 8int d[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; 9string s[13] = {&amp;#34;M&amp;#34;, &amp;#34;CM&amp;#34;, &amp;#34;D&amp;#34;, &amp;#34;CD&amp;#34;, &amp;#34;C&amp;#34;, &amp;#34;XC&amp;#34;, &amp;#34;L&amp;#34;, &amp;#34;XL&amp;#34;, &amp;#34;X&amp;#34;, &amp;#34;IX&amp;#34;, &amp;#34;V&amp;#34;, &amp;#34;IV&amp;#34;, &amp;#34;I&amp;#34;}; 10int cnt[13]; 11void solve(int x) { 12 for (int i = 0; i &amp;lt; 13; i++) { 13 cnt[i] += x / d[i]; 14 x %= d[i]; 15 } 16} 17int main() { 18 freopen(&amp;#34;preface.</description>
    </item>
    
    <item>
      <title>2021/02/10 日記</title>
      <link>https://Luke2336.github.io/p/20210210/</link>
      <pubDate>Wed, 10 Feb 2021 11:36:51 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20210210/</guid>
      <description>今天是 20 歲的最後一天！
晚上吃小火鍋，看到了弟弟的摩托車。
USACO 寫完了 Section 2.1。
 2.1 The Castle 2.1 Ordered Fractions 2.1 Sorting a Three-Valued Sequence 2.1 Healthy Holsteins 2.1 Hamming Codes  2.1 The Castle  &amp;ldquo;Farthest to the west&amp;rdquo; 是指「最西邊」。 題意：給定每個房間的四道牆，問拆一道牆能形成的最大房間大小。 解法：Flood Fill 算出每個房間的大小，再試著拆每道牆。  1/* 2ID: whitech1 3TASK: castle 4LANG: C++14 5*/ 6#include &amp;lt;bits/stdc++.h&amp;gt;7using namespace std; 8const char D[5] = &amp;#34;WNES&amp;#34;; 9const int dx[4] = {0, -1, 0, 1}; 10const int dy[4] = {-1, 0, 1, 0}; 11int main() { 12 freopen(&amp;#34;castle.</description>
    </item>
    
    <item>
      <title>2021/02/09 日記</title>
      <link>https://Luke2336.github.io/p/20210209/</link>
      <pubDate>Tue, 09 Feb 2021 11:30:39 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20210209/</guid>
      <description>今天左下腹還是悶悶的。
USACO  重新開始刷 USACO，USACO 最早是 2018 年就有看到的網站，以前因為是英文題面所以沒認真刷。覺得不能亂刷題，應該有系統的刷題，所以就想寒假把這邊刷到 chapter 3，練基礎能力。 今天刷完 Chapter 1 了～  1.4 Wormholes 1.4 Ski Course Design 1.5 Arithmetic Progressions 1.5 Mother’s Milk 1.6 Number Triangles 1.6 Prime Palindromes 1.6 Superprime Rib    1.4 Wormholes  題意：有 12 個蟲洞，要配對成兩兩一組，一旦碰到蟲洞就會被傳送到另一端，且一直往 +X 方向移動，問有多少種組合能形成環？ 這題是很好的題目，能練習實作暴搜。首先要會 DFS 枚舉組合，方法是每次找到第一個沒被用到的點，然後枚舉能和他匹配的點。之後再檢查每個組合是否有環，採取 BFS，每次走兩步，先一步蟲洞，再走到下一個點。  1/* 2ID: whitech1 3TASK: wormhole 4LANG: C++14 5*/ 6#include &amp;lt;bits/stdc++.h&amp;gt;7using namespace std; 8typedef pair&amp;lt;int, int&amp;gt; pii; 9#define x first 10#define y second 11int n, ans = 0; 12vector&amp;lt;pii&amp;gt; p; 13vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt; G; 14vector&amp;lt;int&amp;gt; pr; 15bool check() { 16 vector&amp;lt;int&amp;gt; visit(n); 17 queue&amp;lt;int&amp;gt; q; 18 for (int i = 0; i &amp;lt; n; i++) q.</description>
    </item>
    
  </channel>
</rss>
