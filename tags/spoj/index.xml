<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SPOJ on Luke&#39;s Blog</title>
    <link>https://Luke2336.github.io/tags/spoj/</link>
    <description>Recent content in SPOJ on Luke&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 Oct 2021 10:39:02 +0800</lastBuildDate><atom:link href="https://Luke2336.github.io/tags/spoj/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2021/10/12 日記</title>
      <link>https://Luke2336.github.io/p/20211012/</link>
      <pubDate>Tue, 12 Oct 2021 10:39:02 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20211012/</guid>
      <description>今天的賽局理論上了 Maximal Independent Set 和 Minimal Multi-dominating Set。 晚上專題的 meeting，拿回了一本平行計算相關的書要讀，覺得這禮拜有點忙。  Code CSES - Josephus Problem I 1#pragma GCC optimization (&amp;#34;O3&amp;#34;) 2#include&amp;lt;bits/stdc++.h&amp;gt;3using namespace std; 4typedef long long ll; 5typedef pair&amp;lt;int, int&amp;gt; pii; 6#define pb push_back 7 8int main() { 9 ios::sync_with_stdio(0), cin.tie(0); 10 int n; 11 cin &amp;gt;&amp;gt; n; 12 if (n == 1) { 13 cout &amp;lt;&amp;lt; &amp;#34;1\n&amp;#34;; 14 return 0; 15 } 16 vector&amp;lt;bool&amp;gt; die(n); 17 cout &amp;lt;&amp;lt; 2; 18 for (int i = 1, p = 0; i &amp;lt; n; i++) { 19 die[p] = true; 20 while(die[p]) { 21 p = (p + 1) % n; 22 } 23 p = (p + 1) % n; 24 while(die[p]) { 25 p = (p + 1) % n; 26 } 27 cout &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; (p + 1) % n + 1; 28 } 29 cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; 30 return 0; 31}  SPOJ - SMPDIV 1#pragma GCC optimization (&amp;#34;O3&amp;#34;) 2#include&amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>2021/10/10 日記</title>
      <link>https://Luke2336.github.io/p/20211010/</link>
      <pubDate>Sun, 10 Oct 2021 09:39:12 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20211010/</guid>
      <description>看了新聞的國慶表演。 下午搭國光回新竹，準備連假最後一天趕一下專題的進度。 回到新竹後洗了衣服。  Code SPOJ - HIGHWAYS 1#include &amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3typedef pair&amp;lt;int, int&amp;gt; pii; 4#define INF 1000000000 5 6void Dijkstra(const vector&amp;lt;vector&amp;lt;pii&amp;gt;&amp;gt; &amp;amp;G, vector&amp;lt;int&amp;gt; &amp;amp;dis, int s) { 7 dis.assign(G.size(), INF); 8 dis[s] = 0; 9 priority_queue&amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt;&amp;gt; pq; 10 pq.emplace(dis[s], s); 11 while (!pq.empty()) { 12 int u = pq.top().second; 13 pq.pop(); 14 for (auto e : G[u]) { 15 if (dis[e.first] &amp;gt; dis[u] + e.second) { 16 dis[e.</description>
    </item>
    
    <item>
      <title>2021/10/03 日記</title>
      <link>https://Luke2336.github.io/p/20211003/</link>
      <pubDate>Sun, 03 Oct 2021 10:43:35 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20211003/</guid>
      <description>早上在寫 code。 下午複習了一點點隨機演算法。 晚上吃了青醬蝦義大利麵。  Code SPOJ - LASTDIG  快速冪。  1#pragma GCC optimization (&amp;#34;O3&amp;#34;) 2#include&amp;lt;bits/stdc++.h&amp;gt;3using namespace std; 4typedef long long ll; 5typedef pair&amp;lt;int, int&amp;gt; pii; 6#define pb push_back 7 8int pow(int a, int b, int mod) { 9 a %= mod; 10 int ans = 1; 11 while (b) { 12 if (b &amp;amp; 1) { 13 ans = ans * a % mod; 14 } 15 b &amp;gt;&amp;gt;= 1; 16 a = a * a % mod; 17 } 18 return ans; 19} 20 21int main() { 22 ios::sync_with_stdio(0), cin.</description>
    </item>
    
    <item>
      <title>2021/10/02 日記</title>
      <link>https://Luke2336.github.io/p/20211002/</link>
      <pubDate>Sat, 02 Oct 2021 13:32:08 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20211002/</guid>
      <description>今天下午和旺陽約好一起去新豐走走。  鳳崎落日登山步道  位於新竹新豐，靠近西濱。 從蓮花寺的入口上山，到觀景平台的咖啡店看夕陽後折返，下山跟著別人的路線走稜線，因此不到半小時就下山了，中途有看到碉堡。 有一些岔路，可能會需要先查好地圖再開始爬。 步道整理的不錯，但有些路段沒有石階，只有原始的石頭和沙地，走起來就會滑。今天全程幾乎都有遮蔭，因此不算太熱，風景也很不錯。 晚餐去了南寮新的市集，但人很多，消費也偏高。  Code SPOJ - MST  找 minimum spanning tree 的 cost。  1#pragma GCC optimization (&amp;#34;O3&amp;#34;) 2#include&amp;lt;bits/stdc++.h&amp;gt;3using namespace std; 4typedef long long ll; 5typedef pair&amp;lt;ll, int&amp;gt; pii; 6#define pb push_back 7#define INF 1000000000000L 8 9ll mst(const vector&amp;lt;vector&amp;lt;pii&amp;gt;&amp;gt; &amp;amp;G, int n) { 10 vector&amp;lt;ll&amp;gt; dis(n, INF); 11 vector&amp;lt;bool&amp;gt; inmst(n); 12 priority_queue&amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt;&amp;gt; pq; 13 dis[0] = 0; 14 pq.emplace(dis[0], 0); 15 ll ret = 0; 16 while (!</description>
    </item>
    
    <item>
      <title>2021/10/01 日記</title>
      <link>https://Luke2336.github.io/p/20211001/</link>
      <pubDate>Fri, 01 Oct 2021 19:59:02 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20211001/</guid>
      <description>午餐吃了 pizza。 午覺後把賽局理論的影片看完。 晚上洗完衣服後，寫了一些 SPOJ 的題目。  Code SPOJ - AAC1  簡單的 BFS 找最短路。  1#pragma GCC optimization (&amp;#34;O3&amp;#34;) 2#include&amp;lt;bits/stdc++.h&amp;gt;3using namespace std; 4typedef long long ll; 5typedef pair&amp;lt;int, int&amp;gt; pii; 6#define pb push_back 7 8int solve(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;G, int src, int dst) { 9 vector&amp;lt;int&amp;gt; dis(G.size(), -1); 10 queue&amp;lt;int&amp;gt; q; 11 q.push(src); 12 dis[src] = 0; 13 while (!q.empty()) { 14 if (dis[dst] != -1) { 15 return dis[dst]; 16 } 17 int u = q.</description>
    </item>
    
    <item>
      <title>2021/07/14 日記</title>
      <link>https://Luke2336.github.io/p/20210714/</link>
      <pubDate>Wed, 14 Jul 2021 17:49:47 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20210714/</guid>
      <description>今天考轉系考，壓力很大。  Code SPOJ - PT07Y 1#include &amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3int main() { 4 int n, m; 5 cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; 6 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; G(n + 1); 7 for (int i = 0; i &amp;lt; m; ++i) { 8 int u, v; 9 cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v; 10 G[u].push_back(v); 11 G[v].push_back(u); 12 } 13 if (m != n - 1) { 14 printf(&amp;#34;NO\n&amp;#34;); 15 } else { 16 vector&amp;lt;bool&amp;gt; visit(n + 1); 17 queue&amp;lt;int&amp;gt; q; 18 q.</description>
    </item>
    
    <item>
      <title>2021/07/13 日記</title>
      <link>https://Luke2336.github.io/p/20210713/</link>
      <pubDate>Tue, 13 Jul 2021 14:27:38 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20210713/</guid>
      <description>今天腦袋都很昏，不太能做事，僅僅開了會。 為隔天下午的上機考刷題，練練手感。  Code SPOJ - SAMER08F 1#include &amp;lt;iostream&amp;gt;2using namespace std; 3int main() { 4 int n; 5 while (cin &amp;gt;&amp;gt; n) { 6 if (!n) break; 7 cout &amp;lt;&amp;lt; n * (n + 1) * (2 * n + 1) / 6 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; 8 } 9 return 0; 10}  SPOJ - ACPC10A 1while True: 2 a, b, c = map(int, input().split()) 3 if a == 0 and b == 0 and c == 0: 4 break 5 if a * c == b * b: 6 print(&amp;#34;GP &amp;#34; + str(c * c // b)) 7 elif a + c == b + b: 8 print(&amp;#34;AP &amp;#34; + str(c + c - b)) SPOJ - AGGRCOW 1#include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>2021/07/12 日記</title>
      <link>https://Luke2336.github.io/p/20210712/</link>
      <pubDate>Mon, 12 Jul 2021 19:49:41 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20210712/</guid>
      <description>早上和 Host 討論過後，壓力有比較小一點，也比較有方向，下午有了些嘗試。 台大通識課感覺還算滿涼的，每週只需要看影片跟寫 600 字作業。第一份作業拿了 92 分，覺得滿開心的。 晚上自己試著寫 ICCAD 的 placement。  Code SPOJ - FCTRL 1for T in range(int(input())): 2 cnt2 = cnt5 = 0 3 n = int(input()) 4 j = 2 5 while j &amp;lt;= n: 6 cnt2 += n // j 7 j *= 2 8 j = 5 9 while j &amp;lt;= n: 10 cnt5 += n // j 11 j *= 5 12 print(min(cnt2, cnt5)) SPOJ - NSTEPS 1for t in range(int(input())): 2 x, y = map(int, input().</description>
    </item>
    
    <item>
      <title>2021/07/09 日記</title>
      <link>https://Luke2336.github.io/p/20210709/</link>
      <pubDate>Fri, 09 Jul 2021 17:16:06 +0800</pubDate>
      
      <guid>https://Luke2336.github.io/p/20210709/</guid>
      <description>花了些時間複習 python。  Code TIOJ 1004. 猶太人敢死隊問題 1n = int(input()) 2L = [True] * n 3i = 0 4last = 0 5while True in L: 6 while not L[i]: 7 i = (i + 1) % n 8 i = (i + 1) % n 9 while not L[i]: 10 i = (i + 1) % n 11 L[i] = False 12 last = i 13 i = (i + 1) % n 14print(last + 1) TIOJ 1005.</description>
    </item>
    
  </channel>
</rss>
