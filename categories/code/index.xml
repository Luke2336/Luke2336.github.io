<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code on Luke&#39;s Blog</title>
    <link>https://luke2336.github.io/categories/code/</link>
    <description>Recent content in Code on Luke&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 30 Jan 2022 20:51:14 +0800</lastBuildDate><atom:link href="https://luke2336.github.io/categories/code/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AtCoder Beginning Contest 237</title>
      <link>https://luke2336.github.io/p/atcoder_abc237/</link>
      <pubDate>Sun, 30 Jan 2022 20:51:14 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/atcoder_abc237/</guid>
      <description>https://atcoder.jp/contests/abc237/tasks。 很早就放棄掙扎的一場。 很久沒打 ABC 了，難度似乎提升很多。  A. Not Overflow 1#pragma GCC optimization (&amp;#34;O3&amp;#34;) 2#include&amp;lt;bits/stdc++.h&amp;gt;3using namespace std; 4typedef long long ll; 5typedef pair&amp;lt;int, int&amp;gt; pii; 6#define pb push_back 7 8int main() { 9 ios::sync_with_stdio(0), cin.tie(0); 10 ll N; 11 cin &amp;gt;&amp;gt; N; 12 ll min = -(1ll &amp;lt;&amp;lt; 31); 13 ll max = (1ll &amp;lt;&amp;lt; 31) - 1; 14 if (min &amp;lt;= N &amp;amp;&amp;amp; N &amp;lt;= max) { 15 cout &amp;lt;&amp;lt; &amp;#34;Yes\n&amp;#34;; 16 } else { 17 cout &amp;lt;&amp;lt; &amp;#34;No\n&amp;#34;; 18 } 19 return 0; 20}  B.</description>
    </item>
    
    <item>
      <title>AtCode Library Practice Contest</title>
      <link>https://luke2336.github.io/p/atcoder-practice2/</link>
      <pubDate>Mon, 20 Sep 2021 10:03:41 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/atcoder-practice2/</guid>
      <description>A - Disjoint Set Union 1#pragma GCC optimization (&amp;#34;O3&amp;#34;) 2#include&amp;lt;bits/stdc++.h&amp;gt;3using namespace std; 4typedef long long ll; 5typedef pair&amp;lt;int, int&amp;gt; pii; 6#define pb push_back 7 8class UnionTree { 9private: 10 vector&amp;lt;int&amp;gt; par, sz; 11public: 12 UnionTree(int n) { 13 par.resize(n); 14 for (int i = 0; i &amp;lt; n; i++) { 15 par[i] = i; 16 } 17 sz.resize(n, 1); 18 } 19 int findPar(int x) { 20 return par[x] = (x == par[x] ?</description>
    </item>
    
    <item>
      <title>AtCoder Beginning Contest 216</title>
      <link>https://luke2336.github.io/p/atcoder_abc216/</link>
      <pubDate>Sun, 29 Aug 2021 21:51:11 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/atcoder_abc216/</guid>
      <description>AtCoder Beginning Contest 192 A. Signed Difficulty 1#pragma GCC optimization(&amp;#34;O3&amp;#34;) 2#include &amp;lt;bits/stdc++.h&amp;gt;3using namespace std; 4typedef long long ll; 5typedef pair&amp;lt;int, int&amp;gt; pii; 6#define pb push_back 7int main() 8{ 9 ios::sync_with_stdio(0), cin.tie(0); 10 int X, Y; 11 char c; 12 cin &amp;gt;&amp;gt; X &amp;gt;&amp;gt; c &amp;gt;&amp;gt; Y; 13 if (Y &amp;lt;= 2) 14 cout &amp;lt;&amp;lt; X &amp;lt;&amp;lt; &amp;#34;-\n&amp;#34;; 15 else if (Y &amp;lt;= 6) 16 cout &amp;lt;&amp;lt; X &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; 17 else 18 cout &amp;lt;&amp;lt; X &amp;lt;&amp;lt; &amp;#34;+\n&amp;#34;; 19 return 0; 20}  B.</description>
    </item>
    
    <item>
      <title>AtCoder Beginning Contest 192</title>
      <link>https://luke2336.github.io/p/atcoder_abc192/</link>
      <pubDate>Sat, 20 Feb 2021 21:11:32 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/atcoder_abc192/</guid>
      <description>AtCoder Beginning Contest 192 pD 被卡了很久，pF 沒靈感，只好掉分。
A. Star $$O(1)$$
1#pragma GCC optimization (&amp;#34;O3&amp;#34;) 2#include&amp;lt;bits/stdc++.h&amp;gt;3using namespace std; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 int x; cin &amp;gt;&amp;gt; x; 7 cout &amp;lt;&amp;lt; 100 - x % 100 &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; 8 return 0; 9}  B. uNrEaDaBlE sTrInG $$O(|S|)$$
1#pragma GCC optimization (&amp;#34;O3&amp;#34;) 2#include&amp;lt;bits/stdc++.h&amp;gt;3using namespace std; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 string s; 7 cin &amp;gt;&amp;gt; s; 8 int len = s.</description>
    </item>
    
    <item>
      <title>Hello, Kotlin!</title>
      <link>https://luke2336.github.io/p/hello_kotlin/</link>
      <pubDate>Sun, 14 Feb 2021 17:14:36 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/hello_kotlin/</guid>
      <description>Learn Kotlin by Example (kotlinlang.org)  Output println() 1fun main() { 2 println(&amp;#34;Hello, World!&amp;#34;) 3} Function fun 1fun sum(x: Int, y: Int): Int { 2 return x + y 3} 4 5// Single-Expression 6fun mul(x: Int, y: Int) = x * y 7 8// Default Arguments 9fun printMSG (msg1: String = &amp;#34;Hello&amp;#34;, msg2: String) { 10 println(&amp;#34;$msg1, $msg2!&amp;#34;) 11} 12 13fun main() { 14 println(sum(1, 2)) 15 println(mul(2, 5)) 16 printMSG(&amp;#34;Hi&amp;#34;, &amp;#34;Jack&amp;#34;) 17 printMSG(msg2 = &amp;#34;Kelly&amp;#34;) 18} vararg 1fun sum(vararg a: Int): Int { 2 var ret = 0 3 for (x in a) ret = ret + x 4 return ret 5} 6 7fun main() { 8 println(sum(1, 0, -1, 2)) 9} Variable val var  val 一定要初始化  1fun main() { 2 val v = 1 // immutalbe 3 var x: Int // mutable 4 x = 1 5 println(x + v) 6} null  用 ?</description>
    </item>
    
    <item>
      <title>TIOJ 1214 樹同構</title>
      <link>https://luke2336.github.io/p/tioj1214/</link>
      <pubDate>Mon, 08 Feb 2021 20:36:05 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/tioj1214/</guid>
      <description>ICPC 2020 Taipei 出了一題水母圖的同構，於是今天找了這題樹同構練習，採用括號字串的方法，而不是 Hashing。
 水母圖  對於環上每個點當 root 去生出樹字串。 串接起來後，用環狀字串的演算法去比較。    TIOJ 1214 - 樹論 之 樹同構測試 $$O(|G|^2 \log \Delta(G)) = O(n^2 \log n)$$
 n ≤ 100。給定兩棵樹的邊，問他們是否同構 &amp;ldquo;isomorphic&amp;rdquo; 先 DFS 找出所有的樹重心（最多 2 個）。樹重心的定義為，最大子樹大小最小的點。 從重心開始做 DFS，將每個點用 () 表示，中間夾括入他所有子樹字串，將他們排序後加入。每次排序為度數個，所以總共需要排序 deg - 1 個，所有點加起來為 n 個，再乘上字串比較的複雜度 O(n)。 最後再將重心們的字串排序後串接，比較兩棵樹是否相同。  1#pragma GCC optimization (&amp;#34;O3&amp;#34;) 2#include&amp;lt;bits/stdc++.h&amp;gt;3using namespace std; 4#define pb push_back 5int n; 6int dfs(int u, int p, int &amp;amp;mi, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;G, vector&amp;lt;int&amp;gt; &amp;amp;ret) { 7 int cnt = 0, mx = 0; 8 for (int uu : G[u]) { 9 if (uu == p) continue; 10 int r = dfs(uu, u, mi, G, ret); 11 mx = max(mx, r), cnt += r; 12 } 13 mx = max(mx, n - cnt - 1); 14 if (mx &amp;lt;= mi) { 15 if (mx &amp;lt; mi) ret.</description>
    </item>
    
    <item>
      <title>MacOS Command Line Note</title>
      <link>https://luke2336.github.io/p/mac_cmd/</link>
      <pubDate>Sun, 07 Feb 2021 14:08:22 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/mac_cmd/</guid>
      <description>常用指令    command 用途     clear clear terminal window   ls list directory content   ls -a 將隱藏檔案也列出   cd change directory to home   cd .. change directory to parent   cd - change directory to last working directory   cd / change directory to root   pwd print working directory   rm file_name remove file   mkdir dir_name make directory   rmdir dir_name remove directory   rm -R dir_name remove the directory and all files in the directory   cp -R A B 將 A 資料夾的東西全部複製到 B   mv A dir_name 將 A 搬到資料夾   cat file_name 查看內容   grep text file_name 抓取內容    </description>
    </item>
    
    <item>
      <title>Longest Common Increasing Subsequence(LCIS)</title>
      <link>https://luke2336.github.io/p/lcis/</link>
      <pubDate>Fri, 29 Jan 2021 12:05:24 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/lcis/</guid>
      <description>Codeforces 10 D. LCIS dp[i][j] 為 a[1&amp;hellip;i], b[1&amp;hellip;j] 結尾為 b[j] 的 LCIS 的長度。
$$dp_{i, j} := \begin{cases} \max_{p &amp;lt; j, b_{p} &amp;lt; b_{j}} dp_{i - 1, p} + 1 &amp;amp;, a_{i} = b_{j} \\ dp_{i - 1, j} &amp;amp;, \text{otherwise}. \end{cases}$$
複雜度：O(nm)，n, m 為兩序列長度。
1#pragma GCC optimization (&amp;#34;O3&amp;#34;) 2#include&amp;lt;bits/stdc++.h&amp;gt;3using namespace std; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 // INPUT 7 int L[2]; 8 vector&amp;lt;int&amp;gt; v[2]; 9 for (int i = 0; i &amp;lt; 2; i++) { 10 cin &amp;gt;&amp;gt; L[i]; 11 v[i].</description>
    </item>
    
    <item>
      <title>AtCoder Beginners Selection</title>
      <link>https://luke2336.github.io/p/atcoder_abs/</link>
      <pubDate>Tue, 19 Jan 2021 17:00:49 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/atcoder_abs/</guid>
      <description>AtCoder Beginners Selection 用 AtCoder 的水題來練習 Kotlin 的基礎語法。
PracticeA - Welcome to AtCoder 1private fun readLn() = readLine()!! 2private fun readInt() = readLn().toInt() 3private fun readStrings() = readLn().split(&amp;#34; &amp;#34;) 4private fun readInts() = readStrings().map { it.toInt() } 5 6fun main() { 7 val a = readInt() 8 val(b, c) = readInts() 9 val s = readLn() 10 println(&amp;#34;${a + b + c}$s&amp;#34;) 11} ABC086A - Product 1private fun readLn() = readLine()!</description>
    </item>
    
    <item>
      <title>AtCoder Regular Contest 111</title>
      <link>https://luke2336.github.io/p/atcoder_arc111/</link>
      <pubDate>Sat, 09 Jan 2021 22:03:11 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/atcoder_arc111/</guid>
      <description>因為 pA 卡住，所以慘慘的 QAQ
掉了 31 分到 1685。
AtCoder Regular Contest 111 A. Simple Math 2 題意 $$1 \leq n \leq 10^{18}, 1 \leq m \leq 10^4, \text{find }\lfloor \frac{10^n}{m}\rfloor \mod m.$$
解法  求 (10 ** n) % (m * m) // m。 紀錄餘數的循環節。 卡題原因：  忘記循環不一定從一開始。 用了 unordered_map 判斷餘數是否出現過導致 TLE，換成 array 就變很快了。    Code 1#include&amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3typedef long long ll; 4#define pb push_back 5int s[100000008]; 6int main() { 7 ll n, m, mm; 8 cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; 9 mm = m * m; 10 ll r, d = 1; 11 vector&amp;lt;int&amp;gt; v; // 紀錄餘數 12 for (int i = 0; i &amp;lt;= n; i++) { 13 r = d % mm; 14 if (s[r] || (i &amp;amp;&amp;amp; r == v[0])) break; 15 s[r] = i; 16 v.</description>
    </item>
    
    <item>
      <title>AtCoder Educational DP Contest</title>
      <link>https://luke2336.github.io/p/atcoder_education_dp/</link>
      <pubDate>Mon, 04 Jan 2021 11:59:31 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/atcoder_education_dp/</guid>
      <description>AtCoder Educational DP Contest  [於 Feb, 2020 完成]
這套從簡到難的 DP 題組，有不少經典題，很適合照順序刷。 開始刷了之後，才發現自己實力的不足，有幾題想了很久還是想不出來，只好去翻別人的解答。刷完發現 code 都不長，狀態也不難列，但轉移式都要想很久。
 A. Frog 1 1#include&amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3int main() { 4 int N; scanf(&amp;#34;%d&amp;#34;, &amp;amp;N); 5 int dp[2] = {}, a[2] = {}; 6 scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;a[1], &amp;amp;a[0]); 7 dp[0] = abs(a[1] - a[0]); 8 for (int i = 3; i &amp;lt;= N; i++) { 9 int x; scanf(&amp;#34;%d&amp;#34;,&amp;amp;x); 10 dp[i % 2] = min(dp[i % 2] + abs(x - a[i % 2]), 11 dp[(i + 1) % 2] + abs(x - a[(i + 1) % 2])); 12 a[i % 2] = x; 13 } 14 printf(&amp;#34;%d\n&amp;#34;, dp[N % 2]); 15 return 0; 16}  B.</description>
    </item>
    
    <item>
      <title>AtCoder Beginning Contest 186</title>
      <link>https://luke2336.github.io/p/atcoder_abc186/</link>
      <pubDate>Sat, 19 Dec 2020 22:03:36 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/atcoder_abc186/</guid>
      <description>AtCoder Beginning Contest 186 pE 讓我卡了一下，於是就掉分了。pF 想到了一個假解，浪費了不少時間。可能是因為剛打完 CF，所以狀態不好。
A. Brick 1#include&amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3int main() { 4 int n, w; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; w; 5 cout &amp;lt;&amp;lt; n / w &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; 6 return 0; 7}  B. Blocks on Grid 1#include&amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3int main() { 4 ios_base::sync_with_stdio(0); cin.tie(0); 5 int h, w; cin &amp;gt;&amp;gt; h &amp;gt;&amp;gt; w; 6 int sum = 0, m = 105; 7 for (int i = 0; i &amp;lt; h; i++) { 8 for (int j = 0; j &amp;lt; w; j++) { 9 int x; cin &amp;gt;&amp;gt; x; 10 sum += x; 11 m = min(m, x); 12 } 13 } 14 cout &amp;lt;&amp;lt; sum - m * h * w &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; 15 return 0; 16}  C.</description>
    </item>
    
    <item>
      <title>Codeforces Round 691 Div. 2</title>
      <link>https://luke2336.github.io/p/cf_contest_1459/</link>
      <pubDate>Sat, 19 Dec 2020 19:07:58 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/cf_contest_1459/</guid>
      <description>Codeforces Round #691 (Div. 2) 因為 pC 找不到 bug，就一直亂丟，於是打得超爛。Rating 加了 43 到 1695。
pA. Red-Blue Shuffle 1#include&amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3typedef long long ll; 4typedef pair&amp;lt;int, int&amp;gt; pii; 5#define pb push_back 6int main() { 7 ios_base::sync_with_stdio(0); cin.tie(0); 8 int T; cin &amp;gt;&amp;gt; T; 9 while (T--) { 10 int n; cin &amp;gt;&amp;gt; n; 11 string R, B; 12 cin &amp;gt;&amp;gt; R &amp;gt;&amp;gt; B; 13 int r = 0, b = 0; 14 for (int i = 0; i &amp;lt; n; i++) 15 if (R[i] &amp;gt; B[i]) r++; 16 else if (R[i] &amp;lt; B[i]) b++; 17 if (r &amp;gt; b) cout &amp;lt;&amp;lt; &amp;#34;RED\n&amp;#34;; 18 else if (r &amp;lt; b) cout &amp;lt;&amp;lt; &amp;#34;BLUE\n&amp;#34;; 19 else cout &amp;lt;&amp;lt; &amp;#34;EQUAL\n&amp;#34;; 20 } 21 return 0; 22}  pB.</description>
    </item>
    
    <item>
      <title>有向圖找負環 (Negative-Cycle)</title>
      <link>https://luke2336.github.io/p/negative_cycle/</link>
      <pubDate>Sat, 05 Dec 2020 22:36:18 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/negative_cycle/</guid>
      <description>CSES - 1197 - Cycle Finding  卡車說可以從一個假點開始做 SSSP，也就是將所有點的距離都先設成 0。 我的寫法複雜度看起來不好，感覺假解了，但想不到該怎麼改，可能會 TLE。 想了一個確定複雜度是 O(VE) 的解，將整張圖做 SCC，形成一個 DAG，從每個 in-degree 為 0 的 SCC 選一個點做 DFS。  1#include&amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3typedef long long ll; 4typedef pair&amp;lt;int, ll&amp;gt; pii; 5#define pb push_back 6vector&amp;lt;int&amp;gt; ans; 7vector&amp;lt;vector&amp;lt;pii&amp;gt;&amp;gt; G; 8vector&amp;lt;bool&amp;gt; visit; 9vector&amp;lt;bool&amp;gt; use; 10vector&amp;lt;ll&amp;gt; dis; 11int dfs(int v) { 12 use[v] = visit[v] = true, ans.pb(v); 13 for (pii e : G[v]) { 14 int u = e.</description>
    </item>
    
    <item>
      <title>CF GYM 100274</title>
      <link>https://luke2336.github.io/p/cf_gym_100274/</link>
      <pubDate>Thu, 03 Dec 2020 23:56:03 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/cf_gym_100274/</guid>
      <description>CF-GYM100274 pA  問題：2 &amp;lt;= n &amp;lt;= 1e18，2 &amp;lt;= k &amp;lt;= 1e12，求 n! 是 k 的幾次方。 作法：將 k 做質因數分解，然後各自算出次方數後，再取最小值。 時間：$$O(\log n \sqrt k)$$  1#include&amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3typedef long long ll; 4typedef pair&amp;lt;ll, int&amp;gt; pli; 5vector&amp;lt;pli&amp;gt; prime_factor (ll k) { 6 vector&amp;lt;pli&amp;gt; ret; 7 for (ll i = 2; i * i &amp;lt;= k; i++) { 8 if (k % i) continue; 9 pli p = pli(i, 0); 10 while (k % i == 0) k /= i, p.</description>
    </item>
    
    <item>
      <title>Codeforces Round #615 (Div. 3)</title>
      <link>https://luke2336.github.io/p/cf_contest_1294/</link>
      <pubDate>Fri, 24 Jan 2020 11:26:38 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/cf_contest_1294/</guid>
      <description>Codeforces Round #615 (Div. 3) 第一次 CF 賽中破台，排名 +178，總算 1700 了。 pD 稍微想了一下子，pE 實作上卡了很久，有些邊界問題沒考慮清楚。pF 想了一下子才發現很好寫，但忘了考慮一直鏈的情況，所以 WA 了一次。
A. Collecting Coins 1#include&amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3typedef long long LL; 4int main() { 5 ios::sync_with_stdio(0), cin.tie(0); 6 int t; cin &amp;gt;&amp;gt; t; 7 while (t--) { 8 LL a, b, c, n; 9 cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c &amp;gt;&amp;gt; n; 10 LL sum = n + a + b + c; 11 if (sum % 3) { 12 cout &amp;lt;&amp;lt; &amp;#34;NO\n&amp;#34;; 13 continue; 14 } 15 sum /= 3; 16 if (sum &amp;lt; a || sum &amp;lt; b || sum &amp;lt; c) { 17 cout &amp;lt;&amp;lt; &amp;#34;NO\n&amp;#34;; 18 continue; 19 } 20 cout &amp;lt;&amp;lt; &amp;#34;YES\n&amp;#34;; 21 } 22 return 0; 23}  B.</description>
    </item>
    
    <item>
      <title>2019 ICPC Yokohama Regional</title>
      <link>https://luke2336.github.io/p/icpc-yokohama/</link>
      <pubDate>Sun, 12 Jan 2020 16:13:01 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/icpc-yokohama/</guid>
      <description>這篇是遊記＋比賽紀錄，所以就寫得很零碎了。 本來就很想寫這篇，但一直拖到寒假才有空～～
為什麼去日本呢？ 因為去日本高機率會被電爆，假如要去確實不應該在我們想拿票時去。外國隊名額有限，交大只能派一隊，但剛好沒人要跟我們搶。
我亂分析了一下，日本是實作、數學、幾何題比較多，我們隊有實作大師，似乎還行。日本似乎沒有東南亞那麼多模板題，對我們這種剛開始打的菜鳥似乎比較沒那麼虧。
日本雖然沒有官方旅遊行程，但自己玩也很棒，雖然物價有點高。
行前 暑假一知道可以出國就去辦了台北辦護照，順便回北一女逛了一下。
出國前三天去旅行社弄了 48hr 的東京地鐵券。
因為懶得排行程，排行程似乎變因過多，我們決定第四天自由行，第五天去淺草逛逛。
因為我們原本想住的旅館看起來很不恰當，於是被教練說服比賽期間都跟他住商務旅館（鶴見東橫Inn）。
日本賽制是不限參考資料頁數，但我們還是決定帶彩色的 25 頁 codebook 和一本字典。
賽前有練習或討論了超過 5 年的考古。
DAY1 因為怕打太爛，比賽前不敢排旅遊行程，於是搭 18:25(+8)-22:05(+9) 的飛機。
跟教練搭計程車，所以提早了不少到機場，但因為我不到20歲，搞保險搞了好久。然後就是人生第一次搭飛機了，幸好我不是一個人出國。
我們在機場還很認真的研究考古題，上飛機後就開始研究飛機餐了，隊友超愛吃奶油。
下飛機後，領完行李後，我花了三分鐘弄了張免費網卡，詳請請參考這篇，結果最後只用了 100/500MB。
然後就搭京急去旅館睡覺了，氣溫雖然不到 15 度，但因為濕度很低，所以感覺不冷，隊友直接只穿一件 T-shirt＋超薄外套。
DAY2（測機日） 本來這天下午應該要在台灣考演算法概論上機考，有兩個選項，一個是期末算兩倍，另一個是在日本考。我們選擇在日本的 7:00-11:00 考，當作練手感。毫無意外地，小爆炸了一下。
中午在橫濱市區吃 KFC，日本的 KFC 超好吃的！
然後準時的抵達賽場，教練似乎跟日本人很熟，我們報到完他就去外交了。台大 wa&amp;hellip;123 坐在我們背後兩組，他們NPSC坐在我們左邊，真是有緣啊！
他們的系統教學示範超生動的，讓我們好想再去日本比一次。
桌子的佈局是兩張長桌，放成L型。
然後就是測機了，全部都是考古題，有幾題上飛機前看過。有一題是暴力枚舉，但我隊友不會寫遞迴枚舉，於是我只好去摸鍵盤了（鍵盤手感不錯）。
之後是自我介紹時間，事前會叫你交一頁投影片，另外還會給一本印有各隊介紹的本本，很多好玩的ascii圖。清大比我們早了幾天到日本，他們先去寶可夢樂園血拼，於是就全套寶可夢上去介紹。
牆上有先放隔天的氣球，於是知道總共有11題。有提供點心區和餐盒，於是我很認真的研究了隔天要吃什麼點心。（我們是離點心最近的位置）
晚上，教練請我們吃燒肉，牛橫膈超好吃的！然後去車站逛了超市。
DAY3（比賽日） 我雷我抱歉，我鬧鐘又設到晚上了，幸好教練發現我沒出現，就直接 morning call，不然就慘了。然後匆匆忙忙的吃了早餐，隊友也一副沒睡飽的樣子。
我們即時抵達賽場，教練忙台北站忙到快掛了，就先回去旅館休息。進去後，桌面佈局維持我們前一天調好的樣子。
比賽提早了五分鐘開始，主席倒數的好嗨好可愛。
開場就按照策略先把該抄的東西抄好，雖然他們本身很貼心的有提供一些快速編譯的指令。
然後因為日本有確定 pApB 一定是最水的，於是我們 pB 在 00:23 先AC，pA 有點卡，於是 00:32 才 AC。
然後 pH 是括號匹配，搭上刪除操作，因為我們把他想成可以用 map 或線段樹之類的弄，想的有點複雜，但感覺做得掉，就交給學弟先寫。</description>
    </item>
    
    <item>
      <title>交大 2019 年度賽</title>
      <link>https://luke2336.github.io/p/nctu_annual_contest_2019/</link>
      <pubDate>Wed, 04 Sep 2019 11:13:48 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/nctu_annual_contest_2019/</guid>
      <description>NCTU_Pusheen的第一場ICPC賽制比賽。 （角色：我、隊友H、隊友U） 好像有點太早到了，9:30開始，我們8:05就全到了。 然後就開始討論選課的事，還有推廣了「貼圖大戰」。 似乎三個人還是有點緊張，隊友U算是最淡定的一個，於是就讓他坐電腦前了。只有九隊而已，真的很怕墊底。（明明前一天的新生賽才拿第一，但就是莫名沒自信QQ）
解題 M很水，於是隊友H就用接近首殺的速度把M殺了。然後我發現K很水，然後就讓隊友U把他殺了，然後過程中順便想出了K的構造題 Ｉ，原本差點就傳了，但剛好發現範圍到10^32，於是改用python寫掉，於是K和Ｉ都拿到首殺，這時大致過了半小時。
然後，我發現F似乎是簡單的DP建表，於是就丟給隊友U寫。 因為G明顯是我不擅長的幾何題，於是丟給隊友H，隊友H就想出了一個假解，因為我懶得驗證正確性，也不覺得有其他簡單的作法，於是就丟上去讓他WA了。
E是一題矩陣題，賽中我覺得高斯消去能解，但隊友U阻止了我，提醒我高斯做出來不一定是整數。賽後這題似乎是能用高斯加一些處理弄過。
因為ABC的題序一樣，然後都沒靈感，於是就先擺著。J看得出來是DP，但以為沒這麼簡單，就擺一邊了，事後證明是個錯誤決定。
此時沒有人解出其他題目，於是就決定去開D和L。
D一開始以為是Dijkstra，後來WA了之後，證出等號成立時轉移會出事，於是我就想出了一個二分搜解，但因為複雜度卡卡的，於是繼續在Dijkstra上繞圈圈。然後在最後三十分鐘，隊友U想出了一個具體的二分搜＋BFS作法，但因為搜的東西不對，無法剪枝，於是常數太大，吃了TLE。
L大概是解出來最爽的一題，花了超過一小時。隊友H先推出大致的規律，然後我用了類似前綴和的東西，把空間和時間壓到lgN，然後交給隊友H和U寫。但賽後證實我們賽中想過本機跑分塊的作法也能喇過。
A後來有兩隊解出來，於是也稍微想了一下，猜是要建圖，但真的想不出來。
嗯，看到最後會發現我好像沒碰過鍵盤呢！！
L的題解 題目是將L到R(0~1e9)的二進位字串接起來，然後求這個字串的1和0共有幾段。例如1~5，表示成11011100101，答案為7。
隨手寫了一篇題解：2019交大年度賽pL非官方題解</description>
    </item>
    
    <item>
      <title>Zerojudge a813 - 城市觀測</title>
      <link>https://luke2336.github.io/p/zj_a813/</link>
      <pubDate>Tue, 07 Aug 2018 09:52:33 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/zj_a813/</guid>
      <description>此篇是從舊 Blog 搬過來。
Zerojudge a813 - 4. 城市觀測 題目敘述 有 N 棟房子。對於任意 AB 兩棟房子，只要 AB 中間沒有房子的高度超過 A 或 B，則 A 可看見 B。求 1 ~ N 每棟房子可看見的房子總數。
 測資一，0 &amp;lt; N ≤ 300，0 &amp;lt; H[i] ≤ 1e5，3/17分 測資二，0 &amp;lt; N ≤ 5000，0 &amp;lt; H[i] ≤ 1e5，3/17分 測資三，0 &amp;lt; N ≤ 1e6，0 &amp;lt; H[i] ≤ 1e9，11/17分  範例測資  N = 2，H = {1,1}，ans = 1+1 = 2 N = 3，H = {1,2,3}，ans = 1+2+1 = 4 N = 5，H = {5,2,3,4,4}，ans = 4+2+3+3+2 = 14  參考解法 「A 可看見 B」和「B 可看見 A」等價，因此只要計算一半就好了，也就是可以將問題簡化成，計算每棟房子往左看的sum x 2。</description>
    </item>
    
    <item>
      <title>UVA 106 - Fermat vs. Pythagoras</title>
      <link>https://luke2336.github.io/p/uva_106/</link>
      <pubDate>Wed, 04 Jul 2018 10:13:53 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/uva_106/</guid>
      <description>UVA 106 - Fermat vs. Pythagoras 題目敘述 輸入 N (1 ≤ N ≤ 1000000)，求X² + Y² = Z²（0 &amp;lt; X &amp;lt; Y &amp;lt; Z ≤ N）的解中
 三數互質 gcd(X, Y, Z) = 1 的解有幾組 １ ~ Ｎ 中有幾個正整數沒被任何一組解包含  解法 原本想枚舉 Y 和 Z，但時間上會是 10¹¹ 等級，顯然不是一個好方法。
這時，突然想到了「畢式三元數」(Pythagorean triple)，畢竟每次數學培訓上數論都會講到，前幾天翻數學競賽的書也剛好看到，不過似乎只針對「互質畢式三元數」討論而已。
 「互質畢式三元數」性質如下：
X, Y, Z ∈ 𝚴，X² + Y² ＝ Z² 且 gcd(X, Y, Z) = 1，則可表示為
 X = m² - n² Y = 2mn Z = m² + n²  其中 m &amp;gt; n，gcd(m, n) = 1，m, n 為一奇一偶。</description>
    </item>
    
    <item>
      <title>2018 資訊之芽 算法班 心得</title>
      <link>https://luke2336.github.io/p/sprout-2018/</link>
      <pubDate>Mon, 02 Jul 2018 11:33:59 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/sprout-2018/</guid>
      <description>為什麼會去資芽？ 會知道這個好活動真心感謝學校的老師和學姊宣傳XD
第一次參加台大的資芽是在高一下時，那時是參加 python 語法班，原本也有想報名算法班，但是報名門檻有要寫題目，我好像離門檻還差半題的分數。但說真的，語法班的二階就已經讓忙碌的小高一吃不消了&amp;hellip;&amp;hellip;
高二沒去資芽則是因為入芽考的時間剛好撞到社團寒訓。
高三想說學測考得沒有很糟糕，六日也沒什麼事，就把握最後的機會報名了。
資芽的內容 建議直接去 google 課程網比較清楚。
課程形式 先在家看影片預習（1 ~ 1.5 hr），上課時討論及補充細節及更深的技巧，回家寫手寫作業（1 ~ 2 hr）和上機作業（3 ~ 5 題 + 1 ~ 2 題加分題，2 ~ 3 hr）。總之，每週在家至少要花4小時，但花到8小時也不是不可能。
課程內容 大致上分成兩階段，第一階段其實不算太困難，有基本的資料結構（stack、queue、linked list、heap）、複雜度、圖論（tree、DFS、BFS）、Greedy、Binary search、Divide &amp;amp; Conquer、DP。 第二階段，每年的內容都不太一樣，固定會有的主題是 DP，其他主題有線段樹、字串匹配（KMP、Trie、Hash、Z-value&amp;hellip;&amp;hellip;）、shortest path。大部分都是我有聽過但不太敢碰的主題，但既然都花時間來了，就硬著頭皮學吧！反正總有一天要面對。個人是認為難度真的比一階難很多（其實一階結束就已經有 1/3 的人退了）。
手寫作業 我覺得內容很廣泛，但大多是課程相關和一些常用到的知識，例如 hash、disjoint-set、NP-complete，有很大一部分都是證明題，需要一些數學或是強大的構造靈感，我到後面好像有點混，都在亂寫，一階時也是靠平安的幫忙。
上機作業 每週 3 ~ 5 題，另外還有 1 ~ 2 題的加分題。有一半會是講過的範例，但還是有點難度。不會寫就去用FB私訊講師，他們人都不錯，而且提示都給得剛剛好，不會破壞你想題目的機會。
課堂討論 這是我最喜歡資芽的原因，討論的過程可以讓你練習把自己的想法講得讓別人聽得懂，過程中和別人互相確認想法發現彼此的 bug，確認自己有真的聽懂，也能聽到很多不錯的想法。但我覺得大家好像都不太會主動找不熟的人討論，算是美中不足之處。
兩次認證考 都是 3 小時 5 題，我覺得和上課教的東西相關性高但難度卻很高，建議盡量多拿部份分，我自己是兩次都拿不到 100 分（滿分500），但我認為拿 250 分左右是有機會的。
歡樂團體賽 三個人一組，我跟裘莉和哆啦一組。7 題裡面，我們寫了 5 題。題目跟課程內容不太相關，我覺得裘莉很可憐，丟給他的題目都是不太好寫的題目。哆啦更可憐，她寫出來卻一直無法 AC，因為測試的程式出包&amp;hellip;&amp;hellip;我算是有貢獻吧，雖然其中一題其實是矇到，整個是錯的剛好沒被卡掉。歡樂的點可能是我們拿第二名吧！</description>
    </item>
    
    <item>
      <title>TOI 2018 選訓營一階 心得</title>
      <link>https://luke2336.github.io/p/toi-2018/</link>
      <pubDate>Fri, 22 Jun 2018 11:17:06 +0800</pubDate>
      
      <guid>https://luke2336.github.io/p/toi-2018/</guid>
      <description>寫這篇文其實是害怕自己某天忘了這段日子的美好回憶，那時很認真的每天寫日記，不過因為太累了，所以好像漏記了不少，就順便補上吧！
DAY 1 四點半在師大本部報到，應該是前十個到的，發現自己看起來超與眾不同。
穿著北一體育服：對！我很乖，請了公假還一早拖著行李箱上學，三點半才離開學校。南部來的早上翹課挺合理，但建中生表示他們已經請了好幾週公假了！！
唯二的女生：我比較早到，所以剛開始就放下行李，去認識一群聊得挺嗨的男生。 Yunn 到的時候，互相打量了好一會，於是我決定主動去認識她，這選擇真的太對了，她其實不太怕生 XD
沒帶大鍵盤：哇！大家除了筆電外都帶著大鍵盤耶！其實我入營考測機時就被某人的鍵盤聲弄到快崩潰，所以看到一堆鍵盤真的好可怕！！
行李箱好迷你：我有第二小的行李箱，除了某遲到的人只背著書包外？
報到完，就去吃飯了～我和Yunn選了一個大桌坐。男生似乎都想離我們遠遠的，但訂的位子有限，晚來的只好跟我們坐囉！等餐等超久的，於是我這個傻瓜就開始想認識別人了，印象中，同桌的有復旦、南一中、延平*２，我對他們的評價是一群不喜歡說話的人&amp;hellip;&amp;hellip;一吃飽他們就急著問輔導員可不可以先回房間。隔壁桌則比較歡樂，開心的打程式，應該是老朋友了！
回房間後，我猜我是最早睡的，九點多就先睡了～（Yunn 認真讀化學）
DAY 2 習慣性的早起，好像不到五點半吧！！
睡不著就開始打理自己，想說寫個幾題熱身，於是就抱著書和筆電出去了！這時已經開始過敏，一定是因為被窩不夠暖 QQ不知為何我居然在寫 TIOJ！逆序數對怎麼樣都寫不出來（之後資芽有這題，原來要分治！）
七點四十搭專車到分部，享用了早餐，每天都是三明治和漢堡交替，星期日吃飯糰，Yunn 真的超討厭早餐店的茶，於是之後晚點名的鋁箔包成了她的救星。
這天的課表是「Graph basics」，早上是 flow，下午上 matching，我一整天都在流鼻水，雖然大致聽得懂，但實作上我真的有點障礙，心情一整個blue。
中午到學七餐廳吃，有了北市賽的經驗，我馬上捨棄了自助餐這個選項，去吃豬排咖哩飯，90 元的餐卷真棒！！（據說從前只有 80 元，但因為去年那家店的價格是 89，釀成民怨，於是就加碼了！！但似乎有人吃自助餐吃到一百四？）
傍晚時，有人來看我&amp;hellip;&amp;hellip;（略）安慰了我很受傷的心。
晚上，自主練習&amp;hellip;&amp;hellip;八點半就放我們離開分部了。（累倒）
DAY 3 是邦一的課，開心的一天！！
早上在師大會館就遇到邦一了，Yunn 似乎早就認識他了～
早上是 greedy，下午表定是 Interval，其實參雜了不少 DP。
作業有 8 題，好像是開到星期天&amp;hellip;&amp;hellip;
先寫了一題 FCFS 排程（Greedy），然後試著寫帶權LIS，但真的寫不出來 QQ
晚上終於發了 I2A，今年特別高級，是硬殼版的！！
DAY 4 早上是自主練習，於是我就多次請教背後的 map 大神 wLIS，他救了我，超感激！還讓我認識了 map 的很多用法。其他人似乎忙著打 JOI，但我還是繼續嘗試邦一的題目，AC 了 independent tree（tree DP）、interval domination、給一堆線性函數求和的最大值（二分搜），總算跟上大部分人的進度了。
表定下午和晚上是 MST 和 Shortest Path，但香港人教授似乎聽說我們很強，於是上很快，拓樸排序、SSSP、MST、APSP，似乎上了兩小時他就走了。晚上只好變成自主練習，但我真的好累，於是就和男生們去玩拉密了（開啟耍廢狀態），但至少稍微和周柏宇和陳冠宇他們熟了一點點～</description>
    </item>
    
  </channel>
</rss>
